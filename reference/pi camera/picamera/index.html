

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Picamera 1.10 documentation</title>
  

  
  

  

  
  
    

  

  
  

  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  
    <link rel="stylesheet" href="_static/style_override.css" type="text/css" />
  
    <link rel="stylesheet" href="https://media.readthedocs.org/css/readthedocs-doc-embed.css" type="text/css" />
  

  
    <link rel="top" title="None" href="index.html#document-index"/>
 
<!-- RTD Extra Head -->

    

<!-- 
Always link to the latest version, as canonical.
http://docs.readthedocs.org/en/latest/canonical.html
-->
<link rel="canonical" href="http://picamera.readthedocs.org/en/release-1.10/" />
<script type="text/javascript">
  // This is included here because other places don't have access to the pagename variable.
  var READTHEDOCS_DATA = {
    project: "picamera",
    version: "release-1.10",
    language: "en",
    page: "index",
    builder: "sphinx",
    theme: "sphinx_rtd_theme",
    docroot: "/docs/",
    
    source_suffix: ".rst",
    
    api_host: "https://readthedocs.org/",
    commit: "6f36295e"
  }
  // Old variables
  var doc_version = "release-1.10";
  var doc_slug = "picamera";
  var page_name = "index";
  var html_theme = "sphinx_rtd_theme";
</script>
<!-- RTD Analytics Code -->
<!-- Included in the header because you don't have a footer block. -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-17997319-1']);
  _gaq.push(['_trackPageview']);


  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<!-- end RTD Analytics Code -->
<!-- end RTD <extrahead> -->


  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html#document-index" class="icon icon-home"> Picamera
          

          
          </a>

          
            
            
            
              <div class="version">
                release-1.10
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-install2">1. Python 2.7+ Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-install3">2. Python 3.2+ Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-quickstart">3. Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-recipes1">4. Basic Recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-recipes2">5. Advanced Recipes</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-faq">6. Frequently Asked Questions (FAQ)</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-fov">7. Camera Hardware</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-deprecated">8. Deprecated Functionality</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-api">9. API - <code class="docutils literal"><span class="pre">picamera</span></code> Package</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-api_camera">10. API - <code class="docutils literal"><span class="pre">picamera.camera</span></code> Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-api_encoders">11. API - <code class="docutils literal"><span class="pre">picamera.encoders</span></code> Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-api_streams">12. API - <code class="docutils literal"><span class="pre">picamera.streams</span></code> Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-api_renderers">13. API - <code class="docutils literal"><span class="pre">picamera.renderers</span></code> Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-api_color">14. API - <code class="docutils literal"><span class="pre">picamera.color</span></code> Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-api_array">15. API - <code class="docutils literal"><span class="pre">picamera.array</span></code> Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-api_exc">16. API - <code class="docutils literal"><span class="pre">picamera.exc</span></code> Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-changelog">17. Change log</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-license">18. License</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html#document-index">Picamera</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html#document-index">Docs</a> &raquo;</li>
      
    <li>Picamera 1.10 documentation</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="https://github.com/waveform80/picamera/blob/release-1.10/docs/index.rst" class="fa fa-github"> Edit on GitHub</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <span class="target" id="root"></span><div class="section" id="picamera">
<h1>picamera<a class="headerlink" href="#picamera" title="Permalink to this headline">¶</a></h1>
<p>This package provides a pure Python interface to the <a class="reference external" href="http://www.raspberrypi.org/">Raspberry Pi</a> <a class="reference external" href="http://www.raspberrypi.org/camera">camera</a>
module for Python 2.7 (or above) or Python 3.2 (or above).</p>
<div class="section" id="links">
<h2>Links<a class="headerlink" href="#links" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>The code is licensed under the <a class="reference external" href="http://opensource.org/licenses/BSD-3-Clause">BSD license</a></li>
<li>The <a class="reference external" href="https://github.com/waveform80/picamera">source code</a> can be obtained from GitHub, which also hosts the <a class="reference external" href="https://github.com/waveform80/picamera/issues">bug
tracker</a></li>
<li>The <a class="reference external" href="http://picamera.readthedocs.org/">documentation</a> (which includes installation, quick-start examples, and
lots of code recipes) can be read on ReadTheDocs</li>
<li>Packages can be downloaded from <a class="reference external" href="http://pypi.python.org/pypi/picamera/">PyPI</a>, but reading the installation
instructions is more likely to be useful</li>
</ul>
</div>
<div class="section" id="table-of-contents">
<h2>Table of Contents<a class="headerlink" href="#table-of-contents" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-install2"></span><div class="section" id="python-2-7-installation">
<span id="install2"></span><h3>Python 2.7+ Installation<a class="headerlink" href="#python-2-7-installation" title="Permalink to this headline">¶</a></h3>
<p>There are several ways to install picamera under Python 2.7 (or above), each
with their own advantages and disadvantages. Have a read of the sections below
and select an installation method which conforms to your needs.</p>
<div class="section" id="firmware-upgrades">
<span id="firmware2"></span><h4>Firmware upgrades<a class="headerlink" href="#firmware-upgrades" title="Permalink to this headline">¶</a></h4>
<p>The behaviour of the Pi&#8217;s camera module is dictated by the Pi&#8217;s firmware. Over
time, considerable work has gone into fixing bugs and extending the
functionality of the Pi&#8217;s camera module through new firmware releases. Whilst
the picamera library attempts to maintain backward compatibility with older Pi
firmwares, it is only tested against the latest firmware at the time of
release, and not all functionality may be available if you are running an older
firmware. As an example, the <a class="reference internal" href="index.html#picamera.camera.PiCamera.annotate_text" title="picamera.camera.PiCamera.annotate_text"><code class="xref py py-attr docutils literal"><span class="pre">annotate_text</span></code></a>
attribute relies on a recent firmware; older firmwares lacked the
functionality.</p>
<p>You can determine the revision of your current firmware with the following
command:</p>
<div class="highlight-python"><div class="highlight"><pre>$ uname -a
</pre></div>
</div>
<p>The firmware revision is the number after the <code class="docutils literal"><span class="pre">#</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>Linux kermit 3.12.26+ #707 PREEMPT Sat Aug 30 17:39:19 BST 2014 armv6l GNU/Linux
                        /
                       /
  firmware revision --+
</pre></div>
</div>
<p>On Raspbian, the standard upgrade procedure should keep your firmware
up to date:</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo apt-get update
$ sudo apt-get upgrade
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Previously, these documents have suggested using the <code class="docutils literal"><span class="pre">rpi-update</span></code> utility
to update the Pi&#8217;s firmware; this is now discouraged. If you have
previously used the <code class="docutils literal"><span class="pre">rpi-update</span></code> utility to update your firmware, you can
switch back to using <code class="docutils literal"><span class="pre">apt</span></code> to manage it with the following commands:</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo apt-get update
$ sudo apt-get install --reinstall libraspberrypi0 libraspberrypi-{bin,dev,doc} raspberrypi-bootloader
$ sudo rm /boot/.firmware_revision
</pre></div>
</div>
<p class="last">You will need to reboot after doing so.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Please note that the <a class="reference external" href="http://www.adafruit.com/product/1601">PiTFT</a> screen (and similar GPIO-driven screens)
requires a custom firmware for operation. This firmware lags behind the
official firmware and at the time of writing lacks several features
including long exposures and text overlays.</p>
</div>
</div>
<div class="section" id="raspbian-installation">
<span id="raspbian-install2"></span><h4>Raspbian installation<a class="headerlink" href="#raspbian-installation" title="Permalink to this headline">¶</a></h4>
<p>If you are using the <a class="reference external" href="http://www.raspbian.org/">Raspbian</a> distro, it is best to install picamera using
the system&#8217;s package manager: apt. This will ensure that picamera is easy to
keep up to date, and easy to remove should you wish to do so. It will also make
picamera available for all users on the system. To install picamera using apt
simply:</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo apt-get update
$ sudo apt-get install python-picamera
</pre></div>
</div>
<p>To upgrade your installation when new releases are made you can simply use
apt&#8217;s normal upgrade procedure:</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo apt-get update
$ sudo apt-get upgrade
</pre></div>
</div>
<p>If you ever need to remove your installation:</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo apt-get remove python-picamera
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you are using a recent installation of Raspbian, you may find that the
python-picamera package is already installed (it is included by default
in recent versions of <a class="reference external" href="http://www.raspberrypi.org/downloads/">NOOBS</a>).</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The release of the picamera package on Raspbian lags behind the release of
picamera packages on PyPI (see <a class="reference internal" href="#system-install2"><span>System installation</span></a> below) by a few days.
If you find yourself unable to upgrade immediately following a release
announcement, you can either switch to a PyPI installation or wait a few
days for the Raspbian packages to arrive in the repository.</p>
</div>
</div>
<div class="section" id="user-installation">
<span id="user-install2"></span><h4>User installation<a class="headerlink" href="#user-installation" title="Permalink to this headline">¶</a></h4>
<p>This is the simplest (non-apt) form of installation, but bear in mind that it
will only work for the user you install under. For example, if you install as
the <code class="docutils literal"><span class="pre">pi</span></code> user, you will only be able to use picamera as the <code class="docutils literal"><span class="pre">pi</span></code> user. If
you run python as root (e.g. with <code class="docutils literal"><span class="pre">sudo</span> <span class="pre">python</span></code>) it will not find the module.
See <a class="reference internal" href="#system-install2"><span>System installation</span></a> below if you require a root installation.</p>
<p>To install as your current user:</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo apt-get install python-pip
$ pip install --user picamera
</pre></div>
</div>
<p>If you wish to use the classes in the <a class="reference internal" href="index.html#module-picamera.array" title="picamera.array"><code class="xref py py-mod docutils literal"><span class="pre">picamera.array</span></code></a> module then specify
the &#8220;array&#8221; option which will pull in numpy as a dependency (be warned that
building numpy takes a <em>long</em> time on a Pi):</p>
<div class="highlight-python"><div class="highlight"><pre>$ pip install --user &quot;picamera[array]&quot;
</pre></div>
</div>
<p>Note that <code class="docutils literal"><span class="pre">pip</span></code> is <strong>not</strong> run with <code class="docutils literal"><span class="pre">sudo</span></code>; this is deliberate. To upgrade
your installation when new releases are made:</p>
<div class="highlight-python"><div class="highlight"><pre>$ pip install --user -U picamera
</pre></div>
</div>
<p>If you ever need to remove your installation:</p>
<div class="highlight-python"><div class="highlight"><pre>$ pip uninstall picamera
</pre></div>
</div>
</div>
<div class="section" id="system-installation">
<span id="system-install2"></span><h4>System installation<a class="headerlink" href="#system-installation" title="Permalink to this headline">¶</a></h4>
<p>A system installation will make picamera accessible to all users (in contrast
to the user installation). It is as simple to perform as the user installation
and equally easy to keep updated. To perform the installation:</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo apt-get install python-pip
$ sudo pip install picamera
</pre></div>
</div>
<p>If you wish to use the classes in the <a class="reference internal" href="index.html#module-picamera.array" title="picamera.array"><code class="xref py py-mod docutils literal"><span class="pre">picamera.array</span></code></a> module then specify
the &#8220;array&#8221; option which will pull in numpy as a dependency (be warned that
building numpy takes a <em>long</em> time on a Pi):</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo pip install &quot;picamera[array]&quot;
</pre></div>
</div>
<p>To upgrade your installation when new releases are made:</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo pip install -U picamera
</pre></div>
</div>
<p>If you ever need to remove your installation:</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo pip uninstall picamera
</pre></div>
</div>
</div>
<div class="section" id="virtualenv-installation">
<span id="virtualenv-install2"></span><h4>Virtualenv installation<a class="headerlink" href="#virtualenv-installation" title="Permalink to this headline">¶</a></h4>
<p>If you wish to install picamera within a virtualenv (useful if you&#8217;re working
on several Python projects with potentially conflicting dependencies, or you
just like keeping things separate and easily removable):</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo apt-get install python-pip python-virtualenv
$ virtualenv sandbox
$ source sandbox/bin/activate
(sandbox) $ pip install picamera
</pre></div>
</div>
<p>If you wish to use the classes in the <a class="reference internal" href="index.html#module-picamera.array" title="picamera.array"><code class="xref py py-mod docutils literal"><span class="pre">picamera.array</span></code></a> module then specify
the &#8220;array&#8221; option which will pull in numpy as a dependency (be warned that
building numpy takes a <em>long</em> time on a Pi):</p>
<div class="highlight-python"><div class="highlight"><pre>(sandbox) $ pip install &quot;picamera[array]&quot;
</pre></div>
</div>
<p>Bear in mind that each time you want to use picamera you will need to activate
the virtualenv before running Python:</p>
<div class="highlight-python"><div class="highlight"><pre>$ source sandbox/bin/activate
(sandbox) $ python
&gt;&gt;&gt; import picamera
</pre></div>
</div>
<p>To upgrade your installation, make sure the virtualenv is activated and just
use pip:</p>
<div class="highlight-python"><div class="highlight"><pre>$ source sandbox/bin/activate
(sandbox) $ pip install -U picamera
</pre></div>
</div>
<p>To remove your installation simply blow away the virtualenv:</p>
<div class="highlight-python"><div class="highlight"><pre>$ rm -fr ~/sandbox/
</pre></div>
</div>
</div>
<div class="section" id="development-installation">
<span id="dev-install2"></span><h4>Development installation<a class="headerlink" href="#development-installation" title="Permalink to this headline">¶</a></h4>
<p>If you wish to develop picamera itself, it is easiest to obtain the source by
cloning the GitHub repository and then use the &#8220;develop&#8221; target of the Makefile
which will install the package as a link to the cloned repository allowing
in-place development (it also builds a tags file for use with vim/emacs with
Exuberant&#8217;s ctags utility).  The following example demonstrates this method
within a virtual Python environment:</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo apt-get install build-essential git git-core exuberant-ctags \
    python-virtualenv
$ virtualenv sandbox
$ source sandbox/bin/activate
(sandbox) $ git clone https://github.com/waveform80/picamera.git
(sandbox) $ cd picamera
(sandbox) $ make develop
</pre></div>
</div>
<p>To pull the latest changes from git into your clone and update your
installation:</p>
<div class="highlight-python"><div class="highlight"><pre>$ source sandbox/bin/activate
(sandbox) $ cd picamera
(sandbox) $ git pull
(sandbox) $ make develop
</pre></div>
</div>
<p>To remove your installation blow away the sandbox and the clone:</p>
<div class="highlight-python"><div class="highlight"><pre>$ rm -fr ~/sandbox/ ~/picamera/
</pre></div>
</div>
<p>For anybody wishing to hack on the project please understand that although it
is technically written in pure Python, heavy use of <a class="reference external" href="http://docs.python.org/3.2/library/ctypes.html#module-ctypes" title="(in Python v3.2)"><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> is involved
so the code really doesn&#8217;t look much like Python - more a sort of horrid
mishmash of C and Python.</p>
<p>The project consists primarily of a class (<a class="reference internal" href="index.html#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a>)
which is a re-implementation of high-level bits of the <code class="docutils literal"><span class="pre">raspistill</span></code> and
<code class="docutils literal"><span class="pre">raspivid</span></code> commands using the <a class="reference external" href="http://docs.python.org/3.2/library/ctypes.html#module-ctypes" title="(in Python v3.2)"><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> based <code class="docutils literal"><span class="pre">libmmal</span></code> header
conversion, plus a set of <a class="reference internal" href="index.html#custom-encoders"><span>encoder classes</span></a> which
re-implement the encoder callback configuration in the aforementioned binaries.
Various classes for specialized applications also exist
(<a class="reference internal" href="index.html#picamera.streams.PiCameraCircularIO" title="picamera.streams.PiCameraCircularIO"><code class="xref py py-class docutils literal"><span class="pre">PiCameraCircularIO</span></code></a>,
<a class="reference internal" href="index.html#picamera.array.PiBayerArray" title="picamera.array.PiBayerArray"><code class="xref py py-class docutils literal"><span class="pre">PiBayerArray</span></code></a>, etc.)</p>
<p>Even if you don&#8217;t feel up to hacking on the code, I&#8217;d love to hear suggestions
from people of what you&#8217;d like the API to look like (even if the code itself
isn&#8217;t particularly pythonic, the interface should be)!</p>
</div>
<div class="section" id="test-suite">
<span id="test-suite2"></span><h4>Test suite<a class="headerlink" href="#test-suite" title="Permalink to this headline">¶</a></h4>
<p>If you wish to run the picamera test suite, follow the instructions in
<a class="reference internal" href="#dev-install2"><span>Development installation</span></a> above and then install the following additional
dependencies (note: avconv is installed system-wide):</p>
<div class="highlight-python"><div class="highlight"><pre>(sandbox) $ sudo apt-get install libav-tools
(sandbox) $ pip install Pillow pytest mock numpy
</pre></div>
</div>
<p>Finally, to run the test suite, execute the following command:</p>
<div class="highlight-python"><div class="highlight"><pre>(sandbox) $ make test
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The test suite takes a <em>very</em> long time to execute (at least 4 hours on an
overclocked Pi). Depending on configuration, it can also lockup the camera
requiring a reboot to reset, so ensure you are familiar with SSH or using
alternate TTYs to access a command line in the event you need to reboot.</p>
</div>
</div>
</div>
<span id="document-install3"></span><div class="section" id="python-3-2-installation">
<span id="install3"></span><h3>Python 3.2+ Installation<a class="headerlink" href="#python-3-2-installation" title="Permalink to this headline">¶</a></h3>
<p>There are several ways to install picamera under Python 3.2 (or above), each
with their own advantages and disadvantages. Have a read of the sections below
and select an installation method which conforms to your needs.</p>
<div class="section" id="firmware-upgrades">
<span id="firmware3"></span><h4>Firmware upgrades<a class="headerlink" href="#firmware-upgrades" title="Permalink to this headline">¶</a></h4>
<p>The behaviour of the Pi&#8217;s camera module is dictated by the Pi&#8217;s firmware. Over
time, considerable work has gone into fixing bugs and extending the
functionality of the Pi&#8217;s camera module through new firmware releases. Whilst
the picamera library attempts to maintain backward compatibility with older Pi
firmwares, it is only tested against the latest firmware at the time of
release, and not all functionality may be available if you are running an older
firmware. As an example, the <a class="reference internal" href="index.html#picamera.camera.PiCamera.annotate_text" title="picamera.camera.PiCamera.annotate_text"><code class="xref py py-attr docutils literal"><span class="pre">annotate_text</span></code></a>
attribute relies on a recent firmware; older firmwares lacked the
functionality.</p>
<p>You can determine the revision of your current firmware with the following
command:</p>
<div class="highlight-python"><div class="highlight"><pre>$ uname -a
</pre></div>
</div>
<p>The firmware revision is the number after the <code class="docutils literal"><span class="pre">#</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>Linux kermit 3.12.26+ #707 PREEMPT Sat Aug 30 17:39:19 BST 2014 armv6l GNU/Linux
                        /
                       /
  firmware revision --+
</pre></div>
</div>
<p>On Raspbian, the standard upgrade procedure should keep your firmware
up to date:</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo apt-get update
$ sudo apt-get upgrade
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Previously, these documents have suggested using the <code class="docutils literal"><span class="pre">rpi-update</span></code> utility
to update the Pi&#8217;s firmware; this is now discouraged. If you have
previously used the <code class="docutils literal"><span class="pre">rpi-update</span></code> utility to update your firmware, you can
switch back to using <code class="docutils literal"><span class="pre">apt</span></code> to manage it with the following commands:</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo apt-get update
$ sudo apt-get install --reinstall libraspberrypi0 libraspberrypi-{bin,dev,doc} raspberrypi-bootloader
$ sudo rm /boot/.firmware_revision
</pre></div>
</div>
<p class="last">You will need to reboot after doing so.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Please note that the <a class="reference external" href="http://www.adafruit.com/product/1601">PiTFT</a> screen (and similar GPIO-driven screens)
requires a custom firmware for operation. This firmware lags behind the
official firmware and at the time of writing lacks several features
including long exposures and text overlays.</p>
</div>
</div>
<div class="section" id="raspbian-installation">
<span id="raspbian-install3"></span><h4>Raspbian installation<a class="headerlink" href="#raspbian-installation" title="Permalink to this headline">¶</a></h4>
<p>If you are using the <a class="reference external" href="http://www.raspbian.org/">Raspbian</a> distro, it is best to install picamera using
the system&#8217;s package manager: apt. This will ensure that picamera is easy to
keep up to date, and easy to remove should you wish to do so. It will also make
picamera available for all users on the system. To install picamera using apt
simply:</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo apt-get update
$ sudo apt-get install python3-picamera
</pre></div>
</div>
<p>To upgrade your installation when new releases are made you can simply use
apt&#8217;s normal upgrade procedure:</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo apt-get update
$ sudo apt-get upgrade
</pre></div>
</div>
<p>If you ever need to remove your installation:</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo apt-get remove python3-picamera
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you are using a recent installation of Raspbian, you may find that the
python3-picamera package is already installed (it is included by default
in recent versions of <a class="reference external" href="http://www.raspberrypi.org/downloads/">NOOBS</a>).</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The release of the picamera package on Raspbian lags behind the release of
picamera packages on PyPI (see <a class="reference internal" href="index.html#system-install2"><span>System installation</span></a> below) by a few days.
If you find yourself unable to upgrade immediately following a release
announcement, you can either switch to a PyPI installation or wait a few
days for the Raspbian packages to arrive in the repository.</p>
</div>
</div>
<div class="section" id="user-installation">
<span id="user-install3"></span><h4>User installation<a class="headerlink" href="#user-installation" title="Permalink to this headline">¶</a></h4>
<p>This is the simplest (non-apt) form of installation (though it&#8217;s also complex
to uninstall should you wish to do so later), but bear in mind that it will
only work for the user you install under. For example, if you install as the
<code class="docutils literal"><span class="pre">pi</span></code> user, you will only be able to use picamera as the <code class="docutils literal"><span class="pre">pi</span></code> user. If you
run python as root (e.g. with <code class="docutils literal"><span class="pre">sudo</span> <span class="pre">python3</span></code>) it will not find the module.
See <a class="reference internal" href="#system-install3"><span>System installation</span></a> below if you require a root installation.</p>
<p>To install as your current user:</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo apt-get install python3-pip
$ pip-3.2 install --user picamera
</pre></div>
</div>
<p>If you wish to use the classes in the <a class="reference internal" href="index.html#module-picamera.array" title="picamera.array"><code class="xref py py-mod docutils literal"><span class="pre">picamera.array</span></code></a> module then specify
the &#8220;array&#8221; option which will pull in numpy as a dependency (be warned that
building numpy takes a <em>long</em> time on a Pi):</p>
<div class="highlight-python"><div class="highlight"><pre>$ pip-3.2 install --user &quot;picamera[array]&quot;
</pre></div>
</div>
<p>Note that <code class="docutils literal"><span class="pre">pip-3.2</span></code> is <strong>not</strong> run with <code class="docutils literal"><span class="pre">sudo</span></code>; this is deliberate. To
upgrade your installation when new releases are made:</p>
<div class="highlight-python"><div class="highlight"><pre>$ pip-3.2 install --user -U picamera
</pre></div>
</div>
<p>If you ever need to remove your installation:</p>
<div class="highlight-python"><div class="highlight"><pre>$ pip-3.2 uninstall picamera
</pre></div>
</div>
</div>
<div class="section" id="system-installation">
<span id="system-install3"></span><h4>System installation<a class="headerlink" href="#system-installation" title="Permalink to this headline">¶</a></h4>
<p>A system installation will make picamera accessible to all users (in contrast
to the user installation). It is as simple to perform as the user installation
and equally easy to keep updated. To perform the installation:</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo apt-get install python3-pip
$ sudo pip-3.2 install picamera
</pre></div>
</div>
<p>If you wish to use the classes in the <a class="reference internal" href="index.html#module-picamera.array" title="picamera.array"><code class="xref py py-mod docutils literal"><span class="pre">picamera.array</span></code></a> module then specify
the &#8220;array&#8221; option which will pull in numpy as a dependency (be warned that
building numpy takes a <em>long</em> time on a Pi):</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo pip-3.2 install &quot;picamera[array]&quot;
</pre></div>
</div>
<p>To upgrade your installation when new releases are made:</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo pip-3.2 install -U picamera
</pre></div>
</div>
<p>If you ever need to remove your installation:</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo pip-3.2 uninstall picamera
</pre></div>
</div>
</div>
<div class="section" id="virtualenv-installation">
<span id="virtualenv-install3"></span><h4>Virtualenv installation<a class="headerlink" href="#virtualenv-installation" title="Permalink to this headline">¶</a></h4>
<p>If you wish to install picamera within a virtualenv (useful if you&#8217;re working
on several Python projects with potentially conflicting dependencies, or you
just like keeping things separate and easily removable):</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo apt-get install python3-pip python-virtualenv
$ virtualenv -p python3 sandbox
$ source sandbox/bin/activate
(sandbox) $ pip-3.2 install picamera
</pre></div>
</div>
<p>If you wish to use the classes in the <a class="reference internal" href="index.html#module-picamera.array" title="picamera.array"><code class="xref py py-mod docutils literal"><span class="pre">picamera.array</span></code></a> module then specify
the &#8220;array&#8221; option which will pull in numpy as a dependency (be warned that
building numpy takes a <em>long</em> time on a Pi):</p>
<div class="highlight-python"><div class="highlight"><pre>(sandbox) $ pip-3.2 install &quot;picamera[array]&quot;
</pre></div>
</div>
<p>Bear in mind that each time you want to use picamera you will need to activate
the virtualenv before running Python:</p>
<div class="highlight-python"><div class="highlight"><pre>$ source sandbox/bin/activate
(sandbox) $ python
&gt;&gt;&gt; import picamera
</pre></div>
</div>
<p>To upgrade your installation, make sure the virtualenv is activated and just
use easy_install:</p>
<div class="highlight-python"><div class="highlight"><pre>$ source sandbox/bin/activate
(sandbox) $ pip-3.2 install -U picamera
</pre></div>
</div>
<p>To remove your installation simply blow away the virtualenv:</p>
<div class="highlight-python"><div class="highlight"><pre>$ rm -fr ~/sandbox/
</pre></div>
</div>
</div>
<div class="section" id="development-installation">
<span id="dev-install3"></span><h4>Development installation<a class="headerlink" href="#development-installation" title="Permalink to this headline">¶</a></h4>
<p>If you wish to develop picamera itself, it is easiest to obtain the source by
cloning the GitHub repository and then use the &#8220;develop&#8221; target of the Makefile
which will install the package as a link to the cloned repository allowing
in-place development (it also builds a tags file for use with vim/emacs with
Exuberant&#8217;s ctags utility).  The following example demonstrates this method
within a virtual Python environment:</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo apt-get install build-essential git git-core exuberant-ctags \
    python-virtualenv
$ virtualenv -p python3 sandbox
$ source sandbox/bin/activate
(sandbox) $ git clone https://github.com/waveform80/picamera.git
(sandbox) $ cd picamera
(sandbox) $ make develop
</pre></div>
</div>
<p>To pull the latest changes from git into your clone and update your
installation:</p>
<div class="highlight-python"><div class="highlight"><pre>$ source sandbox/bin/activate
(sandbox) $ cd picamera
(sandbox) $ git pull
(sandbox) $ make develop
</pre></div>
</div>
<p>To remove your installation blow away the sandbox and the clone:</p>
<div class="highlight-python"><div class="highlight"><pre>$ rm -fr ~/sandbox/ ~/picamera/
</pre></div>
</div>
<p>For anybody wishing to hack on the project please understand that although it
is technically written in pure Python, heavy use of <a class="reference external" href="http://docs.python.org/3.2/library/ctypes.html#module-ctypes" title="(in Python v3.2)"><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> is involved
so the code really doesn&#8217;t look much like Python - more a sort of horrid
mishmash of C and Python.</p>
<p>The project consists primarily of a class (<a class="reference internal" href="index.html#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a>)
which is a re-implementation of high-level bits of the <code class="docutils literal"><span class="pre">raspistill</span></code> and
<code class="docutils literal"><span class="pre">raspivid</span></code> commands using the <a class="reference external" href="http://docs.python.org/3.2/library/ctypes.html#module-ctypes" title="(in Python v3.2)"><code class="xref py py-mod docutils literal"><span class="pre">ctypes</span></code></a> based <code class="docutils literal"><span class="pre">libmmal</span></code> header
conversion, plus a set of <a class="reference internal" href="index.html#custom-encoders"><span>encoder classes</span></a> which
re-implement the encoder callback configuration in the aforementioned binaries.
Various classes for specialized applications also exist
(<a class="reference internal" href="index.html#picamera.streams.PiCameraCircularIO" title="picamera.streams.PiCameraCircularIO"><code class="xref py py-class docutils literal"><span class="pre">PiCameraCircularIO</span></code></a>,
<a class="reference internal" href="index.html#picamera.array.PiBayerArray" title="picamera.array.PiBayerArray"><code class="xref py py-class docutils literal"><span class="pre">PiBayerArray</span></code></a>, etc.)</p>
<p>Even if you don&#8217;t feel up to hacking on the code, I&#8217;d love to hear suggestions
from people of what you&#8217;d like the API to look like (even if the code itself
isn&#8217;t particularly pythonic, the interface should be)!</p>
</div>
<div class="section" id="test-suite">
<span id="test-suite3"></span><h4>Test suite<a class="headerlink" href="#test-suite" title="Permalink to this headline">¶</a></h4>
<p>If you wish to run the picamera test suite, follow the instructions in
<a class="reference internal" href="index.html#dev-install2"><span>Development installation</span></a> above and then install the following additional
dependencies (note: avconv is installed system-wide):</p>
<div class="highlight-python"><div class="highlight"><pre>(sandbox) $ sudo apt-get install libav-tools
(sandbox) $ pip install Pillow pytest mock numpy
</pre></div>
</div>
<p>Finally, to run the test suite, execute the following command:</p>
<div class="highlight-python"><div class="highlight"><pre>(sandbox) $ make test
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The test suite takes a <em>very</em> long time to execute (at least 4 hours on an
overclocked Pi). Depending on configuration, it can also lockup the camera
requiring a reboot to reset, so ensure you are familiar with SSH or using
alternate TTYs to access a command line in the event you need to reboot.</p>
</div>
</div>
</div>
<span id="document-quickstart"></span><div class="section" id="quick-start">
<span id="quickstart"></span><h3>Quick Start<a class="headerlink" href="#quick-start" title="Permalink to this headline">¶</a></h3>
<p>Start a preview for 10 seconds with the default settings:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="n">camera</span> <span class="o">=</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">stop_preview</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that you should always ensure you call
<a class="reference internal" href="index.html#picamera.camera.PiCamera.close" title="picamera.camera.PiCamera.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> on the PiCamera object to clean up
resources.  The following example demonstrates that Python&#8217;s <code class="docutils literal"><span class="pre">with</span></code> statement
can be used to achieve this implicitly; when the <code class="docutils literal"><span class="pre">with</span></code> block ends,
<a class="reference internal" href="index.html#picamera.camera.PiCamera.close" title="picamera.camera.PiCamera.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> will be called implicitly:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">stop_preview</span><span class="p">()</span>
</pre></div>
</div>
<p>The following example shows that certain properties can be adjusted &#8220;live&#8221;
while a preview is running. In this case, the brightness is increased steadily
during display:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
            <span class="n">camera</span><span class="o">.</span><span class="n">brightness</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">stop_preview</span><span class="p">()</span>
</pre></div>
</div>
<p>The next example demonstrates setting the camera resolution (this can only be
done when the camera is not recording) to 640x480, then starting a preview and
a recording to a disk file:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_recording</span><span class="p">(</span><span class="s">&#39;foo.h264&#39;</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">stop_recording</span><span class="p">()</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">stop_preview</span><span class="p">()</span>
</pre></div>
</div>
<p>The camera&#8217;s default resolution is the display&#8217;s resolution. If the display has
been disabled (e.g. with <cite>tvservice -o</cite>), then the default resolution is
1280x720.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Note that <a class="reference internal" href="index.html#picamera.camera.PiCamera.wait_recording" title="picamera.camera.PiCamera.wait_recording"><code class="xref py py-meth docutils literal"><span class="pre">wait_recording()</span></code></a> is used above
instead of <a class="reference external" href="http://docs.python.org/3.2/library/time.html#time.sleep" title="(in Python v3.2)"><code class="xref py py-func docutils literal"><span class="pre">time.sleep()</span></code></a>. This method checks for errors (e.g. out of
disk space) while the recording is running and raises an exception if one
occurs. If <a class="reference external" href="http://docs.python.org/3.2/library/time.html#time.sleep" title="(in Python v3.2)"><code class="xref py py-func docutils literal"><span class="pre">time.sleep()</span></code></a> was used instead the exception would be
raised by <a class="reference internal" href="index.html#picamera.camera.PiCamera.stop_recording" title="picamera.camera.PiCamera.stop_recording"><code class="xref py py-meth docutils literal"><span class="pre">stop_recording()</span></code></a> but only after
the full waiting time had run.</p>
</div>
<p>This example demonstrates starting a preview, setting some parameters
and then capturing an image while the preview is running:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">exposure_compensation</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">exposure_mode</span> <span class="o">=</span> <span class="s">&#39;spotlight&#39;</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">meter_mode</span> <span class="o">=</span> <span class="s">&#39;matrix&#39;</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">image_effect</span> <span class="o">=</span> <span class="s">&#39;gpen&#39;</span>
    <span class="c"># Give the camera some time to adjust to conditions</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="s">&#39;foo.jpg&#39;</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">stop_preview</span><span class="p">()</span>
</pre></div>
</div>
<p>The following example customizes the Exif tags to embed in the image before
calling <a class="reference internal" href="index.html#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2592</span><span class="p">,</span> <span class="mi">1944</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">exif_tags</span><span class="p">[</span><span class="s">&#39;IFD0.Artist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;Me!&#39;</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">exif_tags</span><span class="p">[</span><span class="s">&#39;IFD0.Copyright&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;Copyright (c) 2013 Me!&#39;</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="s">&#39;foo.jpg&#39;</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">stop_preview</span><span class="p">()</span>
</pre></div>
</div>
<p>See the documentation for <a class="reference internal" href="index.html#picamera.camera.PiCamera.exif_tags" title="picamera.camera.PiCamera.exif_tags"><code class="xref py py-attr docutils literal"><span class="pre">exif_tags</span></code></a> for a
complete list of the supported tags.</p>
<p>The next example demonstrates capturing a series of images as a numbered series
with a one minute delay between each capture using the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture_continuous" title="picamera.camera.PiCamera.capture_continuous"><code class="xref py py-meth docutils literal"><span class="pre">capture_continuous()</span></code></a> method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">filename</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">camera</span><span class="o">.</span><span class="n">capture_continuous</span><span class="p">(</span><span class="s">&#39;image{counter:02d}.jpg&#39;</span><span class="p">)):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Captured image </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">100</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">stop_preview</span><span class="p">()</span>
</pre></div>
</div>
<p>This example demonstrates capturing low resolution JPEGs extremely rapidly
using the video-port capability of the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture_sequence" title="picamera.camera.PiCamera.capture_sequence"><code class="xref py py-meth docutils literal"><span class="pre">capture_sequence()</span></code></a> method. The framerate of the
captures is displayed afterward:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture_sequence</span><span class="p">((</span>
        <span class="s">&#39;image</span><span class="si">%03d</span><span class="s">.jpg&#39;</span> <span class="o">%</span> <span class="n">i</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">120</span><span class="p">)</span>
        <span class="p">),</span> <span class="n">use_video_port</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Captured 120 images at </span><span class="si">%.2f</span><span class="s">fps&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">120</span> <span class="o">/</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)))</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">stop_preview</span><span class="p">()</span>
</pre></div>
</div>
<p>This example demonstrates capturing an unencoded image in RGB format and
producing a <a class="reference external" href="http://www.numpy.org/">numpy</a> array from the image:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">picamera.array</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">PiRGBArray</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span> <span class="k">as</span> <span class="n">stream</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">768</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="s">&#39;rgb&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-recipes1"></span><div class="section" id="basic-recipes">
<span id="recipes1"></span><h3>Basic Recipes<a class="headerlink" href="#basic-recipes" title="Permalink to this headline">¶</a></h3>
<p>The following recipes should be reasonably accessible to Python programmers of
all skill levels. Please feel free to suggest enhancements or additional
recipes.</p>
<div class="section" id="capturing-to-a-file">
<span id="file-capture"></span><h4>Capturing to a file<a class="headerlink" href="#capturing-to-a-file" title="Permalink to this headline">¶</a></h4>
<p>Capturing an image to a file is as simple as specifying the name of the file as
the output of whatever <a class="reference internal" href="index.html#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a> method you
require:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">768</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="c"># Camera warm-up time</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="s">&#39;foo.jpg&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that files opened by picamera (as in the case above) will be flushed and
closed so that when the capture method returns, the data should be accessible
to other processes.</p>
</div>
<div class="section" id="capturing-to-a-stream">
<span id="stream-capture"></span><h4>Capturing to a stream<a class="headerlink" href="#capturing-to-a-stream" title="Permalink to this headline">¶</a></h4>
<p>Capturing an image to a file-like object (a <a class="reference external" href="http://docs.python.org/3.2/library/socket.html#socket.socket" title="(in Python v3.2)"><code class="xref py py-func docutils literal"><span class="pre">socket()</span></code></a>, a
<a class="reference external" href="http://docs.python.org/3.2/library/io.html#io.BytesIO" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">io.BytesIO</span></code></a> stream, an existing open file object, etc.) is as simple as
specifying that object as the output of whatever
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a> method you&#8217;re using:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="c"># Create an in-memory stream</span>
<span class="n">my_stream</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="c"># Camera warm-up time</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">my_stream</span><span class="p">,</span> <span class="s">&#39;jpeg&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that the format is explicitly specified in the case above. The
<a class="reference external" href="http://docs.python.org/3.2/library/io.html#io.BytesIO" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">BytesIO</span></code></a> object has no filename, so the camera can&#8217;t automatically
figure out what format to use.</p>
<p>One thing to bear in mind is that (unlike specifying a filename), the stream is
<em>not</em> automatically closed after capture; picamera assumes that since it didn&#8217;t
open the stream it can&#8217;t presume to close it either. However, if the object has
a <code class="docutils literal"><span class="pre">flush</span></code> method, this will be called prior to capture returning. This should
ensure that once capture returns the data is accessible to other processes
although the object still needs to be closed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="c"># Explicitly open a new file called my_image.jpg</span>
<span class="n">my_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;my_image.jpg&#39;</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">)</span>
<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">my_file</span><span class="p">)</span>
<span class="c"># At this point my_file.flush() has been called, but the file has</span>
<span class="c"># not yet been closed</span>
<span class="n">my_file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that in the case above, we didn&#8217;t have to specify the format as the camera
interrogated the <code class="docutils literal"><span class="pre">my_file</span></code> object for its filename (specifically, it looks
for a <code class="docutils literal"><span class="pre">name</span></code> attribute on the provided object). As well as using stream
classes built into Python (like <a class="reference external" href="http://docs.python.org/3.2/library/io.html#io.BytesIO" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">BytesIO</span></code></a>) you can also construct
your own <a class="reference internal" href="index.html#custom-outputs"><span>custom outputs</span></a>.</p>
</div>
<div class="section" id="capturing-to-a-pil-image">
<span id="pil-capture"></span><h4>Capturing to a PIL Image<a class="headerlink" href="#capturing-to-a-pil-image" title="Permalink to this headline">¶</a></h4>
<p>This is a variation on <a class="reference internal" href="#stream-capture"><span>Capturing to a stream</span></a>. First we&#8217;ll capture an image to a
<a class="reference external" href="http://docs.python.org/3.2/library/io.html#io.BytesIO" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">BytesIO</span></code></a> stream (Python&#8217;s in-memory stream class), then we&#8217;ll
rewind the position of the stream to the start, and read the stream into a
<a class="reference external" href="http://effbot.org/imagingbook/pil-index.htm">PIL</a> Image object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>

<span class="c"># Create the in-memory stream</span>
<span class="n">stream</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;jpeg&#39;</span><span class="p">)</span>
<span class="c"># &quot;Rewind&quot; the stream to the beginning so we can read its content</span>
<span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="capturing-to-an-opencv-object">
<span id="opencv-capture"></span><h4>Capturing to an OpenCV object<a class="headerlink" href="#capturing-to-an-opencv-object" title="Permalink to this headline">¶</a></h4>
<p>This is another variation on <a class="reference internal" href="#stream-capture"><span>Capturing to a stream</span></a>. First we&#8217;ll capture an
image to a <a class="reference external" href="http://docs.python.org/3.2/library/io.html#io.BytesIO" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">BytesIO</span></code></a> stream (Python&#8217;s in-memory stream class), then
convert the stream to a numpy array and read the array with <a class="reference external" href="http://opencv.org/">OpenCV</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="c"># Create the in-memory stream</span>
<span class="n">stream</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;jpeg&#39;</span><span class="p">)</span>
<span class="c"># Construct a numpy array from the stream</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">getvalue</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="c"># &quot;Decode&quot; the image from the array, preserving colour</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imdecode</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="c"># OpenCV returns an array with data in BGR order. If you want RGB instead</span>
<span class="c"># use the following...</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>If you want to avoid the JPEG encoding and decoding (which is lossy) and
potentially speed up the process, you can now use the classes in the
<a class="reference internal" href="index.html#module-picamera.array" title="picamera.array"><code class="xref py py-mod docutils literal"><span class="pre">picamera.array</span></code></a> module. As OpenCV images are simply numpy arrays arranged
in BGR order, one can use the <a class="reference internal" href="index.html#picamera.array.PiRGBArray" title="picamera.array.PiRGBArray"><code class="xref py py-class docutils literal"><span class="pre">PiRGBArray</span></code></a> class and
simply capture with the <code class="docutils literal"><span class="pre">'bgr'</span></code> format (given that RGB and BGR data is the
same size and configuration, just with reversed color planes):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">picamera.array</span>
<span class="kn">import</span> <span class="nn">cv2</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">PiRGBArray</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span> <span class="k">as</span> <span class="n">stream</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;bgr&#39;</span><span class="p">)</span>
        <span class="c"># At this point the image is available as stream.array</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">array</span>
</pre></div>
</div>
</div>
<div class="section" id="capturing-resized-images">
<span id="resize-capture"></span><h4>Capturing resized images<a class="headerlink" href="#capturing-resized-images" title="Permalink to this headline">¶</a></h4>
<p>Sometimes, particularly in scripts which will perform some sort of analysis or
processing on images, you may wish to capture smaller images than the current
resolution of the camera. Although such resizing can be performed using
libraries like PIL or OpenCV, it is considerably more efficient to have the
Pi&#8217;s GPU perform the resizing when capturing the image. This can be done with
the <em>resize</em> parameter of the <a class="reference internal" href="index.html#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a>
methods:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">768</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="c"># Camera warm-up time</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="s">&#39;foo.jpg&#39;</span><span class="p">,</span> <span class="n">resize</span><span class="o">=</span><span class="p">(</span><span class="mi">320</span><span class="p">,</span> <span class="mi">240</span><span class="p">))</span>
</pre></div>
</div>
<p>The <em>resize</em> parameter can also be specified when recording video with the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> method.</p>
</div>
<div class="section" id="capturing-consistent-images">
<span id="consistent-capture"></span><h4>Capturing consistent images<a class="headerlink" href="#capturing-consistent-images" title="Permalink to this headline">¶</a></h4>
<p>You may wish to capture a sequence of images all of which look the same in
terms of brightness, color, and contrast (this can be useful in timelapse
photography, for example). Various attributes need to be used in order to
ensure consistency across multiple shots. Specifically, you need to ensure that
the camera&#8217;s exposure time, white balance, and gains are all fixed:</p>
<ul class="simple">
<li>To fix exposure time, set the <a class="reference internal" href="index.html#picamera.camera.PiCamera.shutter_speed" title="picamera.camera.PiCamera.shutter_speed"><code class="xref py py-attr docutils literal"><span class="pre">shutter_speed</span></code></a>
attribute to a reasonable value.</li>
<li>To fix exposure gains, let <a class="reference internal" href="index.html#picamera.camera.PiCamera.analog_gain" title="picamera.camera.PiCamera.analog_gain"><code class="xref py py-attr docutils literal"><span class="pre">analog_gain</span></code></a> and
<a class="reference internal" href="index.html#picamera.camera.PiCamera.digital_gain" title="picamera.camera.PiCamera.digital_gain"><code class="xref py py-attr docutils literal"><span class="pre">digital_gain</span></code></a> settle on reasonable values,
then set <a class="reference internal" href="index.html#picamera.camera.PiCamera.exposure_mode" title="picamera.camera.PiCamera.exposure_mode"><code class="xref py py-attr docutils literal"><span class="pre">exposure_mode</span></code></a> to <code class="docutils literal"><span class="pre">'off'</span></code>.</li>
<li>To fix white balance, set the <a class="reference internal" href="index.html#picamera.camera.PiCamera.awb_mode" title="picamera.camera.PiCamera.awb_mode"><code class="xref py py-attr docutils literal"><span class="pre">awb_mode</span></code></a> to
<code class="docutils literal"><span class="pre">'off'</span></code>, then set <a class="reference internal" href="index.html#picamera.camera.PiCamera.awb_gains" title="picamera.camera.PiCamera.awb_gains"><code class="xref py py-attr docutils literal"><span class="pre">awb_gains</span></code></a> to a (red,
blue) tuple of gains.</li>
<li>Optionally, set <a class="reference internal" href="index.html#picamera.camera.PiCamera.iso" title="picamera.camera.PiCamera.iso"><code class="xref py py-attr docutils literal"><span class="pre">iso</span></code></a> to a fixed value.</li>
</ul>
<p>It can be difficult to know what appropriate values might be for these
attributes.  For <a class="reference internal" href="index.html#picamera.camera.PiCamera.iso" title="picamera.camera.PiCamera.iso"><code class="xref py py-attr docutils literal"><span class="pre">iso</span></code></a>, a simple rule of thumb
is that 100 and 200 are reasonable values for daytime, while 400 and 800 are
better for low light. To determine a reasonable value for
<a class="reference internal" href="index.html#picamera.camera.PiCamera.shutter_speed" title="picamera.camera.PiCamera.shutter_speed"><code class="xref py py-attr docutils literal"><span class="pre">shutter_speed</span></code></a> you can query the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.exposure_speed" title="picamera.camera.PiCamera.exposure_speed"><code class="xref py py-attr docutils literal"><span class="pre">exposure_speed</span></code></a> attribute.  For exposure
gains, it&#8217;s usually enough to wait until
<a class="reference internal" href="index.html#picamera.camera.PiCamera.analog_gain" title="picamera.camera.PiCamera.analog_gain"><code class="xref py py-attr docutils literal"><span class="pre">analog_gain</span></code></a> is greater than 1 (the default,
which will produce entirely black frames) before
<a class="reference internal" href="index.html#picamera.camera.PiCamera.exposure_mode" title="picamera.camera.PiCamera.exposure_mode"><code class="xref py py-attr docutils literal"><span class="pre">exposure_mode</span></code></a> is set to <code class="docutils literal"><span class="pre">'off'</span></code>.  Finally,
to determine reasonable values for <a class="reference internal" href="index.html#picamera.camera.PiCamera.awb_gains" title="picamera.camera.PiCamera.awb_gains"><code class="xref py py-attr docutils literal"><span class="pre">awb_gains</span></code></a>
simply query the property while <a class="reference internal" href="index.html#picamera.camera.PiCamera.awb_mode" title="picamera.camera.PiCamera.awb_mode"><code class="xref py py-attr docutils literal"><span class="pre">awb_mode</span></code></a> is
set to something other than <code class="docutils literal"><span class="pre">'off'</span></code>.  Again, this will tell you the camera&#8217;s
white balance gains as determined by the auto-white-balance algorithm.</p>
<p>The following script provides a brief example of configuring these settings:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="c"># Wait for the automatic gain control to settle</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="c"># Now fix the values</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">shutter_speed</span> <span class="o">=</span> <span class="n">camera</span><span class="o">.</span><span class="n">exposure_speed</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">exposure_mode</span> <span class="o">=</span> <span class="s">&#39;off&#39;</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">camera</span><span class="o">.</span><span class="n">awb_gains</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">awb_mode</span> <span class="o">=</span> <span class="s">&#39;off&#39;</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">awb_gains</span> <span class="o">=</span> <span class="n">g</span>
    <span class="c"># Finally, take several photos with the fixed settings</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture_sequence</span><span class="p">([</span><span class="s">&#39;image</span><span class="si">%02d</span><span class="s">.jpg&#39;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)])</span>
</pre></div>
</div>
</div>
<div class="section" id="capturing-timelapse-sequences">
<span id="timelapse-capture"></span><h4>Capturing timelapse sequences<a class="headerlink" href="#capturing-timelapse-sequences" title="Permalink to this headline">¶</a></h4>
<p>The simplest way to capture long time-lapse sequences is with the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture_continuous" title="picamera.camera.PiCamera.capture_continuous"><code class="xref py py-meth docutils literal"><span class="pre">capture_continuous()</span></code></a> method. With this method,
the camera captures images continually until you tell it to stop. Images are
automatically given unique names and you can easily control the delay between
captures. The following example shows how to capture images with a 5 minute
delay between each shot:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">camera</span><span class="o">.</span><span class="n">capture_continuous</span><span class="p">(</span><span class="s">&#39;img{counter:03d}.jpg&#39;</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Captured </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">300</span><span class="p">)</span> <span class="c"># wait 5 minutes</span>
</pre></div>
</div>
<p>However, you may wish to capture images at a particular time, say at the start
of every hour. This simply requires a refinement of the delay in the loop (the
<a class="reference external" href="http://docs.python.org/3.2/library/datetime.html#module-datetime" title="(in Python v3.2)"><code class="xref py py-mod docutils literal"><span class="pre">datetime</span></code></a> module is slightly easier to use for calculating dates and
times; this example also demonstrates the <code class="docutils literal"><span class="pre">timestamp</span></code> template in the
captured filenames):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>

<span class="k">def</span> <span class="nf">wait</span><span class="p">():</span>
    <span class="c"># Calculate the delay to the start of the next hour</span>
    <span class="n">next_hour</span> <span class="o">=</span> <span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">hour</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
        <span class="n">minute</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">second</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">microsecond</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">delay</span> <span class="o">=</span> <span class="p">(</span><span class="n">next_hour</span> <span class="o">-</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">())</span><span class="o">.</span><span class="n">seconds</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">wait</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">camera</span><span class="o">.</span><span class="n">capture_continuous</span><span class="p">(</span><span class="s">&#39;img{timestamp:%Y-%m-</span><span class="si">%d</span><span class="s">-%H-%M}.jpg&#39;</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Captured </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
        <span class="n">wait</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="capturing-in-low-light">
<span id="dark-capture"></span><h4>Capturing in low light<a class="headerlink" href="#capturing-in-low-light" title="Permalink to this headline">¶</a></h4>
<p>Using similar tricks to those in <a class="reference internal" href="#consistent-capture"><span>Capturing consistent images</span></a>, the Pi&#8217;s camera can
capture images in low light conditions. The primary objective is to set a high
gain, and a long exposure time to allow the camera to gather as much light as
possible. However, the <a class="reference internal" href="index.html#picamera.camera.PiCamera.shutter_speed" title="picamera.camera.PiCamera.shutter_speed"><code class="xref py py-attr docutils literal"><span class="pre">shutter_speed</span></code></a>
attribute is constrained by the camera&#8217;s
<a class="reference internal" href="index.html#picamera.camera.PiCamera.framerate" title="picamera.camera.PiCamera.framerate"><code class="xref py py-attr docutils literal"><span class="pre">framerate</span></code></a> so the first thing we need to do is
set a very slow framerate. The following script captures an image with a 6
second exposure time (the maximum the Pi&#8217;s camera module is currently capable
of):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>
<span class="kn">from</span> <span class="nn">fractions</span> <span class="kn">import</span> <span class="n">Fraction</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">)</span>
    <span class="c"># Set a framerate of 1/6fps, then set shutter</span>
    <span class="c"># speed to 6s and ISO to 800</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">shutter_speed</span> <span class="o">=</span> <span class="mi">6000000</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">exposure_mode</span> <span class="o">=</span> <span class="s">&#39;off&#39;</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">iso</span> <span class="o">=</span> <span class="mi">800</span>
    <span class="c"># Give the camera a good long time to measure AWB</span>
    <span class="c"># (you may wish to use fixed AWB instead)</span>
    <span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="c"># Finally, capture an image with a 6s exposure. Due</span>
    <span class="c"># to mode switching on the still port, this will take</span>
    <span class="c"># longer than 6 seconds</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="s">&#39;dark.jpg&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In anything other than dark conditions, the image produced by this script will
most likely be completely white or at least heavily over-exposed.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The Pi&#8217;s camera module uses a <a class="reference external" href="http://en.wikipedia.org/wiki/Rolling_shutter">rolling shutter</a>. This means that moving
subjects may appear distorted if they move relative to the camera. This
effect will be exaggerated by using longer exposure times.</p>
</div>
</div>
<div class="section" id="capturing-to-a-network-stream">
<span id="streaming-capture"></span><h4>Capturing to a network stream<a class="headerlink" href="#capturing-to-a-network-stream" title="Permalink to this headline">¶</a></h4>
<p>This is a variation of <a class="reference internal" href="#timelapse-capture"><span>Capturing timelapse sequences</span></a>. Here we have two scripts: a
server (presumably on a fast machine) which listens for a connection from the
Raspberry Pi, and a client which runs on the Raspberry Pi and sends a continual
stream of images to the server. We&#8217;ll use a very simple protocol for
communication: first the length of the image will be sent as a 32-bit integer
(in <a class="reference external" href="http://en.wikipedia.org/wiki/Endianness">Little Endian</a> format), then this will be followed by the bytes of image
data. If the length is 0, this indicates that the connection should be closed
as no more images will be forthcoming. This protocol is illustrated below:</p>
<div align="center" class="align-center"><img src="_images/image_protocol.svg" /></div>
<p>Firstly the server script (which relies on PIL for reading JPEGs, but you could
replace this with any other suitable graphics library, e.g. OpenCV or
GraphicsMagick):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>

<span class="c"># Start a socket listening for connections on 0.0.0.0:8000 (0.0.0.0 means</span>
<span class="c"># all interfaces)</span>
<span class="n">server_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="n">server_socket</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s">&#39;0.0.0.0&#39;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">))</span>
<span class="n">server_socket</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c"># Accept a single connection and make a file-like object out of it</span>
<span class="n">connection</span> <span class="o">=</span> <span class="n">server_socket</span><span class="o">.</span><span class="n">accept</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">makefile</span><span class="p">(</span><span class="s">&#39;rb&#39;</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="c"># Read the length of the image as a 32-bit unsigned int. If the</span>
        <span class="c"># length is zero, quit the loop</span>
        <span class="n">image_len</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s">&#39;&lt;L&#39;</span><span class="p">,</span> <span class="n">connection</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">calcsize</span><span class="p">(</span><span class="s">&#39;&lt;L&#39;</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">image_len</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="c"># Construct a stream to hold the image data and read the image</span>
        <span class="c"># data from the connection</span>
        <span class="n">image_stream</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
        <span class="n">image_stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">connection</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">image_len</span><span class="p">))</span>
        <span class="c"># Rewind the stream, open it as an image with PIL and do some</span>
        <span class="c"># processing on it</span>
        <span class="n">image_stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">image_stream</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Image is </span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">image</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">image</span><span class="o">.</span><span class="n">verify</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Image is verified&#39;</span><span class="p">)</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">server_socket</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>Now for the client side of things, on the Raspberry Pi:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="c"># Connect a client socket to my_server:8000 (change my_server to the</span>
<span class="c"># hostname of your server)</span>
<span class="n">client_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="n">client_socket</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s">&#39;my_server&#39;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">))</span>

<span class="c"># Make a file-like object out of the connection</span>
<span class="n">connection</span> <span class="o">=</span> <span class="n">client_socket</span><span class="o">.</span><span class="n">makefile</span><span class="p">(</span><span class="s">&#39;wb&#39;</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
        <span class="c"># Start a preview and let the camera warm up for 2 seconds</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

        <span class="c"># Note the start time and construct a stream to hold image data</span>
        <span class="c"># temporarily (we could write it directly to connection but in this</span>
        <span class="c"># case we want to find out the size of each capture first to keep</span>
        <span class="c"># our protocol simple)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">foo</span> <span class="ow">in</span> <span class="n">camera</span><span class="o">.</span><span class="n">capture_continuous</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="s">&#39;jpeg&#39;</span><span class="p">):</span>
            <span class="c"># Write the length of the capture to the stream and flush to</span>
            <span class="c"># ensure it actually gets sent</span>
            <span class="n">connection</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">&#39;&lt;L&#39;</span><span class="p">,</span> <span class="n">stream</span><span class="o">.</span><span class="n">tell</span><span class="p">()))</span>
            <span class="n">connection</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="c"># Rewind the stream and send the image data over the wire</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">connection</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
            <span class="c"># If we&#39;ve been capturing for more than 30 seconds, quit</span>
            <span class="k">if</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="c"># Reset the stream for the next capture</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span>
    <span class="c"># Write a length of zero to the stream to signal we&#39;re done</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">&#39;&lt;L&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">client_socket</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>The server script should be run first to ensure there&#8217;s a listening socket
ready to accept a connection from the client script.</p>
</div>
<div class="section" id="recording-video-to-a-file">
<span id="file-record"></span><h4>Recording video to a file<a class="headerlink" href="#recording-video-to-a-file" title="Permalink to this headline">¶</a></h4>
<p>Recording a video to a file is simple:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_recording</span><span class="p">(</span><span class="s">&#39;my_video.h264&#39;</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">stop_recording</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that we use <a class="reference internal" href="index.html#picamera.camera.PiCamera.wait_recording" title="picamera.camera.PiCamera.wait_recording"><code class="xref py py-meth docutils literal"><span class="pre">wait_recording()</span></code></a> in the
example above instead of <a class="reference external" href="http://docs.python.org/3.2/library/time.html#time.sleep" title="(in Python v3.2)"><code class="xref py py-func docutils literal"><span class="pre">time.sleep()</span></code></a> which we&#8217;ve been using in the image
capture recipes above. The <a class="reference internal" href="index.html#picamera.camera.PiCamera.wait_recording" title="picamera.camera.PiCamera.wait_recording"><code class="xref py py-meth docutils literal"><span class="pre">wait_recording()</span></code></a>
method is similar in that it will pause for the number of seconds specified,
but unlike <a class="reference external" href="http://docs.python.org/3.2/library/time.html#time.sleep" title="(in Python v3.2)"><code class="xref py py-func docutils literal"><span class="pre">time.sleep()</span></code></a> it will continually check for recording errors
(e.g. an out of disk space condition) while it is waiting. If we had used
<a class="reference external" href="http://docs.python.org/3.2/library/time.html#time.sleep" title="(in Python v3.2)"><code class="xref py py-func docutils literal"><span class="pre">time.sleep()</span></code></a> instead, such errors would only be raised by the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.stop_recording" title="picamera.camera.PiCamera.stop_recording"><code class="xref py py-meth docutils literal"><span class="pre">stop_recording()</span></code></a> call (which could be long
after the error actually occurred).</p>
</div>
<div class="section" id="recording-video-to-a-stream">
<span id="stream-record"></span><h4>Recording video to a stream<a class="headerlink" href="#recording-video-to-a-stream" title="Permalink to this headline">¶</a></h4>
<p>This is very similar to <a class="reference internal" href="#file-record"><span>Recording video to a file</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="n">stream</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_recording</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;h264&#39;</span><span class="p">,</span> <span class="n">quality</span><span class="o">=</span><span class="mi">23</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">stop_recording</span><span class="p">()</span>
</pre></div>
</div>
<p>Here, we&#8217;ve set the <em>quality</em> parameter to indicate to the encoder the level
of image quality that we&#8217;d like it to try and maintain. The camera&#8217;s H.264
encoder is primarily constrained by two parameters:</p>
<ul class="simple">
<li><em>bitrate</em> limits the encoder&#8217;s output to a certain number of bits per second.
The default is 17000000 (17Mbps), and the maximum value is 25000000 (25Mbps).
Higher values give the encoder more &#8220;freedom&#8221; to encode at higher qualities.
You will likely find that the default doesn&#8217;t constrain the encoder at all
except at higher recording resolutions.</li>
<li><em>quality</em> tells the encoder what level of image quality to maintain. Values
can be between 1 (highest quality) and 40 (lowest quality), with typical
values providing a reasonable trade-off between bandwidth and quality being
between 20 and 25.</li>
</ul>
<p>As well as using stream classes built into Python (like <a class="reference external" href="http://docs.python.org/3.2/library/io.html#io.BytesIO" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">BytesIO</span></code></a>)
you can also construct your own <a class="reference internal" href="index.html#custom-outputs"><span>custom outputs</span></a>. This is
particularly useful for video recording, as discussed in the linked recipe.</p>
</div>
<div class="section" id="recording-over-multiple-files">
<span id="split-record"></span><h4>Recording over multiple files<a class="headerlink" href="#recording-over-multiple-files" title="Permalink to this headline">¶</a></h4>
<p>If you wish split your recording over multiple files, you can use the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.split_recording" title="picamera.camera.PiCamera.split_recording"><code class="xref py py-meth docutils literal"><span class="pre">split_recording()</span></code></a> method to accomplish this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_recording</span><span class="p">(</span><span class="s">&#39;1.h264&#39;</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">11</span><span class="p">):</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">split_recording</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%d</span><span class="s">.h264&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">stop_recording</span><span class="p">()</span>
</pre></div>
</div>
<p>This should produce 10 video files named <code class="docutils literal"><span class="pre">1.h264</span></code>, <code class="docutils literal"><span class="pre">2.h264</span></code>, etc. each of
which is approximately 5 seconds long (approximately because the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.split_recording" title="picamera.camera.PiCamera.split_recording"><code class="xref py py-meth docutils literal"><span class="pre">split_recording()</span></code></a> method will only split files
at a key-frame).</p>
<p>The <a class="reference internal" href="index.html#picamera.camera.PiCamera.record_sequence" title="picamera.camera.PiCamera.record_sequence"><code class="xref py py-meth docutils literal"><span class="pre">record_sequence()</span></code></a> method can also be used
to achieve this with slightly cleaner code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">camera</span><span class="o">.</span><span class="n">record_sequence</span><span class="p">(</span>
            <span class="s">&#39;</span><span class="si">%d</span><span class="s">.h264&#39;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">)):</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.3: </span>The <a class="reference internal" href="index.html#picamera.camera.PiCamera.record_sequence" title="picamera.camera.PiCamera.record_sequence"><code class="xref py py-meth docutils literal"><span class="pre">record_sequence()</span></code></a> method was introduced
in version 1.3</p>
</div>
</div>
<div class="section" id="recording-to-a-circular-stream">
<span id="circular-record1"></span><h4>Recording to a circular stream<a class="headerlink" href="#recording-to-a-circular-stream" title="Permalink to this headline">¶</a></h4>
<p>This is similar to <a class="reference internal" href="#stream-record"><span>Recording video to a stream</span></a> but uses a special kind of in-memory
stream provided by the picamera library. The
<a class="reference internal" href="index.html#picamera.streams.PiCameraCircularIO" title="picamera.streams.PiCameraCircularIO"><code class="xref py py-class docutils literal"><span class="pre">PiCameraCircularIO</span></code></a> class implements a <a class="reference external" href="http://en.wikipedia.org/wiki/Circular_buffer">ring buffer</a>
based stream, specifically for video recording.  This enables you to keep an
in-memory stream containing the last <em>n</em> seconds of video recorded (where <em>n</em>
is determined by the bitrate of the video recording and the size of the ring
buffer underlying the stream).</p>
<p>A typical use-case for this sort of storage is security applications where one
wishes to detect motion and only record to disk the video where motion was
detected. This example keeps 20 seconds of video in memory until the
<code class="docutils literal"><span class="pre">write_now</span></code> function returns <code class="docutils literal"><span class="pre">True</span></code> (in this implementation this is random
but one could, for example, replace this with some sort of motion detection
algorithm). Once <code class="docutils literal"><span class="pre">write_now</span></code> returns <code class="docutils literal"><span class="pre">True</span></code>, the script waits 10 more
seconds (so that the buffer contains 10 seconds of video from before the event,
and 10 seconds after) and writes the resulting video to disk before going back
to waiting:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">def</span> <span class="nf">write_now</span><span class="p">():</span>
    <span class="c"># Randomly return True (like a fake motion detection routine)</span>
    <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

<span class="k">def</span> <span class="nf">write_video</span><span class="p">(</span><span class="n">stream</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Writing video!&#39;</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">stream</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
        <span class="c"># Find the first header frame in the video</span>
        <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">stream</span><span class="o">.</span><span class="n">frames</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">frame</span><span class="o">.</span><span class="n">frame_type</span> <span class="o">==</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiVideoFrameType</span><span class="o">.</span><span class="n">sps_header</span><span class="p">:</span>
                <span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="c"># Write the rest of the stream to disk</span>
        <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#39;motion.h264&#39;</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">stream</span> <span class="o">=</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCameraCircularIO</span><span class="p">(</span><span class="n">camera</span><span class="p">,</span> <span class="n">seconds</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_recording</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;h264&#39;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">write_now</span><span class="p">():</span>
                <span class="c"># Keep recording for 10 seconds and only then write the</span>
                <span class="c"># stream to disk</span>
                <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
                <span class="n">write_video</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">stop_recording</span><span class="p">()</span>
</pre></div>
</div>
<p>In the above script we use the threading lock in the
<code class="xref py py-attr docutils literal"><span class="pre">lock</span></code> attribute to prevent the camera&#8217;s background
writing thread from changing the stream while our own thread reads from it (as
the stream is a circular buffer, a write can remove information that is about
to be read). If we had stopped recording to the stream while writing we could
eliminate the <code class="docutils literal"><span class="pre">with</span> <span class="pre">stream.lock</span></code> line in the <code class="docutils literal"><span class="pre">write_video</span></code> function.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Note that <em>at least</em> 20 seconds of video are in the stream. This is an
estimate only; if the H.264 encoder requires less than the specified
bitrate (17Mbps by default) for recording the video, then more than 20
seconds of video will be available in the stream.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.0.</span></p>
</div>
</div>
<div class="section" id="recording-to-a-network-stream">
<span id="streaming-record"></span><h4>Recording to a network stream<a class="headerlink" href="#recording-to-a-network-stream" title="Permalink to this headline">¶</a></h4>
<p>This is similar to <a class="reference internal" href="#stream-record"><span>Recording video to a stream</span></a> but instead of an in-memory stream like
<a class="reference external" href="http://docs.python.org/3.2/library/io.html#io.BytesIO" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">BytesIO</span></code></a>, we will use a file-like object created from a
<a class="reference external" href="http://docs.python.org/3.2/library/socket.html#socket.socket" title="(in Python v3.2)"><code class="xref py py-func docutils literal"><span class="pre">socket()</span></code></a>. Unlike the example in <a class="reference internal" href="#streaming-capture"><span>Capturing to a network stream</span></a> we don&#8217;t
need to complicate our network protocol by writing things like the length of
images. This time we&#8217;re sending a continual stream of video frames (which
necessarily incorporates such information, albeit in a much more efficient
form), so we can simply dump the recording straight to the network socket.</p>
<p>Firstly, the server side script which will simply read the video stream and
pipe it to a media player for display:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">subprocess</span>

<span class="c"># Start a socket listening for connections on 0.0.0.0:8000 (0.0.0.0 means</span>
<span class="c"># all interfaces)</span>
<span class="n">server_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="n">server_socket</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s">&#39;0.0.0.0&#39;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">))</span>
<span class="n">server_socket</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c"># Accept a single connection and make a file-like object out of it</span>
<span class="n">connection</span> <span class="o">=</span> <span class="n">server_socket</span><span class="o">.</span><span class="n">accept</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">makefile</span><span class="p">(</span><span class="s">&#39;rb&#39;</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="c"># Run a viewer with an appropriate command line. Uncomment the mplayer</span>
    <span class="c"># version if you would prefer to use mplayer instead of VLC</span>
    <span class="n">cmdline</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;vlc&#39;</span><span class="p">,</span> <span class="s">&#39;--demux&#39;</span><span class="p">,</span> <span class="s">&#39;h264&#39;</span><span class="p">,</span> <span class="s">&#39;-&#39;</span><span class="p">]</span>
    <span class="c">#cmdline = [&#39;mplayer&#39;, &#39;-fps&#39;, &#39;25&#39;, &#39;-cache&#39;, &#39;1024&#39;, &#39;-&#39;]</span>
    <span class="n">player</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">(</span><span class="n">cmdline</span><span class="p">,</span> <span class="n">stdin</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="c"># Repeatedly read 1k of data from the connection and write it to</span>
        <span class="c"># the media player&#39;s stdin</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">player</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">server_socket</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">player</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you run this script on Windows you will probably need to provide a
complete path to the VLC or mplayer executable. If you run this script
on Mac OS X, and are using Python installed from MacPorts, please ensure
you have also installed VLC or mplayer from MacPorts.</p>
</div>
<p>You will probably notice several seconds of latency with this setup. This is
normal and is because media players buffer several seconds to guard against
unreliable network streams. Some media players (notably mplayer in this case)
permit the user to skip to the end of the buffer (press the right cursor key in
mplayer), reducing the latency by increasing the risk that delayed / dropped
network packets will interrupt the playback.</p>
<p>Now for the client side script which simply starts a recording over a file-like
object created from the network socket:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="c"># Connect a client socket to my_server:8000 (change my_server to the</span>
<span class="c"># hostname of your server)</span>
<span class="n">client_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="n">client_socket</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s">&#39;my_server&#39;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">))</span>

<span class="c"># Make a file-like object out of the connection</span>
<span class="n">connection</span> <span class="o">=</span> <span class="n">client_socket</span><span class="o">.</span><span class="n">makefile</span><span class="p">(</span><span class="s">&#39;wb&#39;</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="mi">24</span>
        <span class="c"># Start a preview and let the camera warm up for 2 seconds</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="c"># Start recording, sending the output to the connection for 60</span>
        <span class="c"># seconds, then stop</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">start_recording</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;h264&#39;</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">stop_recording</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">client_socket</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>It should also be noted that the effect of the above is much more easily
achieved (at least on Linux) with a combination of <code class="docutils literal"><span class="pre">netcat</span></code> and the
<code class="docutils literal"><span class="pre">raspivid</span></code> executable. For example:</p>
<div class="highlight-python"><div class="highlight"><pre>server-side: nc -l 8000 | vlc --demux h264 -
client-side: raspivid -w 640 -h 480 -t 60000 -o - | nc my_server 8000
</pre></div>
</div>
<p>However, this recipe does serve as a starting point for video streaming
applications. It&#8217;s also possible to reverse the direction of this recipe
relatively easily. In this scenario, the Pi acts as the server, waiting for a
connection from the client. When it accepts a connection, it starts streaming
video over it for 60 seconds. Another variation (just for the purposes of
demonstration) is that we initialize the camera straight away instead of
waiting for a connection to allow the streaming to start faster on connection:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="mi">24</span>

    <span class="n">server_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
    <span class="n">server_socket</span><span class="o">.</span><span class="n">bind</span><span class="p">((</span><span class="s">&#39;0.0.0.0&#39;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">))</span>
    <span class="n">server_socket</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c"># Accept a single connection and make a file-like object out of it</span>
    <span class="n">connection</span> <span class="o">=</span> <span class="n">server_socket</span><span class="o">.</span><span class="n">accept</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">makefile</span><span class="p">(</span><span class="s">&#39;wb&#39;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">start_recording</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;h264&#39;</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">stop_recording</span><span class="p">()</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">server_socket</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>One advantage of this setup is that no script is needed on the client side - we
can simply use VLC with a network URL:</p>
<div class="highlight-python"><div class="highlight"><pre>vlc tcp/h264://my_pi_address:8000/
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">VLC (or mplayer) will <em>not</em> work for playback on a Pi. Neither is
(currently) capable of using the GPU for decoding, and thus they attempt to
perform video decoding on the Pi&#8217;s CPU (which is not powerful enough for
the task). You will need to run these applications on a faster machine
(though &#8220;faster&#8221; is a relative term here: even an Atom powered netbook
should be quick enough for the task at non-HD resolutions).</p>
</div>
</div>
<div class="section" id="overlaying-images-on-the-preview">
<span id="image-overlay"></span><h4>Overlaying images on the preview<a class="headerlink" href="#overlaying-images-on-the-preview" title="Permalink to this headline">¶</a></h4>
<p>The camera preview system can operate multiple layered renderers
simultaneously.  While the picamera library only permits a single renderer to
be connected to the camera&#8217;s preview port, it does permit additional renderers
to be created which display a static image. These overlaid renderers can be
used to create simple user interfaces.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Overlay images will <em>not</em> appear in image captures or video recordings. If
you need to embed additional information in the output of the camera,
please refer to <a class="reference internal" href="#text-overlay"><span>Overlaying text on the output</span></a>.</p>
</div>
<p>One difficulty of working with overlay renderers is that they expect unencoded
RGB input which is padded up to the camera&#8217;s block size. The camera&#8217;s block
size is 32x16 so any image data provided to a renderer must have a width which
is a multiple of 32, and a height which is a multiple of 16. The specific RGB
format expected is interleaved unsigned bytes. If all this sounds complicated,
don&#8217;t worry; it&#8217;s quite simple to produce in practice.</p>
<p>The following example demonstrates loading an arbitrary size image with PIL,
padding it to the required size, and producing the unencoded RGB data for the
call to <a class="reference internal" href="index.html#picamera.camera.PiCamera.add_overlay" title="picamera.camera.PiCamera.add_overlay"><code class="xref py py-meth docutils literal"><span class="pre">add_overlay()</span></code></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="mi">24</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>

    <span class="c"># Load the arbitrarily sized image</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#39;overlay.png&#39;</span><span class="p">)</span>
    <span class="c"># Create an image padded to the required size with</span>
    <span class="c"># mode &#39;RGB&#39;</span>
    <span class="n">pad</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s">&#39;RGB&#39;</span><span class="p">,</span> <span class="p">(</span>
        <span class="p">((</span><span class="n">img</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">31</span><span class="p">)</span> <span class="o">//</span> <span class="mi">32</span><span class="p">)</span> <span class="o">*</span> <span class="mi">32</span><span class="p">,</span>
        <span class="p">((</span><span class="n">img</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">15</span><span class="p">)</span> <span class="o">//</span> <span class="mi">16</span><span class="p">)</span> <span class="o">*</span> <span class="mi">16</span><span class="p">,</span>
        <span class="p">))</span>
    <span class="c"># Paste the original image into the padded one</span>
    <span class="n">pad</span><span class="o">.</span><span class="n">paste</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c"># Add the overlay with the padded image as the source,</span>
    <span class="c"># but the original image&#39;s dimensions</span>
    <span class="n">o</span> <span class="o">=</span> <span class="n">camera</span><span class="o">.</span><span class="n">add_overlay</span><span class="p">(</span><span class="n">pad</span><span class="o">.</span><span class="n">tostring</span><span class="p">(),</span> <span class="n">size</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="c"># By default, the overlay is in layer 0, beneath the</span>
    <span class="c"># preview (which defaults to layer 2). Here we make</span>
    <span class="c"># the new overlay semi-transparent, then move it above</span>
    <span class="c"># the preview</span>
    <span class="n">o</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="mi">128</span>
    <span class="n">o</span><span class="o">.</span><span class="n">layer</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="c"># Wait indefinitely until the user terminates the script</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, instead of using an image file as the source, you can produce an
overlay directly from a numpy array. In the following example, we construct
a numpy array with the same resolution as the screen, then draw a white cross
through the center and overlay it on the preview as a simple cross-hair:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="c"># Create an array representing a 1280x720 image of</span>
<span class="c"># a cross through the center of the display. The shape of</span>
<span class="c"># the array must be of the form (height, width, color)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">720</span><span class="p">,</span> <span class="mi">1280</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">a</span><span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mh">0xff</span>
<span class="n">a</span><span class="p">[:,</span> <span class="mi">640</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mh">0xff</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="mi">24</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="c"># Add the overlay directly into layer 3 with transparency;</span>
    <span class="c"># we can omit the size parameter of add_overlay as the</span>
    <span class="c"># size is the same as the camera&#39;s resolution</span>
    <span class="n">o</span> <span class="o">=</span> <span class="n">camera</span><span class="o">.</span><span class="n">add_overlay</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">getbuffer</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">layer</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c"># Wait indefinitely until the user terminates the script</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">remove_overlay</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
</pre></div>
</div>
<p>Given that overlaid renderers can be hidden (by moving them below the
preview&#8217;s <a class="reference internal" href="index.html#picamera.renderers.PiRenderer.layer" title="picamera.renderers.PiRenderer.layer"><code class="xref py py-attr docutils literal"><span class="pre">layer</span></code></a> which defaults to 2),
made semi-transparent (with the <a class="reference internal" href="index.html#picamera.renderers.PiRenderer.alpha" title="picamera.renderers.PiRenderer.alpha"><code class="xref py py-attr docutils literal"><span class="pre">alpha</span></code></a>
property), and resized so that they don&#8217;t <a class="reference internal" href="index.html#picamera.renderers.PiRenderer.fullscreen" title="picamera.renderers.PiRenderer.fullscreen"><code class="xref py py-attr docutils literal"><span class="pre">fill</span> <span class="pre">the</span> <span class="pre">screen</span></code></a>, they can be used to construct
simple user interfaces.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.</span></p>
</div>
</div>
<div class="section" id="overlaying-text-on-the-output">
<span id="text-overlay"></span><h4>Overlaying text on the output<a class="headerlink" href="#overlaying-text-on-the-output" title="Permalink to this headline">¶</a></h4>
<p>The camera includes a rudimentary annotation facility which permits up to 255
characters of ASCII text to be overlaid on all output (including the preview,
image captures and video recordings). To achieve this, simply assign a string
to the <a class="reference internal" href="index.html#picamera.camera.PiCamera.annotate_text" title="picamera.camera.PiCamera.annotate_text"><code class="xref py py-attr docutils literal"><span class="pre">annotate_text</span></code></a> attribute:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="mi">24</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">annotate_text</span> <span class="o">=</span> <span class="s">&#39;Hello world!&#39;</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="c"># Take a picture including the annotation</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="s">&#39;foo.jpg&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>With a little ingenuity, it&#8217;s possible to display longer strings:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">itertools</span>

<span class="n">s</span> <span class="o">=</span> <span class="s">&quot;This message would be far too long to display normally...&quot;</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="mi">24</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">annotate_text</span> <span class="o">=</span> <span class="s">&#39; &#39;</span> <span class="o">*</span> <span class="mi">31</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">annotate_text</span> <span class="o">=</span> <span class="n">camera</span><span class="o">.</span><span class="n">annotate_text</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">31</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<p>And of course, it can be used to display (and embed) a timestamp in recordings
(this recipe also demonstrates drawing a background behind the timestamp for
contrast with the <a class="reference internal" href="index.html#picamera.camera.PiCamera.annotate_background" title="picamera.camera.PiCamera.annotate_background"><code class="xref py py-attr docutils literal"><span class="pre">annotate_background</span></code></a>
attribute):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">datetime</span> <span class="kn">as</span> <span class="nn">dt</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="mi">24</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">annotate_background</span> <span class="o">=</span> <span class="n">picamera</span><span class="o">.</span><span class="n">Color</span><span class="p">(</span><span class="s">&#39;black&#39;</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">annotate_text</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s">&#39;%Y-%m-</span><span class="si">%d</span><span class="s"> %H:%M:%S&#39;</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_recording</span><span class="p">(</span><span class="s">&#39;timestamped.h264&#39;</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span><span class="o">.</span><span class="n">seconds</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">annotate_text</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s">&#39;%Y-%m-</span><span class="si">%d</span><span class="s"> %H:%M:%S&#39;</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">stop_recording</span><span class="p">()</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.</span></p>
</div>
</div>
<div class="section" id="controlling-the-led">
<span id="led-control"></span><h4>Controlling the LED<a class="headerlink" href="#controlling-the-led" title="Permalink to this headline">¶</a></h4>
<p>In certain circumstances, you may find the camera module&#8217;s red LED a hindrance.
For example, in the case of automated close-up wild-life photography, the LED
may scare off animals. It can also cause unwanted reflected red glare with
close-up subjects.</p>
<p>One trivial way to deal with this is simply to place some opaque covering on
the LED (e.g. blue-tack or electricians tape). Another method is to use the
<code class="docutils literal"><span class="pre">disable_camera_led</span></code> option in the <a class="reference external" href="http://www.raspberrypi.org/documentation/configuration/config-txt.md">boot configuration</a>.</p>
<p>However, provided you have the <a class="reference external" href="https://pypi.python.org/pypi/RPi.GPIO">RPi.GPIO</a> package installed, and provided your
Python process is running with sufficient privileges (typically this means
running as root with <code class="docutils literal"><span class="pre">sudo</span> <span class="pre">python</span></code>), you can also control the LED via the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.led" title="picamera.camera.PiCamera.led"><code class="xref py py-attr docutils literal"><span class="pre">led</span></code></a> attribute:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="c"># Turn the camera&#39;s LED off</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">led</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="c"># Take a picture while the LED remains off</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="s">&#39;foo.jpg&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Be aware when you first use the LED property it will set the GPIO library
to Broadcom (BCM) mode with <code class="docutils literal"><span class="pre">GPIO.setmode(GPIO.BCM)</span></code> and disable warnings
with <code class="docutils literal"><span class="pre">GPIO.setwarnings(False)</span></code>. The LED cannot be controlled when the
library is in BOARD mode.</p>
</div>
</div>
</div>
<span id="document-recipes2"></span><div class="section" id="advanced-recipes">
<span id="recipes2"></span><h3>Advanced Recipes<a class="headerlink" href="#advanced-recipes" title="Permalink to this headline">¶</a></h3>
<p>The following recipes involve advanced techniques and may not be &#8220;beginner
friendly&#8221;. Please feel free to suggest enhancements or additional recipes.</p>
<div class="section" id="unencoded-image-capture-yuv-format">
<span id="yuv-capture"></span><h4>Unencoded image capture (YUV format)<a class="headerlink" href="#unencoded-image-capture-yuv-format" title="Permalink to this headline">¶</a></h4>
<p>If you want images captured without loss of detail (due to JPEG&#8217;s lossy
compression), you are probably better off exploring PNG as an alternate image
format (PNG uses lossless compression). However, some applications
(particularly scientific ones) simply require the image data in numeric form.
For this, the <code class="docutils literal"><span class="pre">'yuv'</span></code> format is provided:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="s">&#39;image.data&#39;</span><span class="p">,</span> <span class="s">&#39;yuv&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The specific <a class="reference external" href="http://en.wikipedia.org/wiki/YUV">YUV</a> format used is <a class="reference external" href="http://en.wikipedia.org/wiki/YUV#Y.27UV420p_.28and_Y.27V12_or_YV12.29_to_RGB888_conversion">YUV420</a> (planar). This means that the Y
(luminance) values occur first in the resulting data and have full resolution
(one 1-byte Y value for each pixel in the image). The Y values are followed by
the U (chrominance) values, and finally the V (chrominance) values.  The UV
values have one quarter the resolution of the Y components (4 1-byte Y values
in a square for each 1-byte U and 1-byte V value). This is illustrated in the
diagram below:</p>
<div align="center" class="align-center"><img src="_images/yuv420.svg" /></div>
<p>It is also important to note that when outputting to unencoded formats, the
camera rounds the requested resolution. The horizontal resolution is rounded up
to the nearest multiple of 32 pixels, while the vertical resolution is rounded
up to the nearest multiple of 16 pixels. For example, if the requested
resolution is 100x100, the capture will actually contain 128x112 pixels worth
of data, but pixels beyond 100x100 will be uninitialized.</p>
<p>Given that the <a class="reference external" href="http://en.wikipedia.org/wiki/YUV#Y.27UV420p_.28and_Y.27V12_or_YV12.29_to_RGB888_conversion">YUV420</a> format contains 1.5 bytes worth of data for each pixel
(a 1-byte Y value for each pixel, and 1-byte U and V values for every 4 pixels),
and taking into account the resolution rounding, the size of a 100x100 YUV
capture will be:</p>
<div align="center" class="align-center"><img src="_images/yuv_math.svg" /></div>
<p>The first 14336 bytes of the data (128*112) will be Y values, the next 3584
bytes (128*112/4) will be U values, and the final 3584 bytes will be the V
values.</p>
<p>The following code demonstrates capturing YUV image data, loading the data into
a set of <a class="reference external" href="http://www.numpy.org/">numpy</a> arrays, and converting the data to RGB format in an efficient
manner:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">width</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">height</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">stream</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;image.data&#39;</span><span class="p">,</span> <span class="s">&#39;w+b&#39;</span><span class="p">)</span>
<span class="c"># Capture the image in YUV format</span>
<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="s">&#39;yuv&#39;</span><span class="p">)</span>
<span class="c"># Rewind the stream for reading</span>
<span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="c"># Calculate the actual image size in the stream (accounting for rounding</span>
<span class="c"># of the resolution)</span>
<span class="n">fwidth</span> <span class="o">=</span> <span class="p">(</span><span class="n">width</span> <span class="o">+</span> <span class="mi">31</span><span class="p">)</span> <span class="o">//</span> <span class="mi">32</span> <span class="o">*</span> <span class="mi">32</span>
<span class="n">fheight</span> <span class="o">=</span> <span class="p">(</span><span class="n">height</span> <span class="o">+</span> <span class="mi">15</span><span class="p">)</span> <span class="o">//</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">16</span>
<span class="c"># Load the Y (luminance) data from the stream</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">fwidth</span><span class="o">*</span><span class="n">fheight</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">reshape</span><span class="p">((</span><span class="n">fheight</span><span class="p">,</span> <span class="n">fwidth</span><span class="p">))</span>
<span class="c"># Load the UV (chrominance) data from the stream, and double its size</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="p">(</span><span class="n">fwidth</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">fheight</span><span class="o">//</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span>\
        <span class="n">reshape</span><span class="p">((</span><span class="n">fheight</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">fwidth</span><span class="o">//</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span>\
        <span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="p">(</span><span class="n">fwidth</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">fheight</span><span class="o">//</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span>\
        <span class="n">reshape</span><span class="p">((</span><span class="n">fheight</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">fwidth</span><span class="o">//</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span>\
        <span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c"># Stack the YUV channels together, crop the actual resolution, convert to</span>
<span class="c"># floating point for later calculations, and apply the standard biases</span>
<span class="n">YUV</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">Y</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">V</span><span class="p">))[:</span><span class="n">height</span><span class="p">,</span> <span class="p">:</span><span class="n">width</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
<span class="n">YUV</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>  <span class="o">=</span> <span class="n">YUV</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>  <span class="o">-</span> <span class="mi">16</span>   <span class="c"># Offset Y by 16</span>
<span class="n">YUV</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">YUV</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="mi">128</span>  <span class="c"># Offset UV by 128</span>
<span class="c"># YUV conversion matrix from ITU-R BT.601 version (SDTV)</span>
<span class="c">#              Y       U       V</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.164</span><span class="p">,</span>  <span class="mf">0.000</span><span class="p">,</span>  <span class="mf">1.596</span><span class="p">],</span>    <span class="c"># R</span>
              <span class="p">[</span><span class="mf">1.164</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.392</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.813</span><span class="p">],</span>    <span class="c"># G</span>
              <span class="p">[</span><span class="mf">1.164</span><span class="p">,</span>  <span class="mf">2.017</span><span class="p">,</span>  <span class="mf">0.000</span><span class="p">]])</span>   <span class="c"># B</span>
<span class="c"># Take the dot product with the matrix to produce RGB output, clamp the</span>
<span class="c"># results to byte range and convert to bytes</span>
<span class="n">RGB</span> <span class="o">=</span> <span class="n">YUV</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You may note that we are using <a class="reference external" href="http://docs.python.org/3.2/library/functions.html#open" title="(in Python v3.2)"><code class="xref py py-func docutils literal"><span class="pre">open()</span></code></a> in the code above instead of
<a class="reference external" href="http://docs.python.org/3.2/library/io.html#io.open" title="(in Python v3.2)"><code class="xref py py-func docutils literal"><span class="pre">io.open()</span></code></a> as in the other examples. This is because numpy&#8217;s
<a class="reference external" href="http://docs.scipy.org/doc/numpy/reference/generated/numpy.fromfile.html#numpy.fromfile" title="(in NumPy v1.10)"><code class="xref py py-func docutils literal"><span class="pre">numpy.fromfile()</span></code></a> method annoyingly only accepts &#8220;real&#8221; file objects.</p>
</div>
<p>This recipe is now encapsulated in the <a class="reference internal" href="index.html#picamera.array.PiYUVArray" title="picamera.array.PiYUVArray"><code class="xref py py-class docutils literal"><span class="pre">PiYUVArray</span></code></a>
class in the <a class="reference internal" href="index.html#module-picamera.array" title="picamera.array"><code class="xref py py-mod docutils literal"><span class="pre">picamera.array</span></code></a> module, which means the same can be achieved
as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">picamera.array</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">PiYUVArray</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span> <span class="k">as</span> <span class="n">stream</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="s">&#39;yuv&#39;</span><span class="p">)</span>
        <span class="c"># Show size of YUV data</span>
        <span class="k">print</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="c"># Show size of RGB converted data</span>
        <span class="k">print</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">rgb_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, see <a class="reference internal" href="#rgb-capture"><span>Unencoded image capture (RGB format)</span></a> for a method of having the camera output
RGB data directly.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Capturing so-called &#8220;raw&#8221; formats (<code class="docutils literal"><span class="pre">'yuv'</span></code>, <code class="docutils literal"><span class="pre">'rgb'</span></code>, etc.) does not
provide the raw bayer data from the camera&#8217;s sensor. Rather, it provides
access to the image data after GPU processing, but before format encoding
(JPEG, PNG, etc). Currently, the only method of accessing the raw bayer
data is via the <em>bayer</em> parameter to the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a> method. See <a class="reference internal" href="#bayer-data"><span>Raw Bayer data captures</span></a> for
more information.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.0: </span>The <a class="reference internal" href="index.html#picamera.camera.PiCamera.raw_format" title="picamera.camera.PiCamera.raw_format"><code class="xref py py-attr docutils literal"><span class="pre">raw_format</span></code></a> attribute is now
deprecated, as is the <code class="docutils literal"><span class="pre">'raw'</span></code> format specification for the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a> method. Simply use the <code class="docutils literal"><span class="pre">'yuv'</span></code>
format instead, as shown in the code above.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.5: </span>Added note about new <a class="reference internal" href="index.html#module-picamera.array" title="picamera.array"><code class="xref py py-mod docutils literal"><span class="pre">picamera.array</span></code></a> module.</p>
</div>
</div>
<div class="section" id="unencoded-image-capture-rgb-format">
<span id="rgb-capture"></span><h4>Unencoded image capture (RGB format)<a class="headerlink" href="#unencoded-image-capture-rgb-format" title="Permalink to this headline">¶</a></h4>
<p>The RGB format is rather larger than the <a class="reference external" href="http://en.wikipedia.org/wiki/YUV">YUV</a> format discussed in the section
above, but is more useful for most analyses. To have the camera produce output
in <a class="reference external" href="http://en.wikipedia.org/wiki/RGB">RGB</a> format, you simply need to specify <code class="docutils literal"><span class="pre">'rgb'</span></code> as the format for the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a> method instead:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="s">&#39;image.data&#39;</span><span class="p">,</span> <span class="s">&#39;rgb&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The size of <a class="reference external" href="http://en.wikipedia.org/wiki/RGB">RGB</a> data can be calculated similarly to <a class="reference external" href="http://en.wikipedia.org/wiki/YUV">YUV</a> captures.
Firstly round the resolution appropriately (see <a class="reference internal" href="#yuv-capture"><span>Unencoded image capture (YUV format)</span></a> for the
specifics), then multiply the number of pixels by 3 (1 byte of red, 1 byte of
green, and 1 byte of blue intensity). Hence, for a 100x100 capture, the amount
of data produced is:</p>
<div align="center" class="align-center"><img src="_images/rgb_math.svg" /></div>
<p>The resulting <a class="reference external" href="http://en.wikipedia.org/wiki/RGB">RGB</a> data is interleaved. That is to say that the red, green
and blue values for a given pixel are grouped together, in that order. The
first byte of the data is the red value for the pixel at (0, 0), the second
byte is the green value for the same pixel, and the third byte is the blue
value for that pixel. The fourth byte is the red value for the pixel at (1, 0),
and so on.</p>
<p>Loading the resulting RGB data into a <a class="reference external" href="http://www.numpy.org/">numpy</a> array is simple:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>

<span class="n">width</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">height</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">stream</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;image.data&#39;</span><span class="p">,</span> <span class="s">&#39;w+b&#39;</span><span class="p">)</span>
<span class="c"># Capture the image in RGB format</span>
<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="s">&#39;rgb&#39;</span><span class="p">)</span>
<span class="c"># Rewind the stream for reading</span>
<span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="c"># Calculate the actual image size in the stream (accounting for rounding</span>
<span class="c"># of the resolution)</span>
<span class="n">fwidth</span> <span class="o">=</span> <span class="p">(</span><span class="n">width</span> <span class="o">+</span> <span class="mi">31</span><span class="p">)</span> <span class="o">//</span> <span class="mi">32</span> <span class="o">*</span> <span class="mi">32</span>
<span class="n">fheight</span> <span class="o">=</span> <span class="p">(</span><span class="n">height</span> <span class="o">+</span> <span class="mi">15</span><span class="p">)</span> <span class="o">//</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">16</span>
<span class="c"># Load the data in a three-dimensional array and crop it to the requested</span>
<span class="c"># resolution</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span><span class="o">.</span>\
        <span class="n">reshape</span><span class="p">((</span><span class="n">fheight</span><span class="p">,</span> <span class="n">fwidth</span><span class="p">,</span> <span class="mi">3</span><span class="p">))[:</span><span class="n">height</span><span class="p">,</span> <span class="p">:</span><span class="n">width</span><span class="p">,</span> <span class="p">:]</span>
<span class="c"># If you wish, the following code will convert the image&#39;s bytes into</span>
<span class="c"># floating point values in the range 0 to 1 (a typical format for some</span>
<span class="c"># sorts of analysis)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">image</span> <span class="o">/</span> <span class="mf">255.0</span>
</pre></div>
</div>
<p>This recipe is now encapsulated in the <a class="reference internal" href="index.html#picamera.array.PiRGBArray" title="picamera.array.PiRGBArray"><code class="xref py py-class docutils literal"><span class="pre">PiRGBArray</span></code></a>
class in the <a class="reference internal" href="index.html#module-picamera.array" title="picamera.array"><code class="xref py py-mod docutils literal"><span class="pre">picamera.array</span></code></a> module, which means the same can be achieved
as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">picamera.array</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">PiRGBArray</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span> <span class="k">as</span> <span class="n">stream</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="s">&#39;rgb&#39;</span><span class="p">)</span>
        <span class="c"># Show size of RGB data</span>
        <span class="k">print</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">RGB captures from the still port do not work at the full resolution of the
camera (they result in an out of memory error). Either use YUV captures, or
capture from the video port if you require full resolution.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.0: </span>The <a class="reference internal" href="index.html#picamera.camera.PiCamera.raw_format" title="picamera.camera.PiCamera.raw_format"><code class="xref py py-attr docutils literal"><span class="pre">raw_format</span></code></a> attribute is now
deprecated, as is the <code class="docutils literal"><span class="pre">'raw'</span></code> format specification for the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a> method. Simply use the <code class="docutils literal"><span class="pre">'rgb'</span></code>
format instead, as shown in the code above.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.5: </span>Added note about new <a class="reference internal" href="index.html#module-picamera.array" title="picamera.array"><code class="xref py py-mod docutils literal"><span class="pre">picamera.array</span></code></a> module.</p>
</div>
</div>
<div class="section" id="rapid-capture-and-processing">
<span id="rapid-capture"></span><h4>Rapid capture and processing<a class="headerlink" href="#rapid-capture-and-processing" title="Permalink to this headline">¶</a></h4>
<p>The camera is capable of capturing a sequence of images extremely rapidly by
utilizing its video-capture capabilities with a JPEG encoder (via the
<em>use_video_port</em> parameter). However, there are several things to note about
using this technique:</p>
<ul class="simple">
<li>When using video-port based capture only the video recording area is
captured; in some cases this may be smaller than the normal image capture
area (see discussion in <a class="reference internal" href="index.html#camera-modes"><span>Camera Modes</span></a>).</li>
<li>No Exif information is embedded in JPEG images captured through the
video-port.</li>
<li>Captures typically appear &#8220;grainier&#8221; with this technique. Captures from the
still port use a slower, more intensive denoise algorithm.</li>
</ul>
<p>All capture methods support the <em>use_video_port</em> option, but the methods differ
in their ability to rapidly capture sequential frames. So, whilst
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a> and
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture_continuous" title="picamera.camera.PiCamera.capture_continuous"><code class="xref py py-meth docutils literal"><span class="pre">capture_continuous()</span></code></a> both support
<em>use_video_port</em>, <a class="reference internal" href="index.html#picamera.camera.PiCamera.capture_sequence" title="picamera.camera.PiCamera.capture_sequence"><code class="xref py py-meth docutils literal"><span class="pre">capture_sequence()</span></code></a> is by far
the fastest method (because it does not re-initialize an encoder prior to each
capture). Using this method, the author has managed 30fps JPEG captures at a
resolution of 1024x768.</p>
<p>By default, <a class="reference internal" href="index.html#picamera.camera.PiCamera.capture_sequence" title="picamera.camera.PiCamera.capture_sequence"><code class="xref py py-meth docutils literal"><span class="pre">capture_sequence()</span></code></a> is particularly
suited to capturing a fixed number of frames rapidly, as in the following
example which captures a &#8220;burst&#8221; of 5 images:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">768</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture_sequence</span><span class="p">([</span>
        <span class="s">&#39;image1.jpg&#39;</span><span class="p">,</span>
        <span class="s">&#39;image2.jpg&#39;</span><span class="p">,</span>
        <span class="s">&#39;image3.jpg&#39;</span><span class="p">,</span>
        <span class="s">&#39;image4.jpg&#39;</span><span class="p">,</span>
        <span class="s">&#39;image5.jpg&#39;</span><span class="p">,</span>
        <span class="p">])</span>
</pre></div>
</div>
<p>We can refine this slightly by using a generator expression to provide the
filenames for processing instead of specifying every single filename manually:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="n">frames</span> <span class="o">=</span> <span class="mi">60</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">768</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="c"># Give the camera some warm-up time</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture_sequence</span><span class="p">([</span>
        <span class="s">&#39;image</span><span class="si">%02d</span><span class="s">.jpg&#39;</span> <span class="o">%</span> <span class="n">i</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
        <span class="p">],</span> <span class="n">use_video_port</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">finish</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;Captured </span><span class="si">%d</span><span class="s"> frames at </span><span class="si">%.2f</span><span class="s">fps&#39;</span> <span class="o">%</span> <span class="p">(</span>
    <span class="n">frames</span><span class="p">,</span>
    <span class="n">frames</span> <span class="o">/</span> <span class="p">(</span><span class="n">finish</span> <span class="o">-</span> <span class="n">start</span><span class="p">)))</span>
</pre></div>
</div>
<p>However, this still doesn&#8217;t let us capture an arbitrary number of frames until
some condition is satisfied. To do this we need to use a generator function to
provide the list of filenames (or more usefully, streams) to the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture_sequence" title="picamera.camera.PiCamera.capture_sequence"><code class="xref py py-meth docutils literal"><span class="pre">capture_sequence()</span></code></a> method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="n">frames</span> <span class="o">=</span> <span class="mi">60</span>

<span class="k">def</span> <span class="nf">filenames</span><span class="p">():</span>
    <span class="n">frame</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">frame</span> <span class="o">&lt;</span> <span class="n">frames</span><span class="p">:</span>
        <span class="k">yield</span> <span class="s">&#39;image</span><span class="si">%02d</span><span class="s">.jpg&#39;</span> <span class="o">%</span> <span class="n">frame</span>
        <span class="n">frame</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">768</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="c"># Give the camera some warm-up time</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture_sequence</span><span class="p">(</span><span class="n">filenames</span><span class="p">(),</span> <span class="n">use_video_port</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">finish</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;Captured </span><span class="si">%d</span><span class="s"> frames at </span><span class="si">%.2f</span><span class="s">fps&#39;</span> <span class="o">%</span> <span class="p">(</span>
    <span class="n">frames</span><span class="p">,</span>
    <span class="n">frames</span> <span class="o">/</span> <span class="p">(</span><span class="n">finish</span> <span class="o">-</span> <span class="n">start</span><span class="p">)))</span>
</pre></div>
</div>
<p>The major issue with capturing this rapidly is firstly that the Raspberry Pi&#8217;s
IO bandwidth is extremely limited and secondly that, as a format, JPEG is
considerably less efficient than the H.264 video format (which is to say that,
for the same number of bytes, H.264 will provide considerably better quality
over the same number of frames). At higher resolutions (beyond 800x600) you are
likely to find you cannot sustain 30fps captures to the Pi&#8217;s SD card for very
long (before exhausting the disk cache).</p>
<p>If you are intending to perform processing on the frames after capture, you may
be better off just capturing video and decoding frames from the resulting file
rather than dealing with individual JPEG captures. Alternatively, you may wish
to investigate sending the data over the network (which typically has more
bandwidth available than the SD card interface) and having another machine
perform any required processing. However, if you can perform your processing
fast enough, you may not need to involve the disk or network at all. Using a
generator function, we can maintain a queue of objects to store the captures,
and have parallel threads accept and process the streams as captures come in.
Provided the processing runs at a faster frame rate than the captures, the
encoder won&#8217;t stall:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="c"># Create a pool of image processors</span>
<span class="n">done</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
<span class="n">pool</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">class</span> <span class="nc">ImageProcessor</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ImageProcessor</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stream</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">event</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terminated</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># This method runs in a separate thread</span>
        <span class="k">global</span> <span class="n">done</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminated</span><span class="p">:</span>
            <span class="c"># Wait for an image to be written to the stream</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="c"># Read the image and do some processing on it</span>
                    <span class="c">#Image.open(self.stream)</span>
                    <span class="c">#...</span>
                    <span class="c">#...</span>
                    <span class="c"># Set done to True if you want the script to terminate</span>
                    <span class="c"># at some point</span>
                    <span class="c">#done=True</span>
                <span class="k">finally</span><span class="p">:</span>
                    <span class="c"># Reset the stream and event</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                    <span class="c"># Return ourselves to the pool</span>
                    <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
                        <span class="n">pool</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">streams</span><span class="p">():</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">done</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pool</span><span class="p">:</span>
                <span class="n">processor</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">processor</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">processor</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">processor</span><span class="o">.</span><span class="n">stream</span>
            <span class="n">processor</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># When the pool is starved, wait a while for it to refill</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="p">[</span><span class="n">ImageProcessor</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture_sequence</span><span class="p">(</span><span class="n">streams</span><span class="p">(),</span> <span class="n">use_video_port</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c"># Shut down the processors in an orderly fashion</span>
<span class="k">while</span> <span class="n">pool</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>
        <span class="n">processor</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="n">processor</span><span class="o">.</span><span class="n">terminated</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">processor</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="rapid-capture-and-streaming">
<span id="rapid-streaming"></span><h4>Rapid capture and streaming<a class="headerlink" href="#rapid-capture-and-streaming" title="Permalink to this headline">¶</a></h4>
<p>Following on from <a class="reference internal" href="#rapid-capture"><span>Rapid capture and processing</span></a>, we can combine the video-port capture
technique with <a class="reference internal" href="index.html#streaming-capture"><span>Capturing to a network stream</span></a>. The server side script doesn&#8217;t change
(it doesn&#8217;t really care what capture technique is being used - it just reads
JPEGs off the wire). The changes to the client side script can be minimal at
first - just set <em>use_video_port</em> to <code class="docutils literal"><span class="pre">True</span></code> in the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture_continuous" title="picamera.camera.PiCamera.capture_continuous"><code class="xref py py-meth docutils literal"><span class="pre">capture_continuous()</span></code></a> call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="n">client_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="n">client_socket</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s">&#39;my_server&#39;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">))</span>
<span class="n">connection</span> <span class="o">=</span> <span class="n">client_socket</span><span class="o">.</span><span class="n">makefile</span><span class="p">(</span><span class="s">&#39;wb&#39;</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="mi">30</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">stream</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
        <span class="c"># Use the video-port for captures...</span>
        <span class="k">for</span> <span class="n">foo</span> <span class="ow">in</span> <span class="n">camera</span><span class="o">.</span><span class="n">capture_continuous</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="s">&#39;jpeg&#39;</span><span class="p">,</span>
                                             <span class="n">use_video_port</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
            <span class="n">connection</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">&#39;&lt;L&#39;</span><span class="p">,</span> <span class="n">stream</span><span class="o">.</span><span class="n">tell</span><span class="p">()))</span>
            <span class="n">connection</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">connection</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">&#39;&lt;L&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">client_socket</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>Using this technique, the author can manage about 10fps of streaming at 640x480
on firmware #685. One deficiency of the script above is that it interleaves
capturing images with sending them over the wire (although we deliberately
don&#8217;t flush on sending the image data). Potentially, it would be more efficient
to permit image capture to occur simultaneously with image transmission. We can
attempt to do this by utilizing the background threading techniques from the
final example in <a class="reference internal" href="#rapid-capture"><span>Rapid capture and processing</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">struct</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="n">client_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">()</span>
<span class="n">client_socket</span><span class="o">.</span><span class="n">connect</span><span class="p">((</span><span class="s">&#39;spider&#39;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">))</span>
<span class="n">connection</span> <span class="o">=</span> <span class="n">client_socket</span><span class="o">.</span><span class="n">makefile</span><span class="p">(</span><span class="s">&#39;wb&#39;</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">connection_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="n">pool_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">class</span> <span class="nc">ImageStreamer</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">ImageStreamer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stream</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">event</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">terminated</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c"># This method runs in a background thread</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminated</span><span class="p">:</span>
                <span class="c"># Wait for the image to be written to the stream</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">with</span> <span class="n">connection_lock</span><span class="p">:</span>
                            <span class="n">connection</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">&#39;&lt;L&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">tell</span><span class="p">()))</span>
                            <span class="n">connection</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                            <span class="n">connection</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
                    <span class="k">finally</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                        <span class="k">with</span> <span class="n">pool_lock</span><span class="p">:</span>
                            <span class="n">pool</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">finish</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">streams</span><span class="p">():</span>
        <span class="k">global</span> <span class="n">count</span><span class="p">,</span> <span class="n">finish</span>
        <span class="k">while</span> <span class="n">finish</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">pool_lock</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pool</span><span class="p">:</span>
                    <span class="n">streamer</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">streamer</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="n">streamer</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">streamer</span><span class="o">.</span><span class="n">stream</span>
                <span class="n">streamer</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># When the pool is starved, wait a while for it to refill</span>
                <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="n">finish</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="p">[</span><span class="n">ImageStreamer</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)]</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="mi">30</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">capture_sequence</span><span class="p">(</span><span class="n">streams</span><span class="p">(),</span> <span class="s">&#39;jpeg&#39;</span><span class="p">,</span> <span class="n">use_video_port</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="c"># Shut down the streamers in an orderly fashion</span>
    <span class="k">while</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">streamer</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">streamer</span><span class="o">.</span><span class="n">terminated</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">streamer</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

    <span class="c"># Write the terminating 0-length to the connection to let the server</span>
    <span class="c"># know we&#39;re done</span>
    <span class="k">with</span> <span class="n">connection_lock</span><span class="p">:</span>
        <span class="n">connection</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s">&#39;&lt;L&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

<span class="k">finally</span><span class="p">:</span>
    <span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">client_socket</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="s">&#39;Sent </span><span class="si">%d</span><span class="s"> images in </span><span class="si">%d</span><span class="s"> seconds at </span><span class="si">%.2f</span><span class="s">fps&#39;</span> <span class="o">%</span> <span class="p">(</span>
    <span class="n">count</span><span class="p">,</span> <span class="n">finish</span><span class="o">-</span><span class="n">start</span><span class="p">,</span> <span class="n">count</span> <span class="o">/</span> <span class="p">(</span><span class="n">finish</span><span class="o">-</span><span class="n">start</span><span class="p">)))</span>
</pre></div>
</div>
<p>On the same firmware, the above script achieves about 15fps. It is possible the
new high framerate modes may achieve more (the fact that 15fps is half of the
specified 30fps framerate suggests some stall on every other frame).</p>
</div>
<div class="section" id="capturing-images-whilst-recording">
<span id="record-and-capture"></span><h4>Capturing images whilst recording<a class="headerlink" href="#capturing-images-whilst-recording" title="Permalink to this headline">¶</a></h4>
<p>The camera is capable of capturing still images while it is recording video.
However, if one attempts this using the stills capture mode, the resulting
video will have dropped frames during the still image capture. This is because
images captured via the still port require a mode change, causing the dropped
frames (this is the flicker to a higher resolution that one sees when capturing
while a preview is running).</p>
<p>However, if the <em>use_video_port</em> parameter is used to force a video-port based
image capture (see <a class="reference internal" href="#rapid-capture"><span>Rapid capture and processing</span></a>) then the mode change does not occur,
and the resulting video should not have dropped frames, assuming the image can
be produced before the next video frame is due:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="mi">600</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_recording</span><span class="p">(</span><span class="s">&#39;foo.h264&#39;</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="s">&#39;foo.jpg&#39;</span><span class="p">,</span> <span class="n">use_video_port</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">stop_recording</span><span class="p">()</span>
</pre></div>
</div>
<p>The above code should produce a 20 second video with no dropped frames, and a
still frame from 10 seconds into the video. Higher resolutions or non-JPEG
image formats may still cause dropped frames (only JPEG encoding is hardware
accelerated).</p>
</div>
<div class="section" id="recording-at-multiple-resolutions">
<span id="multi-res-record"></span><h4>Recording at multiple resolutions<a class="headerlink" href="#recording-at-multiple-resolutions" title="Permalink to this headline">¶</a></h4>
<p>The camera is capable of recording multiple streams at different resolutions
simultaneously by use of the video splitter. This is probably most useful for
performing analysis on a low-resolution stream, while simultaneously recording
a high resolution stream for storage or viewing.</p>
<p>The following simple recipe demonstrates using the <em>splitter_port</em> parameter of
the <a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> method to begin two
simultaneous recordings, each with a different resolution:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="mi">768</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_recording</span><span class="p">(</span><span class="s">&#39;highres.h264&#39;</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_recording</span><span class="p">(</span><span class="s">&#39;lowres.h264&#39;</span><span class="p">,</span> <span class="n">splitter_port</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">resize</span><span class="o">=</span><span class="p">(</span><span class="mi">320</span><span class="p">,</span> <span class="mi">240</span><span class="p">))</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">stop_recording</span><span class="p">(</span><span class="n">splitter_port</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">stop_recording</span><span class="p">()</span>
</pre></div>
</div>
<p>There are 4 splitter ports in total that can be used (numbered 0, 1, 2, and 3).
The video recording methods default to using splitter port 1, while the image
capture methods default to splitter port 0 (when the <em>use_video_port</em> parameter
is also True). A splitter port cannot be simultaneously used for video
recording and image capture so you are advised to avoid splitter port 0 for
video recordings unless you never intend to capture images whilst recording.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.3.</span></p>
</div>
</div>
<div class="section" id="recording-motion-vector-data">
<span id="motion-data-output"></span><h4>Recording motion vector data<a class="headerlink" href="#recording-motion-vector-data" title="Permalink to this headline">¶</a></h4>
<p>The Pi&#8217;s camera is capable of outputting the motion vector estimates that the
camera&#8217;s H.264 encoder calculates while generating compressed video. These can
be directed to a separate output file (or file-like object) with the
<em>motion_output</em> parameter of the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> method. Like the normal
<em>output</em> parameter this accepts a string representing a filename, or a
file-like object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_recording</span><span class="p">(</span><span class="s">&#39;motion.h264&#39;</span><span class="p">,</span> <span class="n">motion_output</span><span class="o">=</span><span class="s">&#39;motion.data&#39;</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">stop_recording</span><span class="p">()</span>
</pre></div>
</div>
<p>Motion data is calculated at the <a class="reference external" href="http://en.wikipedia.org/wiki/Macroblock">macro-block</a> level (an MPEG macro-block
represents a 16x16 pixel region of the frame), and includes one extra column of
data. Hence, if the camera&#8217;s resolution is 640x480 (as in the example above)
there will be 41 columns of motion data ((640 / 16) + 1), in 30 rows (480 /
16).</p>
<p>Motion data values are 4-bytes long, consisting of a signed 1-byte x vector, a
signed 1-byte y vector, and an unsigned 2-byte SAD (<a class="reference external" href="http://en.wikipedia.org/wiki/Sum_of_absolute_differences">Sum of Absolute
Differences</a>) value for each macro-block.  Hence in the example above, each
frame will generate 4920 bytes of motion data (41 * 30 * 4). Assuming the data
contains 300 frames (in practice it may contain a few more) the motion data
should be 1,476,000 bytes in total.</p>
<p>The following code demonstrates loading the motion data into a
three-dimensional numpy array. The first dimension represents the frame, with
the latter two representing rows and finally columns. A structured data-type
is used for the array permitting easy access to x, y, and SAD values:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">width</span> <span class="o">=</span> <span class="mi">640</span>
<span class="n">height</span> <span class="o">=</span> <span class="mi">480</span>
<span class="n">cols</span> <span class="o">=</span> <span class="p">(</span><span class="n">width</span> <span class="o">+</span> <span class="mi">15</span><span class="p">)</span> <span class="o">//</span> <span class="mi">16</span>
<span class="n">cols</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c"># there&#39;s always an extra column</span>
<span class="n">rows</span> <span class="o">=</span> <span class="p">(</span><span class="n">height</span> <span class="o">+</span> <span class="mi">15</span><span class="p">)</span> <span class="o">//</span> <span class="mi">16</span>

<span class="n">motion_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span>
    <span class="s">&#39;motion.data&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[</span>
        <span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="s">&#39;i1&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">,</span> <span class="s">&#39;i1&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&#39;sad&#39;</span><span class="p">,</span> <span class="s">&#39;u2&#39;</span><span class="p">),</span>
        <span class="p">])</span>
<span class="n">frames</span> <span class="o">=</span> <span class="n">motion_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="p">(</span><span class="n">cols</span> <span class="o">*</span> <span class="n">rows</span><span class="p">)</span>
<span class="n">motion_data</span> <span class="o">=</span> <span class="n">motion_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">frames</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>

<span class="c"># Access the data for the first frame</span>
<span class="n">motion_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c"># Access just the x-vectors from the fifth frame</span>
<span class="n">motion_data</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="s">&#39;x&#39;</span><span class="p">]</span>

<span class="c"># Access SAD values for the tenth frame</span>
<span class="n">motion_data</span><span class="p">[</span><span class="mi">9</span><span class="p">][</span><span class="s">&#39;sad&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>You can calculate the amount of motion the vector represents simply by
calculating the <a class="reference external" href="http://en.wikipedia.org/wiki/Magnitude_%28mathematics%29#Euclidean_vectors">magnitude of the vector</a> with Pythagoras&#8217; theorem. The SAD
(<a class="reference external" href="http://en.wikipedia.org/wiki/Sum_of_absolute_differences">Sum of Absolute Differences</a>) value can be used to determine how well the
encoder thinks the vector represents the original reference frame.</p>
<p>The following code extends the example above to use PIL to produce a PNG image
from the magnitude of each frame&#8217;s motion vectors:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>

<span class="n">width</span> <span class="o">=</span> <span class="mi">640</span>
<span class="n">height</span> <span class="o">=</span> <span class="mi">480</span>
<span class="n">cols</span> <span class="o">=</span> <span class="p">(</span><span class="n">width</span> <span class="o">+</span> <span class="mi">15</span><span class="p">)</span> <span class="o">//</span> <span class="mi">16</span>
<span class="n">cols</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">rows</span> <span class="o">=</span> <span class="p">(</span><span class="n">height</span> <span class="o">+</span> <span class="mi">15</span><span class="p">)</span> <span class="o">//</span> <span class="mi">16</span>

<span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span>
    <span class="s">&#39;motion.data&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[</span>
        <span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="s">&#39;i1&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">,</span> <span class="s">&#39;i1&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&#39;sad&#39;</span><span class="p">,</span> <span class="s">&#39;u2&#39;</span><span class="p">),</span>
        <span class="p">])</span>
<span class="n">frames</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="p">(</span><span class="n">cols</span> <span class="o">*</span> <span class="n">rows</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">frames</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>

<span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">frames</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">frame</span><span class="p">][</span><span class="s">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">))</span> <span class="o">+</span>
        <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">frame</span><span class="p">][</span><span class="s">&#39;y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">))</span>
        <span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="s">&#39;frame</span><span class="si">%03d</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="n">frame</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Writing </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
    <span class="n">img</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
<p>You may wish to investigate the <a class="reference internal" href="index.html#picamera.array.PiMotionArray" title="picamera.array.PiMotionArray"><code class="xref py py-class docutils literal"><span class="pre">PiMotionArray</span></code></a> class
in the <a class="reference internal" href="index.html#module-picamera.array" title="picamera.array"><code class="xref py py-mod docutils literal"><span class="pre">picamera.array</span></code></a> module which simplifies the above recipes to the
following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">picamera.array</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">PiMotionArray</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span> <span class="k">as</span> <span class="n">stream</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="mi">30</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">start_recording</span><span class="p">(</span><span class="s">&#39;/dev/null&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;h264&#39;</span><span class="p">,</span> <span class="n">motion_output</span><span class="o">=</span><span class="n">stream</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">stop_recording</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">frame</span><span class="p">][</span><span class="s">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">))</span> <span class="o">+</span>
                <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">array</span><span class="p">[</span><span class="n">frame</span><span class="p">][</span><span class="s">&#39;y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">))</span>
                <span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="s">&#39;frame</span><span class="si">%03d</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="n">frame</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;Writing </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
            <span class="n">img</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
<p>Finally, the following command line can be used to generate an animation from
the generated PNGs with ffmpeg (this will take a <em>very</em> long time on the Pi so
you may wish to transfer the images to a faster machine for this step):</p>
<div class="highlight-python"><div class="highlight"><pre>avconv -r 30 -i frame%03d.png -filter:v scale=640:480 -c:v libx264 motion.mp4
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.5.</span></p>
</div>
</div>
<div class="section" id="splitting-to-from-a-circular-stream">
<span id="circular-record2"></span><h4>Splitting to/from a circular stream<a class="headerlink" href="#splitting-to-from-a-circular-stream" title="Permalink to this headline">¶</a></h4>
<p>This example builds on the one in <a class="reference internal" href="index.html#circular-record1"><span>Recording to a circular stream</span></a> and the one in
<a class="reference internal" href="#record-and-capture"><span>Capturing images whilst recording</span></a> to demonstrate the beginnings of a security
application. As before, a <a class="reference internal" href="index.html#picamera.streams.PiCameraCircularIO" title="picamera.streams.PiCameraCircularIO"><code class="xref py py-class docutils literal"><span class="pre">PiCameraCircularIO</span></code></a>
instance is used to keep the last few seconds of video recorded in memory.
While the video is being recorded, video-port-based still captures are taken to
provide a motion detection routine with some input (the actual motion detection
algorithm is left as an exercise for the reader).</p>
<p>Once motion is detected, the last 10 seconds of video are written to disk, and
video recording is split to another disk file to proceed until motion is no
longer detected. Once motion is no longer detected, we split the recording back
to the in-memory ring-buffer:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>

<span class="n">prior_image</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">def</span> <span class="nf">detect_motion</span><span class="p">(</span><span class="n">camera</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">prior_image</span>
    <span class="n">stream</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;jpeg&#39;</span><span class="p">,</span> <span class="n">use_video_port</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">prior_image</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">prior_image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">current_image</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
        <span class="c"># Compare current_image to prior_image to detect motion. This is</span>
        <span class="c"># left as an exercise for the reader!</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="c"># Once motion detection is done, make the prior image the current</span>
        <span class="n">prior_image</span> <span class="o">=</span> <span class="n">current_image</span>
        <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">write_video</span><span class="p">(</span><span class="n">stream</span><span class="p">):</span>
    <span class="c"># Write the entire content of the circular buffer to disk. No need to</span>
    <span class="c"># lock the stream here as we&#39;re definitely not writing to it</span>
    <span class="c"># simultaneously</span>
    <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s">&#39;before.h264&#39;</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">stream</span><span class="o">.</span><span class="n">frames</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">frame</span><span class="o">.</span><span class="n">frame_type</span> <span class="o">==</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiVideoFrameType</span><span class="o">.</span><span class="n">sps_header</span><span class="p">:</span>
                <span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>
                <span class="k">break</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">read1</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">buf</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
    <span class="c"># Wipe the circular stream once we&#39;re done</span>
    <span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">stream</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">)</span>
    <span class="n">stream</span> <span class="o">=</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCameraCircularIO</span><span class="p">(</span><span class="n">camera</span><span class="p">,</span> <span class="n">seconds</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_recording</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;h264&#39;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">detect_motion</span><span class="p">(</span><span class="n">camera</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&#39;Motion detected!&#39;</span><span class="p">)</span>
                <span class="c"># As soon as we detect motion, split the recording to</span>
                <span class="c"># record the frames &quot;after&quot; motion</span>
                <span class="n">camera</span><span class="o">.</span><span class="n">split_recording</span><span class="p">(</span><span class="s">&#39;after.h264&#39;</span><span class="p">)</span>
                <span class="c"># Write the 10 seconds &quot;before&quot; motion to disk as well</span>
                <span class="n">write_video</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
                <span class="c"># Wait until motion is no longer detected, then split</span>
                <span class="c"># recording back to the in-memory circular buffer</span>
                <span class="k">while</span> <span class="n">detect_motion</span><span class="p">(</span><span class="n">camera</span><span class="p">):</span>
                    <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&#39;Motion stopped!&#39;</span><span class="p">)</span>
                <span class="n">camera</span><span class="o">.</span><span class="n">split_recording</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">stop_recording</span><span class="p">()</span>
</pre></div>
</div>
<p>This example also demonstrates writing the circular buffer to disk in an
efficient manner using the <a class="reference internal" href="index.html#picamera.streams.CircularIO.read1" title="picamera.streams.CircularIO.read1"><code class="xref py py-meth docutils literal"><span class="pre">read1()</span></code></a> method
(as opposed to <a class="reference internal" href="index.html#picamera.streams.CircularIO.read" title="picamera.streams.CircularIO.read"><code class="xref py py-meth docutils literal"><span class="pre">read()</span></code></a>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Note that <a class="reference internal" href="index.html#picamera.streams.CircularIO.read1" title="picamera.streams.CircularIO.read1"><code class="xref py py-meth docutils literal"><span class="pre">read1()</span></code></a> does not guarantee to
return the number of bytes requested, even if they are available in the
underlying stream; it simply returns as many as are available from a single
chunk up to the limit specified.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.0.</span></p>
</div>
</div>
<div class="section" id="custom-outputs">
<span id="id1"></span><h4>Custom outputs<a class="headerlink" href="#custom-outputs" title="Permalink to this headline">¶</a></h4>
<p>All methods in the picamera library which accept a filename also accept
file-like objects. Typically, this is only used with actual file objects, or
with memory streams (like <a class="reference external" href="http://docs.python.org/3.2/library/io.html#io.BytesIO" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">io.BytesIO</span></code></a>). However, building a custom
output object is extremely easy and in certain cases very useful. A file-like
object (as far as picamera is concerned) is simply an object with a <code class="docutils literal"><span class="pre">write</span></code>
method which must accept a single parameter consisting of a byte-string, and
which can optionally return the number of bytes written. The object can
optionally implement a <code class="docutils literal"><span class="pre">flush</span></code> method (which has no parameters), which will
be called at the end of output.</p>
<p>Custom outputs are particularly useful with video recording as the custom
output&#8217;s <code class="docutils literal"><span class="pre">write</span></code> method will be called (at least) once for every frame that
is output, allowing you to implement code that reacts to each and every frame
without going to the bother of a full <a class="reference internal" href="#custom-encoders"><span>custom encoder</span></a>.
However, one should bear in mind that because the <code class="docutils literal"><span class="pre">write</span></code> method is called so
frequently, its implementation must be sufficiently rapid that it doesn&#8217;t stall
the encoder (it must perform its processing and return before the next write is
due to arrive).</p>
<p>The following trivial example demonstrates an incredibly simple custom output
which simply throws away the output while counting the number of bytes that
would have been written and prints this at the end of the output:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">class</span> <span class="nc">MyOutput</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%d</span><span class="s"> bytes would have been written&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="mi">60</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_recording</span><span class="p">(</span><span class="n">MyOutput</span><span class="p">(),</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;h264&#39;</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">stop_recording</span><span class="p">()</span>
</pre></div>
</div>
<p>The following example shows how to use a custom output to construct a crude
motion detection system. We construct a custom output object which is used as
the destination for motion vector data (this is particularly simple as motion
vector data always arrives as single chunks; frame data by contrast sometimes
arrives in several separate chunks). The output object doesn&#8217;t actually write
the motion data anywhere; instead it loads it into a numpy array and analyses
whether there are any significantly large vectors in the data, printing a
message to the console if there are. As we are not concerned with keeping the
actual video output in this example, we use <code class="docutils literal"><span class="pre">/dev/null</span></code> as the destination
for the video data:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="n">motion_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([</span>
    <span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="s">&#39;i1&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s">&#39;y&#39;</span><span class="p">,</span> <span class="s">&#39;i1&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s">&#39;sad&#39;</span><span class="p">,</span> <span class="s">&#39;u2&#39;</span><span class="p">),</span>
    <span class="p">])</span>

<span class="k">class</span> <span class="nc">MyMotionDetector</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">camera</span><span class="p">):</span>
        <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="p">(</span><span class="n">width</span> <span class="o">+</span> <span class="mi">15</span><span class="p">)</span> <span class="o">//</span> <span class="mi">16</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">+=</span> <span class="mi">1</span> <span class="c"># there&#39;s always an extra column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rows</span> <span class="o">=</span> <span class="p">(</span><span class="n">height</span> <span class="o">+</span> <span class="mi">15</span><span class="p">)</span> <span class="o">//</span> <span class="mi">16</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="c"># Load the motion data from the string to a numpy array</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">motion_dtype</span><span class="p">)</span>
        <span class="c"># Re-shape it and calculate the magnitude of each vector</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">rows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">))</span> <span class="o">+</span>
            <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">))</span>
            <span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="c"># If there&#39;re more than 10 vectors with a magnitude greater</span>
        <span class="c"># than 60, then say we&#39;ve detected motion</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&gt;</span> <span class="mi">60</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;Motion detected!&#39;</span><span class="p">)</span>
        <span class="c"># Pretend we wrote all the bytes of s</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_recording</span><span class="p">(</span>
        <span class="c"># Throw away the video data, but make sure we&#39;re using H.264</span>
        <span class="s">&#39;/dev/null&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;h264&#39;</span><span class="p">,</span>
        <span class="c"># Record motion data to our custom output object</span>
        <span class="n">motion_output</span><span class="o">=</span><span class="n">MyMotionDetector</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">stop_recording</span><span class="p">()</span>
</pre></div>
</div>
<p>You may wish to investigate the classes in the <a class="reference internal" href="index.html#module-picamera.array" title="picamera.array"><code class="xref py py-mod docutils literal"><span class="pre">picamera.array</span></code></a> module
which implement several custom outputs for analysis of data with numpy. In
particular, the <a class="reference internal" href="index.html#picamera.array.PiMotionAnalysis" title="picamera.array.PiMotionAnalysis"><code class="xref py py-class docutils literal"><span class="pre">PiMotionAnalysis</span></code></a> class can be used to
remove much of the boiler plate code from the recipe above:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">picamera.array</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">class</span> <span class="nc">MyMotionDetector</span><span class="p">(</span><span class="n">picamera</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">PiMotionAnalysis</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">))</span> <span class="o">+</span>
            <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">))</span>
            <span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="c"># If there&#39;re more than 10 vectors with a magnitude greater</span>
        <span class="c"># than 60, then say we&#39;ve detected motion</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">60</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;Motion detected!&#39;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="mi">30</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_recording</span><span class="p">(</span>
        <span class="s">&#39;/dev/null&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;h264&#39;</span><span class="p">,</span>
        <span class="n">motion_output</span><span class="o">=</span><span class="n">MyMotionDetector</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">stop_recording</span><span class="p">()</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.5.</span></p>
</div>
</div>
<div class="section" id="custom-encoders">
<span id="id2"></span><h4>Custom encoders<a class="headerlink" href="#custom-encoders" title="Permalink to this headline">¶</a></h4>
<p>You can override and/or extend the encoder classes used during image or video
capture. This is particularly useful with video capture as it allows you to run
your own code in response to every frame, although naturally whatever code runs
within the encoder&#8217;s callback has to be reasonably quick to avoid stalling the
encoder pipeline.</p>
<p>Writing a custom encoder is quite a bit harder than writing a <a class="reference internal" href="#custom-outputs"><span>custom
output</span></a> and in most cases there&#8217;s little benefit. The only
thing a custom encoder gives you that a custom output doesn&#8217;t is access to the
buffer header flags. For many output formats (MJPEG and YUV for example), these
won&#8217;t tell you anything interesting (i.e. they&#8217;ll simply indicate that the
buffer contains a full frame and nothing else). Currently, the only format
where the buffer header flags contain useful information is H.264. Even then,
most of the information (I-frame, P-frame, motion information, etc.) would be
accessible from the <a class="reference internal" href="index.html#picamera.camera.PiCamera.frame" title="picamera.camera.PiCamera.frame"><code class="xref py py-attr docutils literal"><span class="pre">frame</span></code></a> attribute which you
could access from your custom output&#8217;s <code class="docutils literal"><span class="pre">write</span></code> method.</p>
<p>The encoder classes defined by picamera form the following hierarchy (shaded
classes are actually instantiated by the implementation in picamera, white
classes implement base functionality but aren&#8217;t technically &#8220;abstract&#8221;):</p>
<div align="center" class="align-center"><img src="_images/encoder_classes.svg" /></div>
<p>The following table details which <code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code> methods use which encoder
classes, and which method they call to construct these encoders:</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="35%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method(s)</th>
<th class="head">Call</th>
<th class="head">Returns</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="index.html#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a>
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture_continuous" title="picamera.camera.PiCamera.capture_continuous"><code class="xref py py-meth docutils literal"><span class="pre">capture_continuous()</span></code></a>
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture_sequence" title="picamera.camera.PiCamera.capture_sequence"><code class="xref py py-meth docutils literal"><span class="pre">capture_sequence()</span></code></a></td>
<td><a class="reference internal" href="index.html#picamera.camera.PiCamera._get_image_encoder" title="picamera.camera.PiCamera._get_image_encoder"><code class="xref py py-meth docutils literal"><span class="pre">_get_image_encoder()</span></code></a></td>
<td><code class="xref py py-class docutils literal"><span class="pre">PiCookedOneImageEncoder</span></code>
<code class="xref py py-class docutils literal"><span class="pre">PiRawOneImageEncoder</span></code></td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="index.html#picamera.camera.PiCamera.capture_sequence" title="picamera.camera.PiCamera.capture_sequence"><code class="xref py py-meth docutils literal"><span class="pre">capture_sequence()</span></code></a></td>
<td><a class="reference internal" href="index.html#picamera.camera.PiCamera._get_images_encoder" title="picamera.camera.PiCamera._get_images_encoder"><code class="xref py py-meth docutils literal"><span class="pre">_get_images_encoder()</span></code></a></td>
<td><code class="xref py py-class docutils literal"><span class="pre">PiCookedMultiImageEncoder</span></code>
<code class="xref py py-class docutils literal"><span class="pre">PiRawMultiImageEncoder</span></code></td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a>
<a class="reference internal" href="index.html#picamera.camera.PiCamera.record_sequence" title="picamera.camera.PiCamera.record_sequence"><code class="xref py py-meth docutils literal"><span class="pre">record_sequence()</span></code></a></td>
<td><a class="reference internal" href="index.html#picamera.camera.PiCamera._get_video_encoder" title="picamera.camera.PiCamera._get_video_encoder"><code class="xref py py-meth docutils literal"><span class="pre">_get_video_encoder()</span></code></a></td>
<td><code class="xref py py-class docutils literal"><span class="pre">PiCookedVideoEncoder</span></code>
<code class="xref py py-class docutils literal"><span class="pre">PiRawVideoEncoder</span></code></td>
</tr>
</tbody>
</table>
<p>It is recommended, particularly in the case of the image encoder classes, that
you familiarize yourself with the specific function of these classes so that
you can determine the best class to extend for your particular needs. You may
find that one of the intermediate classes is a better basis for your own
modifications.</p>
<p>In the following example recipe we will extend the
<a class="reference internal" href="index.html#picamera.encoders.PiCookedVideoEncoder" title="picamera.encoders.PiCookedVideoEncoder"><code class="xref py py-class docutils literal"><span class="pre">PiCookedVideoEncoder</span></code></a> class to store how many
I-frames and P-frames are captured (the camera&#8217;s encoder doesn&#8217;t use
B-frames):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">picamera.mmal</span> <span class="kn">as</span> <span class="nn">mmal</span>


<span class="c"># Override PiVideoEncoder to keep track of the number of each type of frame</span>
<span class="k">class</span> <span class="nc">MyEncoder</span><span class="p">(</span><span class="n">picamera</span><span class="o">.</span><span class="n">PiCookedVideoEncoder</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">motion_output</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">i_frames</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">p_frames</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MyEncoder</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">motion_output</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_callback_write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buf</span><span class="p">):</span>
        <span class="c"># Only count when buffer indicates it&#39;s the end of a frame, and</span>
        <span class="c"># it&#39;s not an SPS/PPS header (..._CONFIG)</span>
        <span class="k">if</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">mmal</span><span class="o">.</span><span class="n">MMAL_BUFFER_HEADER_FLAG_FRAME_END</span><span class="p">)</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">mmal</span><span class="o">.</span><span class="n">MMAL_BUFFER_HEADER_FLAG_CONFIG</span><span class="p">)</span>
            <span class="p">):</span>
            <span class="k">if</span> <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">mmal</span><span class="o">.</span><span class="n">MMAL_BUFFER_HEADER_FLAG_KEYFRAME</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">i_frames</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">p_frames</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c"># Remember to return the result of the parent method!</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">MyEncoder</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_callback_write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>


<span class="c"># Override PiCamera to use our custom encoder for video recording</span>
<span class="k">class</span> <span class="nc">MyCamera</span><span class="p">(</span><span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MyCamera</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i_frames</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_frames</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_get_video_encoder</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">camera_port</span><span class="p">,</span> <span class="n">output_port</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">resize</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">MyEncoder</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">camera_port</span><span class="p">,</span> <span class="n">output_port</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">resize</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">)</span>


<span class="k">with</span> <span class="n">MyCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_recording</span><span class="p">(</span><span class="s">&#39;foo.h264&#39;</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">stop_recording</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Recording contains </span><span class="si">%d</span><span class="s"> I-frames and </span><span class="si">%d</span><span class="s"> P-frames&#39;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">camera</span><span class="o">.</span><span class="n">i_frames</span><span class="p">,</span> <span class="n">camera</span><span class="o">.</span><span class="n">p_frames</span><span class="p">))</span>
</pre></div>
</div>
<p>Please note that the above recipe is flawed: PiCamera is capable of
initiating <a class="reference internal" href="#multi-res-record"><span>multiple simultaneous recordings</span></a>. If this
were used with the above recipe, then each encoder would wind up incrementing
the <code class="docutils literal"><span class="pre">i_frames</span></code> and <code class="docutils literal"><span class="pre">p_frames</span></code> attributes on the <code class="docutils literal"><span class="pre">MyCamera</span></code> instance
leading to incorrect results.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.5.</span></p>
</div>
</div>
<div class="section" id="raw-bayer-data-captures">
<span id="bayer-data"></span><h4>Raw Bayer data captures<a class="headerlink" href="#raw-bayer-data-captures" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal"><span class="pre">bayer</span></code> parameter of the <a class="reference internal" href="index.html#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a> method
causes the raw Bayer data recorded by the camera&#8217;s sensor to be output as
part of the image meta-data.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <code class="docutils literal"><span class="pre">bayer</span></code> parameter only operates with the JPEG format, and only
for captures from the still port (i.e. when <code class="docutils literal"><span class="pre">use_video_port</span></code> is False,
as it is by default).</p>
</div>
<p>Raw Bayer data differs considerably from simple unencoded captures; it is the
data recorded by the camera&#8217;s sensor prior to <em>any</em> GPU processing including
auto white balance, vignette compensation, smoothing, down-scaling,
etc. This also means:</p>
<ul class="simple">
<li>Bayer data is <em>always</em> full resolution, regardless of the camera&#8217;s output
<a class="reference internal" href="index.html#picamera.camera.PiCamera.resolution" title="picamera.camera.PiCamera.resolution"><code class="xref py py-attr docutils literal"><span class="pre">resolution</span></code></a> and any <code class="docutils literal"><span class="pre">resize</span></code> parameter.</li>
<li>Bayer data occupies the last 6,404,096 bytes of the output file. The first
32,768 bytes of this is header data which starts with the string <code class="docutils literal"><span class="pre">'BRCM'</span></code>.</li>
<li>Bayer data consists of 10-bit values, because this is the sensitivity of the
<a class="reference external" href="http://www.ovt.com/products/sensor.php?id=66">OV5647</a> sensor used by the Pi&#8217;s camera. The 10-bit values are organized as
4 8-bit values, followed by the low-order 2-bits of the 4 values packed into
a fifth byte.</li>
</ul>
<div align="center" class="align-center"><img src="_images/bayer_bytes.svg" /></div>
<ul class="simple">
<li>Bayer data is organized in a BGGR pattern (a minor variation of the common
<a class="reference external" href="http://en.wikipedia.org/wiki/Bayer_filter">Bayer CFA</a>). The raw data therefore has twice as many green pixels as red
or blue and if viewed &#8220;raw&#8221; will look distinctly strange (too dark, too
green, and with zippering effects along any straight edges).</li>
</ul>
<div align="center" class="align-center"><img src="_images/bayer_pattern.svg" /></div>
<ul class="simple">
<li>To make a &#8220;normal&#8221; looking image from raw Bayer data you will need to
perform <a class="reference external" href="http://en.wikipedia.org/wiki/Demosaicing">de-mosaicing</a> at the very least, and probably some form of
<a class="reference external" href="http://en.wikipedia.org/wiki/Color_balance">color balance</a>.</li>
</ul>
<p>This (heavily commented) example script causes the camera to capture an image
including the raw Bayer data. It then proceeds to unpack the Bayer data into a
3-dimensional <a class="reference external" href="http://www.numpy.org/">numpy</a> array representing the raw RGB data and finally performs
a rudimentary de-mosaic step with weighted averages. A couple of numpy tricks
are used to improve performance but bear in mind that all processing is
happening on the CPU and will be considerably slower than normal image
captures:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">unicode_literals</span><span class="p">,</span>
    <span class="n">absolute_import</span><span class="p">,</span>
    <span class="n">print_function</span><span class="p">,</span>
    <span class="n">division</span><span class="p">,</span>
    <span class="p">)</span>


<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.lib.stride_tricks</span> <span class="kn">import</span> <span class="n">as_strided</span>

<span class="n">stream</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="c"># Let the camera warm up for a couple of seconds</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="c"># Capture the image, including the Bayer data</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;jpeg&#39;</span><span class="p">,</span> <span class="n">bayer</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="c"># Extract the raw Bayer data from the end of the stream, check the</span>
<span class="c"># header and strip if off before converting the data into a numpy array</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">stream</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()[</span><span class="o">-</span><span class="mi">6404096</span><span class="p">:]</span>
<span class="k">assert</span> <span class="n">data</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;BRCM&#39;</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">32768</span><span class="p">:]</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

<span class="c"># The data consists of 1952 rows of 3264 bytes of data. The last 8 rows</span>
<span class="c"># of data are unused (they only exist because the actual resolution of</span>
<span class="c"># 1944 rows is rounded up to the nearest 16). Likewise, the last 24</span>
<span class="c"># bytes of each row are unused (why?). Here we reshape the data and</span>
<span class="c"># strip off the unused bytes</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1952</span><span class="p">,</span> <span class="mi">3264</span><span class="p">))[:</span><span class="mi">1944</span><span class="p">,</span> <span class="p">:</span><span class="mi">3240</span><span class="p">]</span>

<span class="c"># Horizontally, each row consists of 2592 10-bit values. Every four</span>
<span class="c"># bytes are the high 8-bits of four values, and the 5th byte contains</span>
<span class="c"># the packed low 2-bits of the preceding four values. In other words,</span>
<span class="c"># the bits of the values A, B, C, D and arranged like so:</span>
<span class="c">#</span>
<span class="c">#  byte 1   byte 2   byte 3   byte 4   byte 5</span>
<span class="c"># AAAAAAAA BBBBBBBB CCCCCCCC DDDDDDDD AABBCCDD</span>
<span class="c">#</span>
<span class="c"># Here, we convert our data into a 16-bit array, shift all values left</span>
<span class="c"># by 2-bits and unpack the low-order bits from every 5th byte in each</span>
<span class="c"># row, then remove the columns containing the packed bits</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span>
<span class="k">for</span> <span class="n">byte</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">data</span><span class="p">[:,</span> <span class="n">byte</span><span class="p">::</span><span class="mi">5</span><span class="p">]</span> <span class="o">|=</span> <span class="p">((</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">::</span><span class="mi">5</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="p">((</span><span class="mi">4</span> <span class="o">-</span> <span class="n">byte</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mb">0b11</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="mi">4</span><span class="p">::</span><span class="mi">5</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>

<span class="c"># Now to split the data up into its red, green, and blue components. The</span>
<span class="c"># Bayer pattern of the OV5647 sensor is BGGR. In other words the first</span>
<span class="c"># row contains alternating green/blue elements, the second row contains</span>
<span class="c"># alternating red/green elements, and so on as illustrated below:</span>
<span class="c">#</span>
<span class="c"># GBGBGBGBGBGBGB</span>
<span class="c"># RGRGRGRGRGRGRG</span>
<span class="c"># GBGBGBGBGBGBGB</span>
<span class="c"># RGRGRGRGRGRGRG</span>
<span class="c">#</span>
<span class="c"># Please note that if you use vflip or hflip to change the orientation</span>
<span class="c"># of the capture, you must flip the Bayer pattern accordingly</span>

<span class="n">rgb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="n">rgb</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># Red</span>
<span class="n">rgb</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># Green</span>
<span class="n">rgb</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># Green</span>
<span class="n">rgb</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># Blue</span>

<span class="c"># At this point we now have the raw Bayer data with the correct values</span>
<span class="c"># and colors but the data still requires de-mosaicing and</span>
<span class="c"># post-processing. If you wish to do this yourself, end the script here!</span>
<span class="c">#</span>
<span class="c"># Below we present a fairly naive de-mosaic method that simply</span>
<span class="c"># calculates the weighted average of a pixel based on the pixels</span>
<span class="c"># surrounding it. The weighting is provided by a byte representation of</span>
<span class="c"># the Bayer filter which we construct first:</span>

<span class="n">bayer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">rgb</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">bayer</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># Red</span>
<span class="n">bayer</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># Green</span>
<span class="n">bayer</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># Green</span>
<span class="n">bayer</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># Blue</span>

<span class="c"># Allocate an array to hold our output with the same shape as the input</span>
<span class="c"># data. After this we define the size of window that will be used to</span>
<span class="c"># calculate each weighted average (3x3). Then we pad out the rgb and</span>
<span class="c"># bayer arrays, adding blank pixels at their edges to compensate for the</span>
<span class="c"># size of the window when calculating averages for edge pixels.</span>

<span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">rgb</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">rgb</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="n">window</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">borders</span> <span class="o">=</span> <span class="p">(</span><span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">window</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">border</span> <span class="o">=</span> <span class="p">(</span><span class="n">borders</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">borders</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>

<span class="n">rgb_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span>
    <span class="n">rgb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">borders</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="n">rgb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">borders</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="n">rgb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">rgb</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="n">rgb_pad</span><span class="p">[</span>
    <span class="n">border</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">rgb_pad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">border</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="n">border</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">rgb_pad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">border</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">:]</span> <span class="o">=</span> <span class="n">rgb</span>
<span class="n">rgb</span> <span class="o">=</span> <span class="n">rgb_pad</span>

<span class="n">bayer_pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span>
    <span class="n">bayer</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">borders</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="n">bayer</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">borders</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="n">bayer</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">bayer</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="n">bayer_pad</span><span class="p">[</span>
    <span class="n">border</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">bayer_pad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">border</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="n">border</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">bayer_pad</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">border</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">:]</span> <span class="o">=</span> <span class="n">bayer</span>
<span class="n">bayer</span> <span class="o">=</span> <span class="n">bayer_pad</span>

<span class="c"># In numpy &gt;=1.7.0 just use np.pad (version in Raspbian is 1.6.2 at the</span>
<span class="c"># time of writing...)</span>
<span class="c">#</span>
<span class="c">#rgb = np.pad(rgb, [</span>
<span class="c">#    (border[0], border[0]),</span>
<span class="c">#    (border[1], border[1]),</span>
<span class="c">#    (0, 0),</span>
<span class="c">#    ], &#39;constant&#39;)</span>
<span class="c">#bayer = np.pad(bayer, [</span>
<span class="c">#    (border[0], border[0]),</span>
<span class="c">#    (border[1], border[1]),</span>
<span class="c">#    (0, 0),</span>
<span class="c">#    ], &#39;constant&#39;)</span>

<span class="c"># For each plane in the RGB data, we use a nifty numpy trick</span>
<span class="c"># (as_strided) to construct a view over the plane of 3x3 matrices. We do</span>
<span class="c"># the same for the bayer array, then use Einstein summation on each</span>
<span class="c"># (np.sum is simpler, but copies the data so it&#39;s slower), and divide</span>
<span class="c"># the results to get our weighted average:</span>

<span class="k">for</span> <span class="n">plane</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">rgb</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">plane</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">bayer</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">plane</span><span class="p">]</span>
    <span class="n">pview</span> <span class="o">=</span> <span class="n">as_strided</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span>
        <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">borders</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">borders</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">window</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="n">p</span><span class="o">.</span><span class="n">strides</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">bview</span> <span class="o">=</span> <span class="n">as_strided</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span>
        <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">borders</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">borders</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">window</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="n">b</span><span class="o">.</span><span class="n">strides</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">psum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;ijkl-&gt;ij&#39;</span><span class="p">,</span> <span class="n">pview</span><span class="p">)</span>
    <span class="n">bsum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s">&#39;ijkl-&gt;ij&#39;</span><span class="p">,</span> <span class="n">bview</span><span class="p">)</span>
    <span class="n">output</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">plane</span><span class="p">]</span> <span class="o">=</span> <span class="n">psum</span> <span class="o">//</span> <span class="n">bsum</span>

<span class="c"># At this point output should contain a reasonably &quot;normal&quot; looking</span>
<span class="c"># image, although it still won&#39;t look as good as the camera&#39;s normal</span>
<span class="c"># output (as it lacks vignette compensation, AWB, etc).</span>
<span class="c">#</span>
<span class="c"># If you want to view this in most packages (like GIMP) you&#39;ll need to</span>
<span class="c"># convert it to 8-bit RGB data. The simplest way to do this is by</span>
<span class="c"># right-shifting everything by 2-bits (yes, this makes all that</span>
<span class="c"># unpacking work at the start rather redundant...)</span>

<span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="n">output</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;image.data&#39;</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">output</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>This recipe is also encapsulated in the <a class="reference internal" href="index.html#picamera.array.PiBayerArray" title="picamera.array.PiBayerArray"><code class="xref py py-class docutils literal"><span class="pre">PiBayerArray</span></code></a>
class in the <a class="reference internal" href="index.html#module-picamera.array" title="picamera.array"><code class="xref py py-mod docutils literal"><span class="pre">picamera.array</span></code></a> module, which means the same can be achieved
as follows:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">picamera.array</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">PiBayerArray</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span> <span class="k">as</span> <span class="n">stream</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="s">&#39;jpeg&#39;</span><span class="p">,</span> <span class="n">bayer</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="c"># Demosaic data and write to output (just use stream.array if you</span>
        <span class="c"># want to skip the demosaic step)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">demosaic</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">&#39;image.data&#39;</span><span class="p">,</span> <span class="s">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.3.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.5: </span>Added note about new <a class="reference internal" href="index.html#module-picamera.array" title="picamera.array"><code class="xref py py-mod docutils literal"><span class="pre">picamera.array</span></code></a> module.</p>
</div>
</div>
<div class="section" id="using-a-flash-with-the-camera">
<span id="flash-configuration"></span><h4>Using a flash with the camera<a class="headerlink" href="#using-a-flash-with-the-camera" title="Permalink to this headline">¶</a></h4>
<p>The Pi&#8217;s camera module includes an LED flash driver which can be used to
illuminate a scene upon capture. The flash driver has two configurable GPIO
pins:</p>
<ul class="simple">
<li>one for connection to an LED based flash (xenon flashes won&#8217;t work with the
camera module due to it having a <a class="reference external" href="http://en.wikipedia.org/wiki/Rolling_shutter">rolling shutter</a>). This will fire before
(<a class="reference external" href="http://en.wikipedia.org/wiki/Through-the-lens_metering#Through_the_lens_flash_metering">flash metering</a>) and during capture</li>
<li>one for an optional privacy indicator (a requirement for cameras in some
jurisdictions). This will fire after taking a picture to indicate that the
camera has been used</li>
</ul>
<p>These pins are configured by updating the <a class="reference external" href="http://www.raspberrypi.org/documentation/configuration/pin-configuration.md">VideoCore device tree blob</a>.
Firstly, install the device tree compiler, then grab a copy of the default
device tree source:</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo apt-get install device-tree-compiler
$ wget http://www.raspberrypi.org/documentation/configuration/images/dt-blob.dts
</pre></div>
</div>
<p>The device tree source contains a number of sections enclosed in curly braces,
which form a hierarchy of definitions. The section to edit will depend on which
revision of Raspberry Pi you have:</p>
<table border="1" class="docutils">
<colgroup>
<col width="55%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Model</th>
<th class="head">Section</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Raspberry Pi Model B revision 1</td>
<td><code class="docutils literal"><span class="pre">/videocore/pins_rev1</span></code></td>
</tr>
<tr class="row-odd"><td><p class="first">Raspberry Pi Model A</p>
<p class="last">Raspberry Pi Model B revision 2</p>
</td>
<td><code class="docutils literal"><span class="pre">/videocore/pins_rev2</span></code></td>
</tr>
<tr class="row-even"><td><p class="first">Raspberry Pi Model A+</p>
<p>Raspberry Pi Model B+</p>
<p class="last">Raspberry Pi 2 Model B</p>
</td>
<td><code class="docutils literal"><span class="pre">/videocore/pins_bplus</span></code></td>
</tr>
</tbody>
</table>
<p>Under the section for your particular model of Pi you will find <code class="docutils literal"><span class="pre">pin_config</span></code>
and <code class="docutils literal"><span class="pre">pin_defines</span></code> sections. Under the <code class="docutils literal"><span class="pre">pin_config</span></code> section you need to
configure the GPIO pins you want to use for the flash and privacy indicator as
using pull down termination. Then, under the <code class="docutils literal"><span class="pre">pin_defines</span></code> section you need
to associate those pins with the <code class="docutils literal"><span class="pre">FLASH_0_ENABLE</span></code> and <code class="docutils literal"><span class="pre">FLASH_0_INDICATOR</span></code>
pins.</p>
<p>For example, to configure GPIO 17 as the flash pin, leaving the privacy
indicator pin absent, on a Raspberry Pi Model B revision 2 you would add the
following line under the <code class="docutils literal"><span class="pre">/videocore/pins_rev2/pin_config</span></code> section:</p>
<div class="highlight-python"><div class="highlight"><pre>pin@p17 { function = &quot;output&quot;; termination = &quot;pull_down&quot;; };
</pre></div>
</div>
<p>Please note that GPIO pins will be numbered according to the <a class="reference external" href="http://raspberrypi.stackexchange.com/questions/12966/what-is-the-difference-between-board-and-bcm-for-gpio-pin-numbering">Broadcom pin
numbers</a> (BCM mode in the RPi.GPIO library, <em>not</em> BOARD mode). Then change the
following section under <code class="docutils literal"><span class="pre">/videocore/pins_rev2/pin_defines</span></code>. Specifically,
change the type from &#8220;absent&#8221; to &#8220;internal&#8221;, and add a number property defining
the flash pin as GPIO 17:</p>
<div class="highlight-python"><div class="highlight"><pre>pin-define@FLASH_0_ENABLE {
    type = &quot;internal&quot;;
    number = &lt;17&gt;;
};
</pre></div>
</div>
<p>With the device tree source updated, you now need to compile it into a binary
blob for the firmware to read. This is done with the following command line:</p>
<div class="highlight-python"><div class="highlight"><pre>$ dtc -I dts -O dtb dt-blob.dts -o dt-blob.bin
</pre></div>
</div>
<p>Dissecting this command line, the following components are present:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">dtc</span></code> - Execute the device tree compiler</li>
<li><code class="docutils literal"><span class="pre">-I</span> <span class="pre">dts</span></code> - The input file is in device tree source format</li>
<li><code class="docutils literal"><span class="pre">-O</span> <span class="pre">dtb</span></code> - The output file should be produced in device tree binary format</li>
<li><code class="docutils literal"><span class="pre">dt-blob.dts</span></code> - The first anonymous parameter is the input filename</li>
<li><code class="docutils literal"><span class="pre">-o</span> <span class="pre">dt-blob.bin</span></code> - The output filename</li>
</ul>
<p>This should output the following:</p>
<div class="highlight-python"><div class="highlight"><pre>DTC: dts-&gt;dtb  on file &quot;dt-blob.dts&quot;
</pre></div>
</div>
<p>If anything else is output, it will most likely be an error message indicating
you have made a mistake in the device tree source. In this case, review your
edits carefully (note that sections and properties <em>must</em> be semi-colon
terminated for example), and try again.</p>
<p>Now the device tree binary blob has been produced, it needs to be placed on the
first partition of the SD card. In the case of non-NOOBS Raspbian installs,
this is generally the partition mounted as <code class="docutils literal"><span class="pre">/boot</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo cp dt-blob.bin /boot/
</pre></div>
</div>
<p>However, in the case of NOOBS Raspbian installs, this is the recovery
partition, which is not mounted by default:</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo mkdir /mnt/recovery
$ sudo mount /dev/mmcblk0p1 /mnt/recovery
$ sudo cp dt-blob.bin /mnt/recovery
$ sudo umount /mnt/recovery
$ sudo rmdir /mnt/recovery
</pre></div>
</div>
<p>Please note that the filename and location are important. The binary blob must
be named <code class="docutils literal"><span class="pre">dt-blob.bin</span></code> (all lowercase), and it must be placed in the root
directory of the first partition on the SD card. Once you have rebooted the Pi
(to activate the new device tree configuration) you can test the flash with the
following simple script:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">flash_mode</span> <span class="o">=</span> <span class="s">&#39;on&#39;</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="s">&#39;foo.jpg&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>You should see your flash LED blink twice during the execution of the script.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>The GPIOs only have a limited current drive which is insufficient for
powering the sort of LEDs typically used as flashes in mobile phones. You
will require a suitable drive circuit to power such devices, or risk
damaging your Pi. One developer on the Pi forums notes:</p>
<blockquote class="last">
<div>For reference, the flash driver chips we have used on mobile phones
will often drive up to 500mA into the LED. If you&#8217;re aiming for that,
then please think about your power supply too.</div></blockquote>
</div>
<p>If you wish to experiment with the flash driver without attaching anything to
the GPIO pins, you can also reconfigure the camera&#8217;s own LED to act as the
flash LED. Obviously this is no good for actual flash photography but it can
demonstrate whether your configuration is good. In this case you need not add
anything to the <code class="docutils literal"><span class="pre">pin_config</span></code> section (the camera&#8217;s LED pin is already defined
to use pull down termination), but you do need to set <code class="docutils literal"><span class="pre">CAMERA_0_LED</span></code> to
absent, and <code class="docutils literal"><span class="pre">FLASH_0_ENABLE</span></code> to the old <code class="docutils literal"><span class="pre">CAMERA_0_LED</span></code> definition (this
will be pin 5 in the case of <code class="docutils literal"><span class="pre">pins_rev1</span></code> and <code class="docutils literal"><span class="pre">pins_rev2</span></code>, and pin 32 in the
case of <code class="docutils literal"><span class="pre">pins_bplus</span></code>). For example, change:</p>
<div class="highlight-python"><div class="highlight"><pre>pin_define@CAMERA_0_LED {
    type = &quot;internal&quot;;
    number = &lt;5&gt;;
};
pin_define@FLASH_0_ENABLE {
    type = &quot;absent&quot;;
};
</pre></div>
</div>
<p>into this:</p>
<div class="highlight-python"><div class="highlight"><pre>pin_define@CAMERA_0_LED {
    type = &quot;absent&quot;;
};
pin_define@FLASH_0_ENABLE {
    type = &quot;internal&quot;;
    number = &lt;5&gt;;
};
</pre></div>
</div>
<p>After compiling and installing the device tree blob according to the
instructions above, and rebooting the Pi, you should find the camera LED now
acts as a flash LED with the Python script above.</p>
</div>
</div>
<span id="document-faq"></span><div class="section" id="frequently-asked-questions-faq">
<span id="faq"></span><h3>Frequently Asked Questions (FAQ)<a class="headerlink" href="#frequently-asked-questions-faq" title="Permalink to this headline">¶</a></h3>
<div class="section" id="can-i-put-the-preview-in-a-window">
<h4>Can I put the preview in a window?<a class="headerlink" href="#can-i-put-the-preview-in-a-window" title="Permalink to this headline">¶</a></h4>
<p>No. The camera module&#8217;s preview system is quite crude: it simply tells the GPU
to overlay the preview on the Pi&#8217;s video output. The preview has no knowledge
(or interaction with) the X-Windows environment (incidentally, this is why the
preview works quite happily from the command line, even without anyone logged
in).</p>
<p>That said, the preview area can be resized and repositioned via the
<a class="reference internal" href="index.html#picamera.renderers.PiRenderer.window" title="picamera.renderers.PiRenderer.window"><code class="xref py py-attr docutils literal"><span class="pre">window</span></code></a> attribute of the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.preview" title="picamera.camera.PiCamera.preview"><code class="xref py py-attr docutils literal"><span class="pre">preview</span></code></a> object. If your program can respond
to window repositioning and sizing events you can &#8220;cheat&#8221; and position the
preview within the borders of the target window. However, there&#8217;s currently no
way to allow anything to appear on top of the preview so this is an imperfect
solution at best.</p>
</div>
<div class="section" id="help-i-started-a-preview-and-can-t-see-my-console">
<h4>Help! I started a preview and can&#8217;t see my console!<a class="headerlink" href="#help-i-started-a-preview-and-can-t-see-my-console" title="Permalink to this headline">¶</a></h4>
<p>As mentioned above, the preview is simply an overlay over the Pi&#8217;s video
output.  If you start a preview you may therefore discover you can&#8217;t see your
console anymore and there&#8217;s no obvious way of getting it back. If you&#8217;re
confident in your typing skills you can try calling
<a class="reference internal" href="index.html#picamera.camera.PiCamera.stop_preview" title="picamera.camera.PiCamera.stop_preview"><code class="xref py py-meth docutils literal"><span class="pre">stop_preview()</span></code></a> by typing &#8220;blindly&#8221; into your
hidden console. However, the simplest way of getting your display back is
usually to hit <code class="docutils literal"><span class="pre">Ctrl+D</span></code> to terminate the Python process (which should also
shut down the camera).</p>
<p>When starting a preview, you may want to set the <em>alpha</em> parameter of the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.start_preview" title="picamera.camera.PiCamera.start_preview"><code class="xref py py-meth docutils literal"><span class="pre">start_preview()</span></code></a> method to something like 128.
This should ensure that when the preview is displayed, it is partially
transparent so you can still see your console.</p>
</div>
<div class="section" id="the-preview-doesn-t-work-on-my-pitft-screen">
<h4>The preview doesn&#8217;t work on my PiTFT screen<a class="headerlink" href="#the-preview-doesn-t-work-on-my-pitft-screen" title="Permalink to this headline">¶</a></h4>
<p>The camera&#8217;s preview system directly overlays the Pi&#8217;s output on the HDMI or
composite video ports. At this time, it will not operate with GPIO-driven
displays like the PiTFT. Some projects, like the <a class="reference external" href="https://learn.adafruit.com/diy-wifi-raspberry-pi-touch-cam/overview">Adafruit Touchscreen Camera
project</a>, have approximated a preview by rapidly capturing unencoded images
and displaying them on the PiTFT instead.</p>
</div>
<div class="section" id="how-much-power-does-the-camera-require">
<h4>How much power does the camera require?<a class="headerlink" href="#how-much-power-does-the-camera-require" title="Permalink to this headline">¶</a></h4>
<p>The camera <a class="reference external" href="http://www.raspberrypi.org/help/faqs/#cameraPower">requires 250mA</a> when running. Note that simply creating a
<a class="reference internal" href="index.html#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a> object means the camera is running (due to the
hidden preview that is started to allow the auto-exposure algorithm to run). If
you are running your Pi from batteries, you should
<a class="reference internal" href="index.html#picamera.camera.PiCamera.close" title="picamera.camera.PiCamera.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> (or destroy) the instance when the camera is
not required in order to conserve power. For example, the following code
captures 60 images over an hour, but leaves the camera running all the time:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c"># Camera warm-up time</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">filename</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">camera</span><span class="o">.</span><span class="n">capture_continuous</span><span class="p">(</span><span class="s">&#39;image{counter:02d}.jpg&#39;</span><span class="p">)):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Captured </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
        <span class="c"># Capture one image a minute</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">59</span><span class="p">:</span>
            <span class="k">break</span>
</pre></div>
</div>
<p>By contrast, this code closes the camera between shots (but can&#8217;t use the
convenient <a class="reference internal" href="index.html#picamera.camera.PiCamera.capture_continuous" title="picamera.camera.PiCamera.capture_continuous"><code class="xref py py-meth docutils literal"><span class="pre">capture_continuous()</span></code></a> method as a
result):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">60</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c"># Camera warm-up time</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="s">&#39;image</span><span class="si">%02d</span><span class="s">.jpg&#39;</span> <span class="o">%</span> <span class="n">i</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Captured </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
    <span class="c"># Capture one image a minute</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">59</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Please note the timings in the scripts above are approximate. A more
precise example of timing is given in <a class="reference internal" href="index.html#timelapse-capture"><span>Capturing timelapse sequences</span></a>.</p>
</div>
<p>If you are experiencing lockups or reboots when the camera is active, your
power supply may be insufficient. A practical minimum is 1A for running a Pi
with an active camera module; more may be required if additional peripherals
are attached.</p>
</div>
<div class="section" id="how-can-i-take-two-consecutive-pictures-with-equivalent-settings">
<h4>How can I take two consecutive pictures with equivalent settings?<a class="headerlink" href="#how-can-i-take-two-consecutive-pictures-with-equivalent-settings" title="Permalink to this headline">¶</a></h4>
<p>See the <a class="reference internal" href="index.html#consistent-capture"><span>Capturing consistent images</span></a> recipe.</p>
</div>
<div class="section" id="can-i-use-picamera-with-a-usb-webcam">
<h4>Can I use picamera with a USB webcam?<a class="headerlink" href="#can-i-use-picamera-with-a-usb-webcam" title="Permalink to this headline">¶</a></h4>
<p>No. The picamera library relies on libmmal which is specific to the Pi&#8217;s camera
module.</p>
</div>
<div class="section" id="how-can-i-tell-what-version-of-picamera-i-have-installed">
<h4>How can I tell what version of picamera I have installed?<a class="headerlink" href="#how-can-i-tell-what-version-of-picamera-i-have-installed" title="Permalink to this headline">¶</a></h4>
<p>The picamera library relies on the setuptools package for installation
services.  You can use the setuptools <code class="docutils literal"><span class="pre">pkg_resources</span></code> API to query which
version of picamera is available in your Python environment like so:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pkg_resources</span> <span class="kn">import</span> <span class="n">require</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">require</span><span class="p">(</span><span class="s">&#39;picamera&#39;</span><span class="p">)</span>
<span class="go">[picamera 1.2 (/usr/local/lib/python2.7/dist-packages)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">require</span><span class="p">(</span><span class="s">&#39;picamera&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">version</span>
<span class="go">&#39;1.2&#39;</span>
</pre></div>
</div>
<p>If you have multiple versions installed (e.g. from <code class="docutils literal"><span class="pre">pip</span></code> and <code class="docutils literal"><span class="pre">apt-get</span></code>)
they will not show up in the list returned by the <code class="docutils literal"><span class="pre">require</span></code> method. However,
the first entry in the list will be the version that <code class="docutils literal"><span class="pre">import</span> <span class="pre">picamera</span></code> will
import.</p>
<p>If you receive the error &#8220;No module named pkg_resources&#8221;, you need to install
the <code class="docutils literal"><span class="pre">pip</span></code> utility. This can be done with the following command in Raspbian:</p>
<div class="highlight-python"><div class="highlight"><pre>$ sudo apt-get install python-pip
</pre></div>
</div>
</div>
<div class="section" id="how-come-i-can-t-upgrade-to-the-latest-version">
<h4>How come I can&#8217;t upgrade to the latest version?<a class="headerlink" href="#how-come-i-can-t-upgrade-to-the-latest-version" title="Permalink to this headline">¶</a></h4>
<p>If you are using Raspbian, firstly check that you haven&#8217;t got both a PyPI
(<code class="docutils literal"><span class="pre">pip</span></code>) and an apt (<code class="docutils literal"><span class="pre">apt-get</span></code>) installation of picamera installed
simultaneously. If you have, one will be taking precedence and it may not be
the most up to date version.</p>
<p>Secondly, please understand that while the PyPI release process is entirely
automated (so as soon as a new picamera release is announced, it will be
available on PyPI), the release process for Raspbian packages is semi-manual.
There is typically a delay of a few days after a release before updated
picamera packages become accessible in the Raspbian repository.</p>
<p>Users desperate to try the latest version may choose to uninstall their
<code class="docutils literal"><span class="pre">apt</span></code> based copy (uninstall instructions are provided in the
<a class="reference internal" href="index.html#raspbian-install2"><span>installation instructions</span></a>, and install using
<a class="reference internal" href="index.html#system-install2"><span>pip instead</span></a>. However, be aware that keeping a PyPI
based installation up to date is a more manual process (sticking with <code class="docutils literal"><span class="pre">apt</span></code>
ensures everything gets upgraded with a simple <code class="docutils literal"><span class="pre">sudo</span> <span class="pre">apt-get</span> <span class="pre">upgrade</span></code>
command).</p>
</div>
<div class="section" id="why-is-there-so-much-latency-when-streaming-video">
<h4>Why is there so much latency when streaming video?<a class="headerlink" href="#why-is-there-so-much-latency-when-streaming-video" title="Permalink to this headline">¶</a></h4>
<p>The first thing to understand is that streaming latency is nothing to do with
the encoding or sending end of things (i.e. the Pi), but mostly to do with the
playing or receiving end. If the Pi weren&#8217;t capable of encoding a frame before
the next frame arrived, it wouldn&#8217;t be capable of recording video at all
(because its internal buffers would rapidly become filled with unencoded
frames).</p>
<p>So, why do players typically introduce several seconds worth of latency? The
primary reason is that most players (e.g. VLC) are optimized for playing
streams over a network. Such players allocate a large (multi-second) buffer and
only start playing once this is filled to guard against possible future packet
loss.</p>
<p>A secondary reason that all such players allocate at least a couple of frames
worth of buffering is that the MPEG standard includes certain frame types that
require it:</p>
<ul class="simple">
<li>I-frames (intra-frames, also known as &#8220;key frames&#8221;). These frames contain a
complete picture and thus are the largest sort of frames. They occur at the
start of playback and at periodic points during the stream.</li>
<li>P-frames (predicted frames). These frames describe the changes from the prior
frame to the current frame, therefore one must have successfully decoded the
prior frame in order to decode a P-frame.</li>
<li>B-frames (bi-directional predicted frames). These frames describe the changes
from the next frame to the current frame, therefore one must have
successfully decoded the <em>next</em> frame in order to decode the current B-frame.</li>
</ul>
<p>B-frames aren&#8217;t produced by the Pi&#8217;s camera (or, as I understand it, by most
real-time recording cameras) as it would require buffering yet-to-be-recorded
frames before encoding the current one. However, most recorded media (DVDs,
BDs, and hence network video streams) do use them, so players must support
them. It is simplest to write such a player by assuming that any source may
contain B-frames, and buffering at least 2 frames worth of data at all times to
make decoding them simpler.</p>
<p>As for the network in between, a slow wifi network may introduce a frame&#8217;s
worth of latency, but not much more than that. Check the ping time across your
network; it&#8217;s likely to be less than 30ms in which case your network cannot
account for more than a frame&#8217;s worth of latency.</p>
<p>TL;DR: the reason you&#8217;ve got lots of latency when streaming video is nothing to
do with the Pi. You need to persuade your video player to reduce or forgo its
buffering.</p>
</div>
</div>
<span id="document-fov"></span><div class="section" id="camera-hardware">
<span id="id1"></span><h3>Camera Hardware<a class="headerlink" href="#camera-hardware" title="Permalink to this headline">¶</a></h3>
<p>This chapter attempts to provide an overview of the operation of the camera
under various conditions, as well as to provide an introduction to the low
level software interface that picamera utilizes.</p>
<div class="section" id="camera-modes">
<span id="id2"></span><h4>Camera Modes<a class="headerlink" href="#camera-modes" title="Permalink to this headline">¶</a></h4>
<p>The Pi&#8217;s camera has a discrete set of input modes which are as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="4%" />
<col width="16%" />
<col width="19%" />
<col width="18%" />
<col width="9%" />
<col width="9%" />
<col width="12%" />
<col width="12%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">#</th>
<th class="head">Resolution</th>
<th class="head">Aspect Ratio</th>
<th class="head">Framerates</th>
<th class="head">Video</th>
<th class="head">Image</th>
<th class="head">FoV</th>
<th class="head">Binning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>1920x1080</td>
<td>16:9</td>
<td>1-30fps</td>
<td>x</td>
<td>&nbsp;</td>
<td>Partial</td>
<td>None</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>2592x1944</td>
<td>4:3</td>
<td>1-15fps</td>
<td>x</td>
<td>x</td>
<td>Full</td>
<td>None</td>
</tr>
<tr class="row-even"><td>3</td>
<td>2592x1944</td>
<td>4:3</td>
<td>0.1666-1fps</td>
<td>x</td>
<td>x</td>
<td>Full</td>
<td>None</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>1296x972</td>
<td>4:3</td>
<td>1-42fps</td>
<td>x</td>
<td>&nbsp;</td>
<td>Full</td>
<td>2x2</td>
</tr>
<tr class="row-even"><td>5</td>
<td>1296x730</td>
<td>16:9</td>
<td>1-49fps</td>
<td>x</td>
<td>&nbsp;</td>
<td>Full</td>
<td>2x2</td>
</tr>
<tr class="row-odd"><td>6</td>
<td>640x480</td>
<td>4:3</td>
<td>42.1-60fps</td>
<td>x</td>
<td>&nbsp;</td>
<td>Full</td>
<td>4x4</td>
</tr>
<tr class="row-even"><td>7</td>
<td>640x480</td>
<td>4:3</td>
<td>60.1-90fps</td>
<td>x</td>
<td>&nbsp;</td>
<td>Full</td>
<td>4x4</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This table is accurate as of firmware revision #656. Firmwares prior to
this had a more restricted set of modes, and all video modes had partial
FoV. Please use <code class="docutils literal"><span class="pre">sudo</span> <span class="pre">apt-get</span> <span class="pre">dist-upgrade</span></code> to upgrade to the latest
firmware.</p>
</div>
<p>Modes with full field of view (FoV) capture from the whole area of the
camera&#8217;s sensor (2592x1944 pixels), using the specified amount of <a class="reference external" href="http://www.andor.com/learning-academy/ccd-binning-what-does-binning-mean">binning</a>
to achieve the requested resolution. Modes with partial FoV only capture from
the center 1920x1080 pixels. The difference between these areas is shown in
the illustration below:</p>
<a class="reference internal image-reference" href="_images/sensor_area.png"><img alt="_images/sensor_area.png" class="align-center" src="_images/sensor_area.png" style="width: 640px;" /></a>
<p>The input mode can be manually specified with the <em>sensor_mode</em> parameter in
the <a class="reference internal" href="index.html#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a> constructor (using one of the values
from the # column in the table above). This defaults to 0 indicating that the
mode should be selected automatically based on the requested
<a class="reference internal" href="index.html#picamera.camera.PiCamera.resolution" title="picamera.camera.PiCamera.resolution"><code class="xref py py-attr docutils literal"><span class="pre">resolution</span></code></a> and
<a class="reference internal" href="index.html#picamera.camera.PiCamera.framerate" title="picamera.camera.PiCamera.framerate"><code class="xref py py-attr docutils literal"><span class="pre">framerate</span></code></a>. The rules governing which input
mode is selected are as follows:</p>
<ul class="simple">
<li>The mode must be acceptable. Video modes can be used for video recording,
or for image captures from the video port (i.e. when <em>use_video_port</em> is
<code class="docutils literal"><span class="pre">True</span></code> in calls to the various capture methods). Image captures when
<em>use_video_port</em> is <code class="docutils literal"><span class="pre">False</span></code> must use an image mode (of which only two
currently exist, both with the maximum resolution).</li>
<li>The closer the requested <a class="reference internal" href="index.html#picamera.camera.PiCamera.resolution" title="picamera.camera.PiCamera.resolution"><code class="xref py py-attr docutils literal"><span class="pre">resolution</span></code></a> is to
the mode&#8217;s resolution the better, but downscaling from a higher input
resolution is preferable to upscaling from a lower input resolution.</li>
<li>The requested <a class="reference internal" href="index.html#picamera.camera.PiCamera.framerate" title="picamera.camera.PiCamera.framerate"><code class="xref py py-attr docutils literal"><span class="pre">framerate</span></code></a> should be within
the range of the input mode. Note that this is not a hard restriction (it is
possible, but unlikely, for the camera to select a mode that does not support
the requested framerate).</li>
<li>The closer the aspect ratio of the requested
<a class="reference internal" href="index.html#picamera.camera.PiCamera.resolution" title="picamera.camera.PiCamera.resolution"><code class="xref py py-attr docutils literal"><span class="pre">resolution</span></code></a> is to the mode&#8217;s resolution, the
better. Attempts to set resolutions with aspect ratios other than 4:3 or 16:9
(which are the only ratios directly supported by the modes in the table
above) will choose the mode which maximizes the resulting FoV.</li>
</ul>
<p>A few examples are given below to clarify the operation of this heuristic:</p>
<ul class="simple">
<li>If you set the <a class="reference internal" href="index.html#picamera.camera.PiCamera.resolution" title="picamera.camera.PiCamera.resolution"><code class="xref py py-attr docutils literal"><span class="pre">resolution</span></code></a> to 1024x768 (a
4:3 aspect ratio), and <a class="reference internal" href="index.html#picamera.camera.PiCamera.framerate" title="picamera.camera.PiCamera.framerate"><code class="xref py py-attr docutils literal"><span class="pre">framerate</span></code></a> to
anything less than 42fps, the 1296x976 mode will be selected, and the camera
will downscale the result to 1024x768.</li>
<li>If you set the <a class="reference internal" href="index.html#picamera.camera.PiCamera.resolution" title="picamera.camera.PiCamera.resolution"><code class="xref py py-attr docutils literal"><span class="pre">resolution</span></code></a> to 1280x720 (a
16:9 wide-screen aspect ratio), and
<a class="reference internal" href="index.html#picamera.camera.PiCamera.framerate" title="picamera.camera.PiCamera.framerate"><code class="xref py py-attr docutils literal"><span class="pre">framerate</span></code></a> to anything less than 49fps, the
1296x730 mode will be selected and downscaled appropriately.</li>
<li>Setting <a class="reference internal" href="index.html#picamera.camera.PiCamera.resolution" title="picamera.camera.PiCamera.resolution"><code class="xref py py-attr docutils literal"><span class="pre">resolution</span></code></a> to 1920x1080 and
<a class="reference internal" href="index.html#picamera.camera.PiCamera.framerate" title="picamera.camera.PiCamera.framerate"><code class="xref py py-attr docutils literal"><span class="pre">framerate</span></code></a> to 30fps exceeds the resolution
of both the 1296x730 and 1296x976 modes (i.e. they would require upscaling),
so the 1920x1080 mode is selected instead, although it has a reduced FoV.</li>
<li>A <a class="reference internal" href="index.html#picamera.camera.PiCamera.resolution" title="picamera.camera.PiCamera.resolution"><code class="xref py py-attr docutils literal"><span class="pre">resolution</span></code></a> of 800x600 and a
<a class="reference internal" href="index.html#picamera.camera.PiCamera.framerate" title="picamera.camera.PiCamera.framerate"><code class="xref py py-attr docutils literal"><span class="pre">framerate</span></code></a> of 60fps will select the 640x480
60fps mode, even though it requires upscaling because the algorithm considers
the framerate to take precedence in this case.</li>
<li>Any attempt to capture an image without using the video port will
(temporarily) select the 2592x1944 mode while the capture is performed (this
is what causes the flicker you sometimes see when a preview is running while
a still image is captured).</li>
</ul>
</div>
<div class="section" id="under-the-hood">
<span id="id3"></span><h4>Under the Hood<a class="headerlink" href="#under-the-hood" title="Permalink to this headline">¶</a></h4>
<p>This section attempts to provide detail of what picamera is doing &#8220;under the
hood&#8221; in response to various method calls.</p>
<p>The Pi&#8217;s camera has three ports, the still port, the video port, and the
preview port. The following sections describe how these ports are used by
picamera and how they influence the camera&#8217;s resolutions.</p>
<div class="section" id="the-still-port">
<h5>The Still Port<a class="headerlink" href="#the-still-port" title="Permalink to this headline">¶</a></h5>
<p>Firstly, the still port. Whenever this is used to capture images, it (briefly)
forces the camera&#8217;s mode to one of the two supported still modes (see
<a class="reference internal" href="#camera-modes"><span>Camera Modes</span></a>) so that images are captured using the full area of the
sensor. It also uses a strong de-noise algorithm on captured images so that
they appear higher quality.</p>
<p>The still port is used by the various <a class="reference internal" href="index.html#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a>
methods when their <em>use_video_port</em> parameter is <code class="docutils literal"><span class="pre">False</span></code> (which it is by
default).</p>
</div>
<div class="section" id="the-video-port">
<h5>The Video Port<a class="headerlink" href="#the-video-port" title="Permalink to this headline">¶</a></h5>
<p>The video port is somewhat simpler in that it never changes the camera&#8217;s mode.
The video port is used by the <a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a>
method (for recording video), and is also used by the various
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a> methods when their <em>use_video_port</em>
parameter is <code class="docutils literal"><span class="pre">True</span></code>. Images captured from the video port tend to have a
&#8220;grainy&#8221; appearance, much more akin to a video frame than the images captured
by the still port (this is due to the still port using a slower, more
aggressive denoise algorithm).</p>
</div>
<div class="section" id="the-preview-port">
<h5>The Preview Port<a class="headerlink" href="#the-preview-port" title="Permalink to this headline">¶</a></h5>
<p>The preview port operates more or less identically to the video port. The
preview port is always connected to some form of output to ensure that the
auto-gain algorithm can run. When an instance of
<a class="reference internal" href="index.html#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a> is constructed, the preview port is
initially connected to an instance of <a class="reference internal" href="index.html#picamera.renderers.PiNullSink" title="picamera.renderers.PiNullSink"><code class="xref py py-class docutils literal"><span class="pre">PiNullSink</span></code></a>.
When <a class="reference internal" href="index.html#picamera.camera.PiCamera.start_preview" title="picamera.camera.PiCamera.start_preview"><code class="xref py py-meth docutils literal"><span class="pre">start_preview()</span></code></a> is called, this null sink
is destroyed and the preview port is connected to an instance of
<a class="reference internal" href="index.html#picamera.renderers.PiPreviewRenderer" title="picamera.renderers.PiPreviewRenderer"><code class="xref py py-class docutils literal"><span class="pre">PiPreviewRenderer</span></code></a>. The reverse occurs when
<a class="reference internal" href="index.html#picamera.camera.PiCamera.stop_preview" title="picamera.camera.PiCamera.stop_preview"><code class="xref py py-meth docutils literal"><span class="pre">stop_preview()</span></code></a> is called.</p>
</div>
<div class="section" id="encoders">
<h5>Encoders<a class="headerlink" href="#encoders" title="Permalink to this headline">¶</a></h5>
<p>The camera provides various encoders which can be attached to the still and
video ports for the purpose of producing output (e.g. JPEG images or H.264
encoded video). A port can have a single encoder attached to it at any given
time (or nothing if the port is not in use).</p>
<p>Encoders are connected directly to the still port. For example, when capturing
a picture using the still port, the camera&#8217;s state conceptually moves through
these states:</p>
<div align="center" class="align-center"><img src="_images/still_port_capture.svg" /></div>
<p>As you have probably noticed in the diagram above, the video port is a little
more complex. In order to permit simultaneous video recording and image capture
via the video port, a &#8220;splitter&#8221; component is permanently connected to the
video port by picamera, and encoders are in turn attached to one of its four
output ports (numbered 0, 1, 2, and 3). Hence, when recording video the
camera&#8217;s setup looks like this:</p>
<div align="center" class="align-center"><img src="_images/video_port_record.svg" /></div>
<p>And when simultaneously capturing images via the video port whilst recording,
the camera&#8217;s configuration moves through the following states:</p>
<div align="center" class="align-center"><img src="_images/video_port_capture.svg" /></div>
<p>When the <code class="docutils literal"><span class="pre">resize</span></code> parameter is passed to one of the aforementioned methods, a
resizer component is placed between the camera&#8217;s ports and the encoder, causing
the output to be resized before it reaches the encoder. This is particularly
useful for video recording, as the H.264 encoder cannot cope with full
resolution input. Hence, when performing full frame video recording, the
camera&#8217;s setup looks like this:</p>
<div align="center" class="align-center"><img src="_images/video_fullfov_record.svg" /></div>
<p>Finally, when performing unencoded captures an encoder is (naturally) not
required.  Instead data is taken directly from the camera&#8217;s ports. When raw YUV
format is requested no components are attached to the ports at all (as all
ports default to YUV output). Likewise, when capturing unencoded from the still
port no encoders are used; instead the still port is reconfigured to output
the required encoding (RGB, RGBA, BGR, etc.)</p>
<p>However, the video port is fixed in YUV mode (the video encoders expect YUV
input and the splitter cannot convert encodings). When another raw format like
RGBA is requested, a resizer is used (with its output resolution set to the
input resolution, unless the <code class="docutils literal"><span class="pre">resize</span></code> option is specified with something
different), and its output format is set to the requested raw format:</p>
<div align="center" class="align-center"><img src="_images/still_raw_capture.svg" /></div>
<p>Please note that even the description above is almost certainly far removed
from what actually happens at the camera&#8217;s ISP level. Rather, what has been
described in this section is how the MMAL library exposes the camera to
applications which utilize it (these include the picamera library, along with
the official <cite>raspistill</cite> and <cite>raspivid</cite> applications).</p>
<p>In other words, by using picamera you are passing through (at least) two
abstraction layers which necessarily obscure (but hopefully simplify) the
&#8220;true&#8221; operation of the camera.</p>
</div>
</div>
</div>
<span id="document-deprecated"></span><div class="section" id="deprecated-functionality">
<span id="deprecated"></span><h3>Deprecated Functionality<a class="headerlink" href="#deprecated-functionality" title="Permalink to this headline">¶</a></h3>
<p>The picamera library is (at the time of writing) nearly a year old and has
grown quite rapidly in this time. Occasionally, when adding new functionality
to the library, the API is obvious and natural (e.g.
<a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> and
<a class="reference internal" href="index.html#picamera.camera.PiCamera.stop_recording" title="picamera.camera.PiCamera.stop_recording"><code class="xref py py-meth docutils literal"><span class="pre">stop_recording()</span></code></a>). At other times, it&#8217;s been
less obvious (e.g. unencoded captures) and my initial attempts have proven to
be less than ideal. In such situations I&#8217;ve endeavoured to improve the API
without breaking backward compatibility by introducing new methods or
attributes and deprecating the old ones.</p>
<p>This means that, as of release 1.8, there&#8217;s quite a lot of deprecated
functionality floating around the library which it would be nice to tidy up,
partly to simplify the library for debugging, and partly to simplify it for new
users. To assuage any fears that I&#8217;m imminently going to break backward
compatibility: I intend to leave a gap of at least a year between deprecating
functionality and removing it, hopefully providing ample time for people to
migrate their scripts.</p>
<p>Furthermore, to distinguish any release which is backwards incompatible, I
would increment the major version number in accordance with <a class="reference external" href="http://semver.org/">semantic
versioning</a>. In other words, the first release in which currently deprecated
functionality would be removed would be version 2.0, and as of the release of
1.8 it&#8217;s at least a year away. Any future 1.x releases will include all
currently deprecated functions.</p>
<p>Of course, that still means people need a way of determining whether their
scripts use any deprecated functionality in the picamera library. All
deprecated functionality is documented, and the documentation includes pointers
to the intended replacement functionality (see
<a class="reference internal" href="index.html#picamera.camera.PiCamera.raw_format" title="picamera.camera.PiCamera.raw_format"><code class="xref py py-attr docutils literal"><span class="pre">raw_format</span></code></a> for example). However, Python also
provides excellent methods for determining automatically whether any deprecated
functionality is being used via the <a class="reference external" href="http://docs.python.org/3.2/library/warnings.html#module-warnings" title="(in Python v3.2)"><code class="xref py py-mod docutils literal"><span class="pre">warnings</span></code></a> module.</p>
<div class="section" id="finding-and-fixing-deprecated-usage">
<span id="find-deprecated"></span><h4>Finding and fixing deprecated usage<a class="headerlink" href="#finding-and-fixing-deprecated-usage" title="Permalink to this headline">¶</a></h4>
<p>As of release 1.8, all deprecated functionality will raise
<a class="reference external" href="http://docs.python.org/3.2/library/exceptions.html#DeprecationWarning" title="(in Python v3.2)"><code class="xref py py-exc docutils literal"><span class="pre">DeprecationWarning</span></code></a> when used. By default, the Python interpreter
suppresses these warnings (as they&#8217;re only of interest to developers, not
users) but you can easily configure different behaviour.</p>
<p>The following example script uses a number of deprecated functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">preview_fullscreen</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">preview_alpha</span> <span class="o">=</span> <span class="mi">128</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">raw_format</span> <span class="o">=</span> <span class="s">&#39;yuv&#39;</span>
    <span class="n">stream</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="s">&#39;raw&#39;</span><span class="p">,</span> <span class="n">use_video_port</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Despite using deprecated functionality the script runs happily (and silently)
with picamera 1.8. To discover what deprecated functions are being used, we add
a couple of lines to tell the warnings module that we want &#8220;default&#8221; handling
of <a class="reference external" href="http://docs.python.org/3.2/library/exceptions.html#DeprecationWarning" title="(in Python v3.2)"><code class="xref py py-exc docutils literal"><span class="pre">DeprecationWarning</span></code></a>; &#8220;default&#8221; handling means that the first time an
attempt is made to raise this warning at a particular location, the warning&#8217;s
details will be printed to the console. All future invocations from the same
location will be ignored. This saves flooding the console with warning details
from tight loops. With this change, the script looks like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s">&#39;default&#39;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">)</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">preview_fullscreen</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">preview_alpha</span> <span class="o">=</span> <span class="mi">128</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">raw_format</span> <span class="o">=</span> <span class="s">&#39;yuv&#39;</span>
    <span class="n">stream</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="s">&#39;raw&#39;</span><span class="p">,</span> <span class="n">use_video_port</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>And produces the following output on the console when run:</p>
<div class="highlight-python"><div class="highlight"><pre>/usr/share/pyshared/picamera/camera.py:149: DeprecationWarning: Setting framerate or gains as a tuple is deprecated; please use one of Python&#39;s many numeric classes like int, float, Decimal, or Fraction instead
  &quot;Setting framerate or gains as a tuple is deprecated; &quot;
/usr/share/pyshared/picamera/camera.py:3125: DeprecationWarning: PiCamera.preview_fullscreen is deprecated; use PiCamera.preview.fullscreen instead
  &#39;PiCamera.preview_fullscreen is deprecated; &#39;
/usr/share/pyshared/picamera/camera.py:3068: DeprecationWarning: PiCamera.preview_alpha is deprecated; use PiCamera.preview.alpha instead
  &#39;PiCamera.preview_alpha is deprecated; use &#39;
/usr/share/pyshared/picamera/camera.py:1833: DeprecationWarning: PiCamera.raw_format is deprecated; use required format directly with capture methods instead
  &#39;PiCamera.raw_format is deprecated; use required format &#39;
/usr/share/pyshared/picamera/camera.py:1359: DeprecationWarning: The &quot;raw&quot; format option is deprecated; specify the required format directly instead (&quot;yuv&quot;, &quot;rgb&quot;, etc.)
  &#39;The &quot;raw&quot; format option is deprecated; specify the &#39;
/usr/share/pyshared/picamera/camera.py:1827: DeprecationWarning: PiCamera.raw_format is deprecated; use required format directly with capture methods instead
  &#39;PiCamera.raw_format is deprecated; use required format &#39;
</pre></div>
</div>
<p>This tells us which pieces of deprecated functionality are being used in our
script, but it doesn&#8217;t tell us where in the script they were used. For this,
it is more useful to have warnings converted into full blown exceptions. With
this change, each time a <a class="reference external" href="http://docs.python.org/3.2/library/exceptions.html#DeprecationWarning" title="(in Python v3.2)"><code class="xref py py-exc docutils literal"><span class="pre">DeprecationWarning</span></code></a> would have been printed, it
will instead cause the script to terminate with an unhandled exception and a
full stack trace:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s">&#39;error&#39;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">)</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">preview_fullscreen</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">preview_alpha</span> <span class="o">=</span> <span class="mi">128</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">raw_format</span> <span class="o">=</span> <span class="s">&#39;yuv&#39;</span>
    <span class="n">stream</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="s">&#39;raw&#39;</span><span class="p">,</span> <span class="n">use_video_port</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Now when we run the script it produces the following:</p>
<div class="highlight-python"><div class="highlight"><pre>Traceback (most recent call last):
  File &quot;test_deprecated.py&quot;, line 10, in &lt;module&gt;
    camera.framerate = (24, 1)
  File &quot;/usr/share/pyshared/picamera/camera.py&quot;, line 1888, in _set_framerate
    n, d = to_rational(value)
  File &quot;/usr/share/pyshared/picamera/camera.py&quot;, line 149, in to_rational
    &quot;Setting framerate or gains as a tuple is deprecated; &quot;
DeprecationWarning: Setting framerate or gains as a tuple is deprecated; please use one of Python&#39;s many numeric classes like int, float, Decimal, or Fraction instead
</pre></div>
</div>
<p>This tells us that line 10 of our script is using deprecated functionality, and
provides a hint of how to fix it. We change line 10 to use an int instead of a
tuple for the framerate. Now we run again, and this time get the following:</p>
<div class="highlight-python"><div class="highlight"><pre>Traceback (most recent call last):
  File &quot;test_deprecated.py&quot;, line 12, in &lt;module&gt;
    camera.preview_fullscreen = True
  File &quot;/usr/share/pyshared/picamera/camera.py&quot;, line 3125, in _set_preview_fullscreen
    &#39;PiCamera.preview_fullscreen is deprecated; &#39;
DeprecationWarning: PiCamera.preview_fullscreen is deprecated; use PiCamera.preview.fullscreen instead
</pre></div>
</div>
<p>Now we can tell line 12 has a problem, and once again the exception tells us
how to fix it. We continue in this fashion until the script looks like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s">&#39;error&#39;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">)</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="mi">24</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">preview</span><span class="o">.</span><span class="n">fullscreen</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">preview</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="mi">128</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">stream</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="s">&#39;yuv&#39;</span><span class="p">,</span> <span class="n">use_video_port</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The script now runs to completion, so we can be confident it&#8217;s no longer using
any deprecated functionality and will run happily even when this functionality
is removed in release 2.0. At this point, you may wish to remove the
<code class="docutils literal"><span class="pre">filterwarnings</span></code> line as well (or at least comment it out).</p>
</div>
<div class="section" id="list-of-deprecated-functionality">
<span id="deprecated-list"></span><h4>List of deprecated functionality<a class="headerlink" href="#list-of-deprecated-functionality" title="Permalink to this headline">¶</a></h4>
<p>For convenience, all currently deprecated functionality is detailed below. You
may wish to skim this list to check whether you&#8217;re currently using deprecated
functions, but I would urge users to take advantage of the warnings system
documented in the prior section as well.</p>
<div class="section" id="unencoded-captures">
<span id="deprecated-raw-capture"></span><h5>Unencoded captures<a class="headerlink" href="#unencoded-captures" title="Permalink to this headline">¶</a></h5>
<p>In very early versions of picamera, unencoded captures were created by
specifying the <code class="docutils literal"><span class="pre">'raw'</span></code> format with the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a> method, with the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.raw_format" title="picamera.camera.PiCamera.raw_format"><code class="xref py py-attr docutils literal"><span class="pre">raw_format</span></code></a> attribute providing the actual
encoding. The attribute is deprecated, as is usage of the value <code class="docutils literal"><span class="pre">'raw'</span></code> with
the <em>format</em> parameter of all the capture methods.</p>
<p>The deprecated method of taking unencoded captures looks like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">camera</span><span class="o">.</span><span class="n">raw_format</span> <span class="o">=</span> <span class="s">&#39;rgb&#39;</span>
<span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="s">&#39;output.data&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;raw&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In such cases, simply remove references to
<a class="reference internal" href="index.html#picamera.camera.PiCamera.raw_format" title="picamera.camera.PiCamera.raw_format"><code class="xref py py-attr docutils literal"><span class="pre">raw_format</span></code></a> and place the required format
directly within the <a class="reference internal" href="index.html#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a> call:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="s">&#39;output.data&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;rgb&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="recording-quality">
<span id="deprecated-quantization"></span><h5>Recording quality<a class="headerlink" href="#recording-quality" title="Permalink to this headline">¶</a></h5>
<p>The <em>quantization</em> parameter for
<a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> and
<a class="reference internal" href="index.html#picamera.camera.PiCamera.record_sequence" title="picamera.camera.PiCamera.record_sequence"><code class="xref py py-meth docutils literal"><span class="pre">record_sequence()</span></code></a> is deprecated in favor of the
<em>quality</em> parameter; this change was made to keep the recording methods
consistent with the capture methods, and to make the meaning of the parameter
more obvious to newcomers. The values of the parameter remain the same (i.e.
1-100 for MJPEG recordings with higher values indicating higher quality, and
1-40 for H.264 recordings with lower values indicating higher quality).</p>
<p>The deprecated method of setting recording quality looks like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">camera</span><span class="o">.</span><span class="n">start_recording</span><span class="p">(</span><span class="s">&#39;foo.h264&#39;</span><span class="p">,</span> <span class="n">quantization</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
</pre></div>
</div>
<p>Simply replace the <code class="docutils literal"><span class="pre">quantization</span></code> parameter with the <code class="docutils literal"><span class="pre">quality</span></code> parameter
like so:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">camera</span><span class="o">.</span><span class="n">start_recording</span><span class="p">(</span><span class="s">&#39;foo.h264&#39;</span><span class="p">,</span> <span class="n">quality</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="fractions-as-tuples">
<span id="deprecated-fractions"></span><h5>Fractions as tuples<a class="headerlink" href="#fractions-as-tuples" title="Permalink to this headline">¶</a></h5>
<p>Several attributes in picamera expect rational (fractional) values. In early
versions of picamera, these values could only be specified as a tuple expressed
as <code class="docutils literal"><span class="pre">(numerator,</span> <span class="pre">denominator)</span></code>. In later versions, support was expanded to
accept any of Python&#8217;s numeric types.</p>
<p>The following code illustrates the deprecated usage of a tuple representing
a rational value:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Such cases can be replaced with any of Python&#8217;s numeric types, including
<a class="reference external" href="http://docs.python.org/3.2/library/stdtypes.html#typesnumeric" title="(in Python v3.2)"><span class="xref std std-ref">int</span></a>, <a class="reference external" href="http://docs.python.org/3.2/library/stdtypes.html#typesnumeric" title="(in Python v3.2)"><span class="xref std std-ref">float</span></a>,
<a class="reference external" href="http://docs.python.org/3.2/library/decimal.html#decimal.Decimal" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">Decimal</span></code></a>, and <a class="reference external" href="http://docs.python.org/3.2/library/fractions.html#fractions.Fraction" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">Fraction</span></code></a>. All the following
examples are functionally equivalent to the deprecated example above:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span>
<span class="kn">from</span> <span class="nn">fractions</span> <span class="kn">import</span> <span class="n">Fraction</span>

<span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="mi">24</span>
<span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="mf">24.0</span>
<span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="mi">72</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="s">&#39;24&#39;</span><span class="p">)</span>
<span class="n">camera</span><span class="o">.</span><span class="n">framerate</span> <span class="o">=</span> <span class="n">Fraction</span><span class="p">(</span><span class="s">&#39;48/2&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>These attributes return a <a class="reference external" href="http://docs.python.org/3.2/library/fractions.html#fractions.Fraction" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">Fraction</span></code></a> instance as well, but
one modified to permit access as a tuple in order to maintain backward
compatibility. This is also deprecated behaviour. The following example
demonstrates accessing the <a class="reference internal" href="index.html#picamera.camera.PiCamera.framerate" title="picamera.camera.PiCamera.framerate"><code class="xref py py-attr docutils literal"><span class="pre">framerate</span></code></a>
attribute as a tuple:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;The framerate is </span><span class="si">%d</span><span class="s">/</span><span class="si">%d</span><span class="s"> fps&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
</pre></div>
</div>
<p>In such cases, use the standard <code class="xref py py-attr docutils literal"><span class="pre">numerator</span></code> and
<code class="xref py py-attr docutils literal"><span class="pre">denominator</span></code> attributes of the returned fraction
instead:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">camera</span><span class="o">.</span><span class="n">framerate</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;The framerate is </span><span class="si">%d</span><span class="s">/</span><span class="si">%d</span><span class="s"> fps&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">numerator</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">denominator</span><span class="p">))</span>
</pre></div>
</div>
<p>Alternatively, you may wish to simply convert the <a class="reference external" href="http://docs.python.org/3.2/library/fractions.html#fractions.Fraction" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">Fraction</span></code></a>
instance to a <a class="reference external" href="http://docs.python.org/3.2/library/stdtypes.html#typesnumeric" title="(in Python v3.2)"><span class="xref std std-ref">float</span></a> for greater convenience:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">camera</span><span class="o">.</span><span class="n">framerate</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;The framerate is </span><span class="si">%0.2f</span><span class="s"> fps&#39;</span> <span class="o">%</span> <span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="preview-functions">
<span id="deprecated-preview"></span><h5>Preview functions<a class="headerlink" href="#preview-functions" title="Permalink to this headline">¶</a></h5>
<p>Release 1.8 introduced rather sweeping changes to the preview system to
incorporate the ability to create multiple static overlays on top of the
preview. As a result, the preview system is no longer incorporated into the
<a class="reference internal" href="index.html#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a> class. Instead, it is represented by the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.preview" title="picamera.camera.PiCamera.preview"><code class="xref py py-attr docutils literal"><span class="pre">preview</span></code></a> attribute which is a separate
<a class="reference internal" href="index.html#picamera.renderers.PiPreviewRenderer" title="picamera.renderers.PiPreviewRenderer"><code class="xref py py-class docutils literal"><span class="pre">PiPreviewRenderer</span></code></a> instance when the preview is
active.</p>
<p>This change meant that <a class="reference internal" href="index.html#picamera.camera.PiCamera.preview_alpha" title="picamera.camera.PiCamera.preview_alpha"><code class="xref py py-attr docutils literal"><span class="pre">preview_alpha</span></code></a> was
deprecated in favor of the <a class="reference internal" href="index.html#picamera.renderers.PiRenderer.alpha" title="picamera.renderers.PiRenderer.alpha"><code class="xref py py-attr docutils literal"><span class="pre">alpha</span></code></a>
property of the new <a class="reference internal" href="index.html#picamera.camera.PiCamera.preview" title="picamera.camera.PiCamera.preview"><code class="xref py py-attr docutils literal"><span class="pre">preview</span></code></a> attribute.
Similar changes were made to <a class="reference internal" href="index.html#picamera.camera.PiCamera.preview_layer" title="picamera.camera.PiCamera.preview_layer"><code class="xref py py-attr docutils literal"><span class="pre">preview_layer</span></code></a>,
<a class="reference internal" href="index.html#picamera.camera.PiCamera.preview_fullscreen" title="picamera.camera.PiCamera.preview_fullscreen"><code class="xref py py-attr docutils literal"><span class="pre">preview_fullscreen</span></code></a>, and
<a class="reference internal" href="index.html#picamera.camera.PiCamera.preview_window" title="picamera.camera.PiCamera.preview_window"><code class="xref py py-attr docutils literal"><span class="pre">preview_window</span></code></a>. The following snippet
illustrates the deprecated method of setting preview related attributes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
<span class="n">camera</span><span class="o">.</span><span class="n">preview_alpha</span> <span class="o">=</span> <span class="mi">128</span>
<span class="n">camera</span><span class="o">.</span><span class="n">preview_fullscreen</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">camera</span><span class="o">.</span><span class="n">preview_window</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
</pre></div>
</div>
<p>In this case, where preview attributes are altered <em>after</em> the preview has
been activated, simply modify the corresponding attributes on the preview
object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
<span class="n">camera</span><span class="o">.</span><span class="n">preview</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="mi">128</span>
<span class="n">camera</span><span class="o">.</span><span class="n">preview</span><span class="o">.</span><span class="n">fullscreen</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">camera</span><span class="o">.</span><span class="n">preview</span><span class="o">.</span><span class="n">window</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
</pre></div>
</div>
<p>Unfortuantely, this simple change is not possible when preview attributes are
altered <em>before</em> the preview has been activated, as the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.preview" title="picamera.camera.PiCamera.preview"><code class="xref py py-attr docutils literal"><span class="pre">preview</span></code></a> attribute is <code class="docutils literal"><span class="pre">None</span></code> when the
preview is not active. To accomodate this use-case, optional parameters were
added to <a class="reference internal" href="index.html#picamera.camera.PiCamera.start_preview" title="picamera.camera.PiCamera.start_preview"><code class="xref py py-meth docutils literal"><span class="pre">start_preview()</span></code></a> to provide initial
settings for the preview renderer. The following example illustrates the
deprecated method of setting preview related attribtues prior to activating
the preview:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">camera</span><span class="o">.</span><span class="n">preview_alpha</span> <span class="o">=</span> <span class="mi">128</span>
<span class="n">camera</span><span class="o">.</span><span class="n">preview_fullscreen</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">camera</span><span class="o">.</span><span class="n">preview_window</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
<span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
</pre></div>
</div>
<p>Remove the lines setting the attributes, and use the corresponding keyword
parameters of the <a class="reference internal" href="index.html#picamera.camera.PiCamera.start_preview" title="picamera.camera.PiCamera.start_preview"><code class="xref py py-meth docutils literal"><span class="pre">start_preview()</span></code></a> method
instead:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">(</span>
    <span class="n">alpha</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">fullscreen</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">))</span>
</pre></div>
</div>
<p>Finally, the <a class="reference internal" href="index.html#picamera.camera.PiCamera.previewing" title="picamera.camera.PiCamera.previewing"><code class="xref py py-attr docutils literal"><span class="pre">previewing</span></code></a> attribute is now
obsolete (and thus deprecated) as its functionality can be trivially obtained
by checking the <a class="reference internal" href="index.html#picamera.camera.PiCamera.preview" title="picamera.camera.PiCamera.preview"><code class="xref py py-attr docutils literal"><span class="pre">preview</span></code></a> attribute. The
following example illustrates the deprecated method of checking whether the
preview is activate:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">camera</span><span class="o">.</span><span class="n">previewing</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;The camera preview is running&#39;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;The camera preview is not running&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Simply replace <a class="reference internal" href="index.html#picamera.camera.PiCamera.previewing" title="picamera.camera.PiCamera.previewing"><code class="xref py py-attr docutils literal"><span class="pre">previewing</span></code></a> with
<a class="reference internal" href="index.html#picamera.camera.PiCamera.preview" title="picamera.camera.PiCamera.preview"><code class="xref py py-attr docutils literal"><span class="pre">preview</span></code></a> to bring this code up to date:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">camera</span><span class="o">.</span><span class="n">preview</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;The camera preview is running&#39;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;The camera preview is not running&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="array-stream-truncation">
<span id="deprecated-truncate"></span><h5>Array stream truncation<a class="headerlink" href="#array-stream-truncation" title="Permalink to this headline">¶</a></h5>
<p>In release 1.8, the base <a class="reference internal" href="index.html#picamera.array.PiArrayOutput" title="picamera.array.PiArrayOutput"><code class="xref py py-class docutils literal"><span class="pre">PiArrayOutput</span></code></a> class was
changed to derive from <a class="reference external" href="http://docs.python.org/3.2/library/io.html#io.BytesIO" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">io.BytesIO</span></code></a> in order to add support for seeking,
and to improve performance. The prior implementation had been non-seekable, and
therefore to accommodate re-use of the stream between captures the
<a class="reference internal" href="index.html#picamera.array.PiArrayOutput.truncate" title="picamera.array.PiArrayOutput.truncate"><code class="xref py py-meth docutils literal"><span class="pre">truncate()</span></code></a> method had an unusual
side-effect not seen with regular Python streams: after truncation, the
position of the stream was set to the new length of the stream. In all other
Python streams, the <code class="docutils literal"><span class="pre">truncate</span></code> method doesn&#8217;t affect the stream position. The
method is overridden in 1.8 to maintain its unusual behaviour, but this
behaviour is nonetheless deprecated.</p>
<p>The following snippet illustrates the method of truncating an array stream
in picamera versions 1.7 and older:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">PiYUVArray</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span> <span class="k">as</span> <span class="n">stream</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="s">&#39;yuv&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>If you only need your script to work with picamera versions 1.8 and newer,
such code should be updated to use <code class="docutils literal"><span class="pre">seek</span></code> and <code class="docutils literal"><span class="pre">truncate</span></code> as you would
with any regular Python stream instance:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">PiYUVArray</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span> <span class="k">as</span> <span class="n">stream</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="s">&#39;yuv&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span>
</pre></div>
</div>
<p>Unfortunately, this will not work if your script needs to work with prior
versions of picamera as well (since such streams were non-seekable in prior
versions). In this case, call <code class="xref py py-meth docutils literal"><span class="pre">seekable()</span></code> to determine the
correct course of action:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">PiYUVArray</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span> <span class="k">as</span> <span class="n">stream</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="s">&#39;yuv&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">stream</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stream</span><span class="o">.</span><span class="n">seekable</span><span class="p">():</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stream</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="confusing-crop">
<span id="deprecated-crop"></span><h5>Confusing crop<a class="headerlink" href="#confusing-crop" title="Permalink to this headline">¶</a></h5>
<p>In release 1.8, the <a class="reference internal" href="index.html#picamera.camera.PiCamera.crop" title="picamera.camera.PiCamera.crop"><code class="xref py py-attr docutils literal"><span class="pre">crop</span></code></a> attribute was
renamed to <a class="reference internal" href="index.html#picamera.camera.PiCamera.zoom" title="picamera.camera.PiCamera.zoom"><code class="xref py py-attr docutils literal"><span class="pre">zoom</span></code></a>; the old name was retained as
a deprecated alias for backward compatibility. This change was made as <code class="docutils literal"><span class="pre">crop</span></code>
was a thoroughly misleading name for the attribute (which actually sets the
&#8220;region of interest&#8221; for the sensor), leading to numerous support questions.</p>
<p>The following example illustrates the deprecated attribute name:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">camera</span><span class="o">.</span><span class="n">crop</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>Simply replace <a class="reference internal" href="index.html#picamera.camera.PiCamera.crop" title="picamera.camera.PiCamera.crop"><code class="xref py py-attr docutils literal"><span class="pre">crop</span></code></a> with
<a class="reference internal" href="index.html#picamera.camera.PiCamera.zoom" title="picamera.camera.PiCamera.zoom"><code class="xref py py-attr docutils literal"><span class="pre">zoom</span></code></a> in such cases:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">camera</span><span class="o">.</span><span class="n">zoom</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="incorrect-iso-capitalisation">
<span id="deprecated-iso"></span><h5>Incorrect ISO capitalisation<a class="headerlink" href="#incorrect-iso-capitalisation" title="Permalink to this headline">¶</a></h5>
<p>In release 1.8, the <a class="reference internal" href="index.html#picamera.camera.PiCamera.ISO" title="picamera.camera.PiCamera.ISO"><code class="xref py py-attr docutils literal"><span class="pre">ISO</span></code></a> attribute was renamed
to <a class="reference internal" href="index.html#picamera.camera.PiCamera.iso" title="picamera.camera.PiCamera.iso"><code class="xref py py-attr docutils literal"><span class="pre">iso</span></code></a> for compliance with <a class="reference external" href="http://legacy.python.org/dev/peps/pep-0008/">PEP-8</a> (even
though it&#8217;s an acronym this is still more consistent with the existing API;
consider <a class="reference internal" href="index.html#picamera.camera.PiCamera.led" title="picamera.camera.PiCamera.led"><code class="xref py py-attr docutils literal"><span class="pre">led</span></code></a>,
<a class="reference internal" href="index.html#picamera.camera.PiCamera.awb_mode" title="picamera.camera.PiCamera.awb_mode"><code class="xref py py-attr docutils literal"><span class="pre">awb_mode</span></code></a>, and so on).</p>
<p>The following example illustrates the deprecated attribute case:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">camera</span><span class="o">.</span><span class="n">ISO</span> <span class="o">=</span> <span class="mi">100</span>
</pre></div>
</div>
<p>Simply replace references to <a class="reference internal" href="index.html#picamera.camera.PiCamera.ISO" title="picamera.camera.PiCamera.ISO"><code class="xref py py-attr docutils literal"><span class="pre">ISO</span></code></a> with
<a class="reference internal" href="index.html#picamera.camera.PiCamera.iso" title="picamera.camera.PiCamera.iso"><code class="xref py py-attr docutils literal"><span class="pre">iso</span></code></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">camera</span><span class="o">.</span><span class="n">iso</span> <span class="o">=</span> <span class="mi">100</span>
</pre></div>
</div>
</div>
<div class="section" id="frame-types">
<span id="deprecated-frame-type"></span><h5>Frame types<a class="headerlink" href="#frame-types" title="Permalink to this headline">¶</a></h5>
<p>Over time, several capabilities were added to the H.264 encoder in the GPU
firmware. This expanded the number of possible frame types from a simple
key-frame / non-key-frame affair, to a multitude of possibilities (P-frame,
I-frame, SPS/PPS header, motion vector data, and who knows in future). Rather
than keep adding more and more boolean fields to the
<a class="reference internal" href="index.html#picamera.encoders.PiVideoFrame" title="picamera.encoders.PiVideoFrame"><code class="xref py py-class docutils literal"><span class="pre">PiVideoFrame</span></code></a> named tuple, release 1.5 introduced
the <a class="reference internal" href="index.html#picamera.encoders.PiVideoFrameType" title="picamera.encoders.PiVideoFrameType"><code class="xref py py-class docutils literal"><span class="pre">PiVideoFrameType</span></code></a> enumeration used by the
<a class="reference internal" href="index.html#picamera.encoders.PiVideoFrame.frame_type" title="picamera.encoders.PiVideoFrame.frame_type"><code class="xref py py-attr docutils literal"><span class="pre">frame_type</span></code></a> attribute and deprecated the
<a class="reference internal" href="index.html#picamera.encoders.PiVideoFrame.keyframe" title="picamera.encoders.PiVideoFrame.keyframe"><code class="xref py py-attr docutils literal"><span class="pre">keyframe</span></code></a> and
<a class="reference internal" href="index.html#picamera.encoders.PiVideoFrame.header" title="picamera.encoders.PiVideoFrame.header"><code class="xref py py-attr docutils literal"><span class="pre">header</span></code></a> attributes.</p>
<p>The following code illustrates usage of the deprecated boolean fields:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">camera</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">keyframe</span><span class="p">:</span>
    <span class="n">handle_keyframe</span><span class="p">()</span>
<span class="k">elif</span> <span class="n">camera</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">header</span><span class="p">:</span>
    <span class="n">handle_header</span><span class="p">()</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">handle_frame</span><span class="p">()</span>
</pre></div>
</div>
<p>In such cases, test the <a class="reference internal" href="index.html#picamera.encoders.PiVideoFrame.frame_type" title="picamera.encoders.PiVideoFrame.frame_type"><code class="xref py py-attr docutils literal"><span class="pre">frame_type</span></code></a>
attribute against the corresponding value of the
<a class="reference internal" href="index.html#picamera.encoders.PiVideoFrameType" title="picamera.encoders.PiVideoFrameType"><code class="xref py py-class docutils literal"><span class="pre">PiVideoFrameType</span></code></a> enumeration:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">camera</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">frame_type</span> <span class="o">==</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiVideoFrameType</span><span class="o">.</span><span class="n">key_frame</span><span class="p">:</span>
    <span class="n">handle_keyframe</span><span class="p">()</span>
<span class="k">elif</span> <span class="n">camera</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">frame_type</span> <span class="o">==</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiVideoFrameType</span><span class="o">.</span><span class="n">sps_header</span><span class="p">:</span>
    <span class="n">handle_header</span><span class="p">()</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">handle_frame</span><span class="p">()</span>
</pre></div>
</div>
<p>Alternatively, you may find something like this more elegant (and more future
proof as it&#8217;ll throw a <a class="reference external" href="http://docs.python.org/3.2/library/exceptions.html#KeyError" title="(in Python v3.2)"><code class="xref py py-exc docutils literal"><span class="pre">KeyError</span></code></a> in the event of an unrecognized
frame type):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">handler</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">picamera</span><span class="o">.</span><span class="n">PiVideoFrameType</span><span class="o">.</span><span class="n">key_frame</span><span class="p">:</span>  <span class="n">handle_keyframe</span><span class="p">,</span>
    <span class="n">picamera</span><span class="o">.</span><span class="n">PiVideoFrameType</span><span class="o">.</span><span class="n">sps_header</span><span class="p">:</span> <span class="n">handle_header</span><span class="p">,</span>
    <span class="n">picamera</span><span class="o">.</span><span class="n">PiVideoFrameType</span><span class="o">.</span><span class="n">frame</span><span class="p">:</span>      <span class="n">handle_frame</span><span class="p">,</span>
    <span class="p">}[</span><span class="n">camera</span><span class="o">.</span><span class="n">frame</span><span class="o">.</span><span class="n">frame_type</span><span class="p">]</span>
<span class="n">handler</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="annotation-background-color">
<span id="deprecated-annotate-background"></span><h5>Annotation background color<a class="headerlink" href="#annotation-background-color" title="Permalink to this headline">¶</a></h5>
<p>In release 1.10, the <a class="reference internal" href="index.html#picamera.camera.PiCamera.annotate_background" title="picamera.camera.PiCamera.annotate_background"><code class="xref py py-attr docutils literal"><span class="pre">annotate_background</span></code></a>
attribute was enhanced to support setting the background color of annotation
text. Older versions of picamera treated this attribute as a bool (<code class="docutils literal"><span class="pre">False</span></code>
for no background, <code class="docutils literal"><span class="pre">True</span></code> to draw a black background).</p>
<p>In order to provide the new functionality while maintaining a certain amount of
backward compatibility, the new attribute accepts <code class="docutils literal"><span class="pre">None</span></code> for no background
and a <a class="reference internal" href="index.html#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> instance for a custom background color.
It is worth noting that the truth values of <code class="docutils literal"><span class="pre">None</span></code> and <code class="docutils literal"><span class="pre">False</span></code> are
equivalent, as are the truth values of a <a class="reference internal" href="index.html#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a>
instance and <code class="docutils literal"><span class="pre">True</span></code>. Hence, naive tests against the attribute value will
continue to work.</p>
<p>The following example illustrates the deprecated behaviour of setting the
attribute as a boolean:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">camera</span><span class="o">.</span><span class="n">annotate_background</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">camera</span><span class="o">.</span><span class="n">annotate_background</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>
</div>
<p>In such cases, replace <code class="docutils literal"><span class="pre">False</span></code> with <code class="docutils literal"><span class="pre">None</span></code>, and <code class="docutils literal"><span class="pre">True</span></code> with a
<a class="reference internal" href="index.html#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> instance of your choosing. Bear in mind that
older Pi firmwares can only produce a black background, so you may wish to
stick with black to ensure equivalent behaviour:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">camera</span><span class="o">.</span><span class="n">annotate_background</span> <span class="o">=</span> <span class="bp">None</span>
<span class="n">camera</span><span class="o">.</span><span class="n">annotate_background</span> <span class="o">=</span> <span class="n">picamera</span><span class="o">.</span><span class="n">Color</span><span class="p">(</span><span class="s">&#39;black&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Naive tests against the attribute should work as normal, but specific tests
(which are considered bad practice anyway), should be re-written. The following
example illustrates specific boolean tests:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="n">camera</span><span class="o">.</span><span class="n">annotate_background</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="k">if</span> <span class="n">camera</span><span class="o">.</span><span class="n">annotate_background</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>Such cases should be re-written to remove the specific boolean value mentioned
in the test (this is a general rule, not limited to this deprecation case):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">if</span> <span class="ow">not</span> <span class="n">camera</span><span class="o">.</span><span class="n">annotate_background</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="k">if</span> <span class="n">camera</span><span class="o">.</span><span class="n">annotate_background</span><span class="p">:</span>
    <span class="k">pass</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-api"></span><div class="section" id="module-picamera">
<span id="api-picamera-package"></span><span id="api"></span><h3>API - <code class="docutils literal"><span class="pre">picamera</span></code> Package<a class="headerlink" href="#module-picamera" title="Permalink to this headline">¶</a></h3>
<p>The picamera package consists of several modules which provide a pure Python
interface to the Raspberry Pi&#8217;s camera module. The package is only intended to
run on a Raspberry Pi, and expects to be able to load the MMAL library
(libmmal.so) upon import.</p>
<p>The classes defined by most modules in this package are available directly from
the <a class="reference internal" href="#module-picamera" title="picamera"><code class="xref py py-mod docutils literal"><span class="pre">picamera</span></code></a> namespace. In other words, the following code is typically
all that is required to access classes in the package:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="index.html#module-picamera.array" title="picamera.array"><code class="xref py py-mod docutils literal"><span class="pre">picamera.array</span></code></a> module is an exception to this as it depends on the
third-party <a class="reference external" href="http://www.numpy.org/">numpy</a> package (this avoids making numpy a mandatory dependency
for picamera).</p>
<p>The following sections document the various modules available within the
package:</p>
<ul class="simple">
<li><a class="reference internal" href="index.html#module-picamera.camera" title="picamera.camera"><code class="xref py py-mod docutils literal"><span class="pre">picamera.camera</span></code></a></li>
<li><a class="reference internal" href="index.html#module-picamera.encoders" title="picamera.encoders"><code class="xref py py-mod docutils literal"><span class="pre">picamera.encoders</span></code></a></li>
<li><a class="reference internal" href="index.html#module-picamera.streams" title="picamera.streams"><code class="xref py py-mod docutils literal"><span class="pre">picamera.streams</span></code></a></li>
<li><a class="reference internal" href="index.html#module-picamera.renderers" title="picamera.renderers"><code class="xref py py-mod docutils literal"><span class="pre">picamera.renderers</span></code></a></li>
<li><a class="reference internal" href="index.html#module-picamera.color" title="picamera.color"><code class="xref py py-mod docutils literal"><span class="pre">picamera.color</span></code></a></li>
<li><a class="reference internal" href="index.html#module-picamera.exc" title="picamera.exc"><code class="xref py py-mod docutils literal"><span class="pre">picamera.exc</span></code></a></li>
<li><a class="reference internal" href="index.html#module-picamera.array" title="picamera.array"><code class="xref py py-mod docutils literal"><span class="pre">picamera.array</span></code></a></li>
</ul>
</div>
<span id="document-api_camera"></span><div class="section" id="module-picamera.camera">
<span id="api-picamera-camera-module"></span><span id="api-camera"></span><h3>API - <code class="docutils literal"><span class="pre">picamera.camera</span></code> Module<a class="headerlink" href="#module-picamera.camera" title="Permalink to this headline">¶</a></h3>
<p>The camera module defines the <code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code> class, which is the
primary interface to the Raspberry Pi&#8217;s camera module.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All classes in this module are available from the <a class="reference internal" href="index.html#module-picamera" title="picamera"><code class="xref py py-mod docutils literal"><span class="pre">picamera</span></code></a> namespace
without having to import <a class="reference internal" href="#module-picamera.camera" title="picamera.camera"><code class="xref py py-mod docutils literal"><span class="pre">picamera.camera</span></code></a> directly.</p>
</div>
<p>The following classes are defined in the module:</p>
<div class="section" id="picamera">
<h4>PiCamera<a class="headerlink" href="#picamera" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>In the documentation below several apparently &#8220;private&#8221; methods are
documented (i.e. methods which have names beginning with an underscore).
Most users can ignore these methods; they are intended for those developers
that wish to override or extend the encoder implementations used by
picamera.</p>
<p class="last">Some may question, given that these methods are intended to be overridden,
why they are declared with a leading underscore (which in the Python idiom
suggests that these methods are &#8220;private&#8221; to the class). In the cases where
such methods are documented, the author intends these methods to have
&#8220;protected&#8221; status (in the idiom of C++ and Object Pascal). That is to say,
they are not intended to be used outside of the declaring class, but are
intended to be accessible to, and overridden by, descendent classes.</p>
</div>
<dl class="class">
<dt id="picamera.camera.PiCamera">
<em class="property">class </em><code class="descclassname">picamera.camera.</code><code class="descname">PiCamera</code><span class="sig-paren">(</span><em>camera_num=0</em>, <em>stereo_mode='none'</em>, <em>stereo_decimate=False</em>, <em>resolution=None</em>, <em>framerate=None</em>, <em>sensor_mode=0</em>, <em>led_pin=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a pure Python interface to the Raspberry Pi&#8217;s camera module.</p>
<p>Upon construction, this class initializes the camera. The <em>camera_num</em>
parameter (which defaults to 0) selects the camera module that the instance
will represent. Only the Raspberry Pi compute module currently supports
more than one camera, and this class has not yet been tested with more than
one module.</p>
<p>The <em>resolution</em> and <em>framerate</em> parameters can be used to specify an
initial <a class="reference internal" href="#picamera.camera.PiCamera.resolution" title="picamera.camera.PiCamera.resolution"><code class="xref py py-attr docutils literal"><span class="pre">resolution</span></code></a> and <a class="reference internal" href="#picamera.camera.PiCamera.framerate" title="picamera.camera.PiCamera.framerate"><code class="xref py py-attr docutils literal"><span class="pre">framerate</span></code></a>. If they are not
specified, the <em>framerate</em> will default to 30fps, and the <em>resolution</em> will
default to the connected display&#8217;s resolution or 1280x720 if no display can
be detected (e.g. if the display has been disabled with <code class="docutils literal"><span class="pre">tvservice</span> <span class="pre">-o</span></code>).
If specified, resolution must be a tuple of <cite>(width, height)</cite>, and
framerate must be a rational value (integer, float, fraction, etc).</p>
<p>The <em>sensor_mode</em> parameter can be used to force the camera&#8217;s initial
<a class="reference internal" href="#picamera.camera.PiCamera.sensor_mode" title="picamera.camera.PiCamera.sensor_mode"><code class="xref py py-attr docutils literal"><span class="pre">sensor_mode</span></code></a> to a particular value. This defaults to 0 indicating
that the sensor mode should be selected automatically based on the
requested <em>resolution</em> and <em>framerate</em>. The possible values for this
parameter, along with a description of the heuristic used with the default
can be found in the <a class="reference internal" href="index.html#camera-modes"><span>Camera Modes</span></a> section.</p>
<p>The <em>stereo_mode</em> and <em>stereo_decimate</em> parameters configure dual cameras
on a compute module for sterescopic mode. These parameters can only be set
at construction time; they cannot be altered later without closing the
<a class="reference internal" href="#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a> instance and recreating it. The <em>stereo_mode</em> parameter
defaults to <code class="docutils literal"><span class="pre">'none'</span></code> (no stereoscopic mode) but can be set to
<code class="docutils literal"><span class="pre">'side-by-side'</span></code> or <code class="docutils literal"><span class="pre">'top-bottom'</span></code> to activate a stereoscopic mode. If
the <em>stereo_decimate</em> parameter is <code class="docutils literal"><span class="pre">True</span></code>, the resolution of the two
cameras will be halved so that the resulting image has the same dimensions
as if stereoscopic mode were not being used.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Stereoscopic mode is untested in picamera at this time. If you have the
necessary hardware, the author would be most interested to hear of your
experiences!</p>
</div>
<p>The <em>led_pin</em> parameter can be used to specify the GPIO pin which should be
used to control the camera&#8217;s LED via the <a class="reference internal" href="#picamera.camera.PiCamera.led" title="picamera.camera.PiCamera.led"><code class="xref py py-attr docutils literal"><span class="pre">led</span></code></a> attribute. If this is
not specified, it should default to the correct value for your Pi platform.
You should only need to specify this parameter if you are using a custom
DeviceTree blob (this is only typical on the <a class="reference external" href="http://www.raspberrypi.org/documentation/hardware/computemodule/cmio-camera.md">Compute Module</a> platform).</p>
<p>No preview or recording is started automatically upon construction.  Use
the <a class="reference internal" href="#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a> method to capture images, the <a class="reference internal" href="#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a>
method to begin recording video, or the <a class="reference internal" href="#picamera.camera.PiCamera.start_preview" title="picamera.camera.PiCamera.start_preview"><code class="xref py py-meth docutils literal"><span class="pre">start_preview()</span></code></a> method to
start live display of the camera&#8217;s input.</p>
<p>Several attributes are provided to adjust the camera&#8217;s configuration. Some
of these can be adjusted while a recording is running, like
<a class="reference internal" href="#picamera.camera.PiCamera.brightness" title="picamera.camera.PiCamera.brightness"><code class="xref py py-attr docutils literal"><span class="pre">brightness</span></code></a>. Others, like <a class="reference internal" href="#picamera.camera.PiCamera.resolution" title="picamera.camera.PiCamera.resolution"><code class="xref py py-attr docutils literal"><span class="pre">resolution</span></code></a>, can only be adjusted
when the camera is idle.</p>
<p>When you are finished with the camera, you should ensure you call the
<a class="reference internal" href="#picamera.camera.PiCamera.close" title="picamera.camera.PiCamera.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> method to release the camera resources:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">camera</span> <span class="o">=</span> <span class="n">PiCamera</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="c"># do something with the camera</span>
    <span class="k">pass</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>The class supports the context manager protocol to make this particularly
easy (upon exiting the <code class="docutils literal"><span class="pre">with</span></code> statement, the <a class="reference internal" href="#picamera.camera.PiCamera.close" title="picamera.camera.PiCamera.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> method is
automatically called):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="c"># do something with the camera</span>
    <span class="k">pass</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.8: </span>Added <em>stereo_mode</em> and <em>stereo_decimate</em> parameters</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.9: </span>Added <em>resolution</em>, <em>framerate</em>, and <em>sensor_mode</em> parameters</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.10: </span>Added <em>led_pin</em> parameter</p>
</div>
<dl class="method">
<dt id="picamera.camera.PiCamera._check_camera_open">
<code class="descname">_check_camera_open</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera._check_camera_open"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera._check_camera_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise an exception if the camera is already closed</p>
</dd></dl>

<dl class="method">
<dt id="picamera.camera.PiCamera._check_recording_stopped">
<code class="descname">_check_recording_stopped</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera._check_recording_stopped"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera._check_recording_stopped" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise an exception if the camera is currently recording</p>
</dd></dl>

<dl class="method">
<dt id="picamera.camera.PiCamera._get_annotate_settings">
<code class="descname">_get_annotate_settings</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera._get_annotate_settings"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera._get_annotate_settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current annotation settings as an MMAL structure.</p>
<p>This is a utility method for <code class="xref py py-meth docutils literal"><span class="pre">_get_annotate_text()</span></code>,
<code class="xref py py-meth docutils literal"><span class="pre">_get_annotate_background()</span></code>, etc. all of which rely on the
MMAL_PARAMETER_CAMERA_ANNOTATE_Vn structure to determine their values.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.camera.PiCamera._get_camera_settings">
<code class="descname">_get_camera_settings</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera._get_camera_settings"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera._get_camera_settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current camera settings as an MMAL structure.</p>
<p>This is a utility method for <code class="xref py py-meth docutils literal"><span class="pre">_get_exposure_speed()</span></code>,
<code class="xref py py-meth docutils literal"><span class="pre">_get_analog_gain()</span></code>, etc. all of which rely on the
MMAL_PARAMETER_CAMERA_SETTINGS structure to determine their values.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.camera.PiCamera._get_image_encoder">
<code class="descname">_get_image_encoder</code><span class="sig-paren">(</span><em>camera_port</em>, <em>output_port</em>, <em>format</em>, <em>resize</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera._get_image_encoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera._get_image_encoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct an image encoder for the requested parameters.</p>
<p>This method is called by <a class="reference internal" href="#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a> and <a class="reference internal" href="#picamera.camera.PiCamera.capture_continuous" title="picamera.camera.PiCamera.capture_continuous"><code class="xref py py-meth docutils literal"><span class="pre">capture_continuous()</span></code></a>
to construct an image encoder. The <em>camera_port</em> parameter gives the
MMAL camera port that should be enabled for capture by the encoder. The
<em>output_port</em> parameter gives the MMAL port that the encoder should
read output from (this may be the same as the camera port, but may be
different if other component(s) like a splitter have been placed in the
pipeline). The <em>format</em> parameter indicates the image format and will
be one of:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'jpeg'</span></code></li>
<li><code class="docutils literal"><span class="pre">'png'</span></code></li>
<li><code class="docutils literal"><span class="pre">'gif'</span></code></li>
<li><code class="docutils literal"><span class="pre">'bmp'</span></code></li>
<li><code class="docutils literal"><span class="pre">'yuv'</span></code></li>
<li><code class="docutils literal"><span class="pre">'rgb'</span></code></li>
<li><code class="docutils literal"><span class="pre">'rgba'</span></code></li>
<li><code class="docutils literal"><span class="pre">'bgr'</span></code></li>
<li><code class="docutils literal"><span class="pre">'bgra'</span></code></li>
</ul>
<p>The <em>resize</em> parameter indicates the size that the encoder should
resize the output to (presumably by including a resizer in the
pipeline). Finally, <em>options</em> includes extra keyword arguments that
should be passed verbatim to the encoder.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.camera.PiCamera._get_image_format">
<code class="descname">_get_image_format</code><span class="sig-paren">(</span><em>output</em>, <em>format=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera._get_image_format"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera._get_image_format" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an output object and an optional format, attempt to determine the
requested image format.</p>
<p>This method is used by all capture methods to determine the requested
output format. If <em>format</em> is specified as a MIME-type the &#8220;image/&#8221;
prefix is stripped. If <em>format</em> is not specified, then
<a class="reference internal" href="#picamera.camera.PiCamera._get_output_format" title="picamera.camera.PiCamera._get_output_format"><code class="xref py py-meth docutils literal"><span class="pre">_get_output_format()</span></code></a> will be called to attempt to determine
format from the <em>output</em> object.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.camera.PiCamera._get_images_encoder">
<code class="descname">_get_images_encoder</code><span class="sig-paren">(</span><em>camera_port</em>, <em>output_port</em>, <em>format</em>, <em>resize</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera._get_images_encoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera._get_images_encoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a multi-image encoder for the requested parameters.</p>
<p>This method is largely equivalent to <a class="reference internal" href="#picamera.camera.PiCamera._get_image_encoder" title="picamera.camera.PiCamera._get_image_encoder"><code class="xref py py-meth docutils literal"><span class="pre">_get_image_encoder()</span></code></a> with
the exception that the encoder returned should expect to be passed an
iterable of outputs to its <a class="reference internal" href="index.html#picamera.encoders.PiEncoder.start" title="picamera.encoders.PiEncoder.start"><code class="xref py py-meth docutils literal"><span class="pre">start()</span></code></a>
method, rather than a single output object. This method is called by
the <a class="reference internal" href="#picamera.camera.PiCamera.capture_sequence" title="picamera.camera.PiCamera.capture_sequence"><code class="xref py py-meth docutils literal"><span class="pre">capture_sequence()</span></code></a> method.</p>
<p>All parameters are the same as in <a class="reference internal" href="#picamera.camera.PiCamera._get_image_encoder" title="picamera.camera.PiCamera._get_image_encoder"><code class="xref py py-meth docutils literal"><span class="pre">_get_image_encoder()</span></code></a>. Please
refer to the documentation for that method for further information.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.camera.PiCamera._get_output_format">
<code class="descname">_get_output_format</code><span class="sig-paren">(</span><em>output</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera._get_output_format"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera._get_output_format" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an output object, attempt to determine the requested format.</p>
<p>We attempt to determine the filename of the <em>output</em> object and derive
a MIME type from the extension. If <em>output</em> has no filename, an error
is raised.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.camera.PiCamera._get_ports">
<code class="descname">_get_ports</code><span class="sig-paren">(</span><em>from_video_port</em>, <em>splitter_port</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera._get_ports"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera._get_ports" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the camera and output ports for given capture options.</p>
<p>See <a class="reference internal" href="index.html#camera-hardware"><span>Camera Hardware</span></a> for more information on picamera&#8217;s usage of
camera, splitter, and encoder ports. The general idea here is that the
capture (still) port operates on its own, while the video port is
always connected to a splitter component, so requests for a video port
also have to specify which splitter port they want to use.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.camera.PiCamera._get_video_encoder">
<code class="descname">_get_video_encoder</code><span class="sig-paren">(</span><em>camera_port</em>, <em>output_port</em>, <em>format</em>, <em>resize</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera._get_video_encoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera._get_video_encoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a video encoder for the requested parameters.</p>
<p>This method is called by <a class="reference internal" href="#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> and
<a class="reference internal" href="#picamera.camera.PiCamera.record_sequence" title="picamera.camera.PiCamera.record_sequence"><code class="xref py py-meth docutils literal"><span class="pre">record_sequence()</span></code></a> to construct a video encoder.  The
<em>camera_port</em> parameter gives the MMAL camera port that should be
enabled for capture by the encoder. The <em>output_port</em> parameter gives
the MMAL port that the encoder should read output from (this may be the
same as the camera port, but may be different if other component(s)
like a splitter have been placed in the pipeline). The <em>format</em>
parameter indicates the video format and will be one of:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'h264'</span></code></li>
<li><code class="docutils literal"><span class="pre">'mjpeg'</span></code></li>
</ul>
<p>The <em>resize</em> parameter indicates the size that the encoder should
resize the output to (presumably by including a resizer in the
pipeline). Finally, <em>options</em> includes extra keyword arguments that
should be passed verbatim to the encoder.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.camera.PiCamera._get_video_format">
<code class="descname">_get_video_format</code><span class="sig-paren">(</span><em>output</em>, <em>format=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera._get_video_format"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera._get_video_format" title="Permalink to this definition">¶</a></dt>
<dd><p>Given an output object and an optional format, attempt to determine the
requested video format.</p>
<p>This method is used by all recording methods to determine the requested
output format. If <em>format</em> is specified as a MIME-type the &#8220;video/&#8221; or
&#8220;application/&#8221; prefix will be stripped. If <em>format</em> is not specified,
then <a class="reference internal" href="#picamera.camera.PiCamera._get_output_format" title="picamera.camera.PiCamera._get_output_format"><code class="xref py py-meth docutils literal"><span class="pre">_get_output_format()</span></code></a> will be called to attempt to determine
format from the <em>output</em> object.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.camera.PiCamera._set_camera_mode">
<code class="descname">_set_camera_mode</code><span class="sig-paren">(</span><em>old_mode</em>, <em>new_mode</em>, <em>framerate</em>, <em>resolution</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera._set_camera_mode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera._set_camera_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>A utility method for setting a new camera mode, framerate, and
resolution.</p>
<p>This method is used by the setters of the <a class="reference internal" href="#picamera.camera.PiCamera.resolution" title="picamera.camera.PiCamera.resolution"><code class="xref py py-attr docutils literal"><span class="pre">resolution</span></code></a>,
<a class="reference internal" href="#picamera.camera.PiCamera.framerate" title="picamera.camera.PiCamera.framerate"><code class="xref py py-attr docutils literal"><span class="pre">framerate</span></code></a>, and <a class="reference internal" href="#picamera.camera.PiCamera.sensor_mode" title="picamera.camera.PiCamera.sensor_mode"><code class="xref py py-attr docutils literal"><span class="pre">sensor_mode</span></code></a> properties. It assumes that
the camera has already been disabled and will be enabled after being
called. The <em>old_mode</em> and <em>new_mode</em> arguments are required to ensure
correct operation on older firmwares (specifically that we don&#8217;t try to
set the sensor mode when both old and new modes are 0 or automatic).</p>
</dd></dl>

<dl class="method">
<dt id="picamera.camera.PiCamera.add_overlay">
<code class="descname">add_overlay</code><span class="sig-paren">(</span><em>source</em>, <em>size=None</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera.add_overlay"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera.add_overlay" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a static overlay to the preview output.</p>
<p>This method creates a new static overlay using the same rendering
mechanism as the preview. Overlays will appear on the Pi&#8217;s video
output, but will not appear in captures or video recordings. Multiple
overlays can exist; each call to <a class="reference internal" href="#picamera.camera.PiCamera.add_overlay" title="picamera.camera.PiCamera.add_overlay"><code class="xref py py-meth docutils literal"><span class="pre">add_overlay()</span></code></a> returns a new
<a class="reference internal" href="index.html#picamera.renderers.PiOverlayRenderer" title="picamera.renderers.PiOverlayRenderer"><code class="xref py py-class docutils literal"><span class="pre">PiOverlayRenderer</span></code></a> instance representing
the overlay.</p>
<p>The optional <em>size</em> parameter specifies the size of the source image as
a <code class="docutils literal"><span class="pre">(width,</span> <span class="pre">height)</span></code> tuple. If this is omitted or <code class="docutils literal"><span class="pre">None</span></code> then the
size is assumed to be the same as the camera&#8217;s current
<a class="reference internal" href="#picamera.camera.PiCamera.resolution" title="picamera.camera.PiCamera.resolution"><code class="xref py py-attr docutils literal"><span class="pre">resolution</span></code></a>.</p>
<p>The <em>source</em> must be an object that supports the <a class="reference external" href="http://docs.python.org/3.2/c-api/buffer.html#bufferobjects" title="(in Python v3.2)"><span class="xref std std-ref">buffer protocol</span></a> which has the same length as an image in <a class="reference external" href="http://en.wikipedia.org/wiki/RGB">RGB</a> format
(colors represented as interleaved unsigned bytes) with the specified
<em>size</em> after the width has been rounded up to the nearest multiple of
32, and the height has been rounded up to the nearest multiple of 16.</p>
<p>For example, if <em>size</em> is <code class="docutils literal"><span class="pre">(1280,</span> <span class="pre">720)</span></code>, then <em>source</em> must be a
buffer with length 1280 × 720 × 3 bytes, or 2,764,800 bytes (because
1280 is a multiple of 32, and 720 is a multiple of 16 no extra rounding
is required).  However, if <em>size</em> is <code class="docutils literal"><span class="pre">(97,</span> <span class="pre">57)</span></code>, then <em>source</em> must
be a buffer with length 128 × 64 × 3 bytes, or 24,576 bytes (pixels
beyond column 97 and row 57 in the source will be ignored).</p>
<p>New overlays default to <em>layer</em> 0, whilst the preview defaults to layer
2. Higher numbered layers obscure lower numbered layers, hence new
overlays will be invisible (if the preview is running) by default. You
can make the new overlay visible either by making any existing preview
transparent (with the <a class="reference internal" href="index.html#picamera.renderers.PiRenderer.alpha" title="picamera.renderers.PiRenderer.alpha"><code class="xref py py-attr docutils literal"><span class="pre">alpha</span></code></a>
property) or by moving the overlay into a layer higher than the preview
(with the <a class="reference internal" href="index.html#picamera.renderers.PiRenderer.layer" title="picamera.renderers.PiRenderer.layer"><code class="xref py py-attr docutils literal"><span class="pre">layer</span></code></a> property).</p>
<p>All keyword arguments captured in <em>options</em> are passed onto the
<a class="reference internal" href="index.html#picamera.renderers.PiRenderer" title="picamera.renderers.PiRenderer"><code class="xref py py-class docutils literal"><span class="pre">PiRenderer</span></code></a> constructor. All camera
properties except <a class="reference internal" href="#picamera.camera.PiCamera.resolution" title="picamera.camera.PiCamera.resolution"><code class="xref py py-attr docutils literal"><span class="pre">resolution</span></code></a> and <a class="reference internal" href="#picamera.camera.PiCamera.framerate" title="picamera.camera.PiCamera.framerate"><code class="xref py py-attr docutils literal"><span class="pre">framerate</span></code></a> can be
modified while overlays exist. The reason for these exceptions is that
the overlay has a static resolution and changing the camera&#8217;s mode
would require resizing of the source.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>If too many overlays are added, the display output will be disabled
and a reboot will generally be required to restore the display.
Overlays are composited &#8220;on the fly&#8221;. Hence, a real-time constraint
exists wherein for each horizontal line of HDMI output, the content
of all source layers must be fetched, resized, converted, and
blended to produce the output pixels.</p>
<p class="last">If enough overlays exist (where &#8220;enough&#8221; is a number dependent on
overlay size, display resolution, bus frequency, and several other
factors making it unrealistic to calculate in advance), this
process breaks down and video output fails. One solution is to add
<code class="docutils literal"><span class="pre">dispmanx_offline=1</span></code> to <code class="docutils literal"><span class="pre">/boot/config.txt</span></code> to force the use of
an off-screen buffer. Be aware that this requires more GPU memory
and may reduce the update rate.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="picamera.camera.PiCamera.capture">
<code class="descname">capture</code><span class="sig-paren">(</span><em>output</em>, <em>format=None</em>, <em>use_video_port=False</em>, <em>resize=None</em>, <em>splitter_port=0</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera.capture"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera.capture" title="Permalink to this definition">¶</a></dt>
<dd><p>Capture an image from the camera, storing it in <em>output</em>.</p>
<p>If <em>output</em> is a string, it will be treated as a filename for a new
file which the image will be written to. Otherwise, <em>output</em> is assumed
to a be a file-like object and the image data is appended to it (the
implementation only assumes the object has a <code class="docutils literal"><span class="pre">write()</span></code> method - no
other methods will be called).</p>
<p>If <em>format</em> is <code class="docutils literal"><span class="pre">None</span></code> (the default), the method will attempt to guess
the required image format from the extension of <em>output</em> (if it&#8217;s a
string), or from the <em>name</em> attribute of <em>output</em> (if it has one). In
the case that the format cannot be determined, a
<a class="reference internal" href="index.html#picamera.exc.PiCameraValueError" title="picamera.exc.PiCameraValueError"><code class="xref py py-exc docutils literal"><span class="pre">PiCameraValueError</span></code></a> will be raised.</p>
<p>If <em>format</em> is not <code class="docutils literal"><span class="pre">None</span></code>, it must be a string specifying the format
that you want the image output in. The format can be a MIME-type or
one of the following strings:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'jpeg'</span></code> - Write a JPEG file</li>
<li><code class="docutils literal"><span class="pre">'png'</span></code> - Write a PNG file</li>
<li><code class="docutils literal"><span class="pre">'gif'</span></code> - Write a GIF file</li>
<li><code class="docutils literal"><span class="pre">'bmp'</span></code> - Write a Windows bitmap file</li>
<li><code class="docutils literal"><span class="pre">'yuv'</span></code> - Write the raw image data to a file in YUV420 format</li>
<li><code class="docutils literal"><span class="pre">'rgb'</span></code> - Write the raw image data to a file in 24-bit RGB format</li>
<li><code class="docutils literal"><span class="pre">'rgba'</span></code> - Write the raw image data to a file in 32-bit RGBA format</li>
<li><code class="docutils literal"><span class="pre">'bgr'</span></code> - Write the raw image data to a file in 24-bit BGR format</li>
<li><code class="docutils literal"><span class="pre">'bgra'</span></code> - Write the raw image data to a file in 32-bit BGRA format</li>
<li><code class="docutils literal"><span class="pre">'raw'</span></code> - Deprecated option for raw captures; the format is taken
from the deprecated <a class="reference internal" href="#picamera.camera.PiCamera.raw_format" title="picamera.camera.PiCamera.raw_format"><code class="xref py py-attr docutils literal"><span class="pre">raw_format</span></code></a> attribute</li>
</ul>
<p>The <em>use_video_port</em> parameter controls whether the camera&#8217;s image or
video port is used to capture images. It defaults to <code class="docutils literal"><span class="pre">False</span></code> which
means that the camera&#8217;s image port is used. This port is slow but
produces better quality pictures. If you need rapid capture up to the
rate of video frames, set this to <code class="docutils literal"><span class="pre">True</span></code>.</p>
<p>When <em>use_video_port</em> is <code class="docutils literal"><span class="pre">True</span></code>, the <em>splitter_port</em> parameter
specifies the port of the video splitter that the image encoder will be
attached to. This defaults to <code class="docutils literal"><span class="pre">0</span></code> and most users will have no need to
specify anything different. This parameter is ignored when
<em>use_video_port</em> is <code class="docutils literal"><span class="pre">False</span></code>. See <a class="reference internal" href="index.html#under-the-hood"><span>Under the Hood</span></a> for more
information about the video splitter.</p>
<p>If <em>resize</em> is not <code class="docutils literal"><span class="pre">None</span></code> (the default), it must be a two-element
tuple specifying the width and height that the image should be resized
to.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If <em>resize</em> is specified, or <em>use_video_port</em> is <code class="docutils literal"><span class="pre">True</span></code>, Exif
metadata will <strong>not</strong> be included in JPEG output. This is due to an
underlying firmware limitation.</p>
</div>
<p>Certain file formats accept additional options which can be specified
as keyword arguments. Currently, only the <code class="docutils literal"><span class="pre">'jpeg'</span></code> encoder accepts
additional options, which are:</p>
<ul class="simple">
<li><em>quality</em> - Defines the quality of the JPEG encoder as an integer
ranging from 1 to 100. Defaults to 85. Please note that JPEG quality
is not a percentage and <a class="reference external" href="http://photo.net/learn/jpeg/#qual">definitions of quality</a> vary widely.</li>
<li><em>thumbnail</em> - Defines the size and quality of the thumbnail to embed
in the Exif metadata. Specifying <code class="docutils literal"><span class="pre">None</span></code> disables thumbnail
generation.  Otherwise, specify a tuple of <code class="docutils literal"><span class="pre">(width,</span> <span class="pre">height,</span>
<span class="pre">quality)</span></code>. Defaults to <code class="docutils literal"><span class="pre">(64,</span> <span class="pre">48,</span> <span class="pre">35)</span></code>.</li>
<li><em>bayer</em> - If <code class="docutils literal"><span class="pre">True</span></code>, the raw bayer data from the camera&#8217;s sensor
is included in the Exif metadata.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The so-called &#8220;raw&#8221; formats listed above (<code class="docutils literal"><span class="pre">'yuv'</span></code>, <code class="docutils literal"><span class="pre">'rgb'</span></code>,
etc.) do not represent the raw bayer data from the camera&#8217;s sensor.
Rather they provide access to the image data after GPU processing,
but before format encoding (JPEG, PNG, etc). Currently, the only
method of accessing the raw bayer data is via the <em>bayer</em> parameter
described above.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.0: </span>The <em>resize</em> parameter was added, and raw capture formats can now
be specified directly</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.3: </span>The <em>splitter_port</em> parameter was added, and <em>bayer</em> was added as
an option for the <code class="docutils literal"><span class="pre">'jpeg'</span></code> format</p>
</div>
</dd></dl>

<dl class="method">
<dt id="picamera.camera.PiCamera.capture_continuous">
<code class="descname">capture_continuous</code><span class="sig-paren">(</span><em>output</em>, <em>format=None</em>, <em>use_video_port=False</em>, <em>resize=None</em>, <em>splitter_port=0</em>, <em>burst=False</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera.capture_continuous"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera.capture_continuous" title="Permalink to this definition">¶</a></dt>
<dd><p>Capture images continuously from the camera as an infinite iterator.</p>
<p>This method returns an infinite iterator of images captured
continuously from the camera. If <em>output</em> is a string, each captured
image is stored in a file named after <em>output</em> after substitution of
two values with the <a class="reference external" href="http://docs.python.org/3.2/library/stdtypes.html#str.format" title="(in Python v3.2)"><code class="xref py py-meth docutils literal"><span class="pre">format()</span></code></a> method. Those two values are:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">{counter}</span></code> - a simple incrementor that starts at 1 and increases
by 1 for each image taken</li>
<li><code class="docutils literal"><span class="pre">{timestamp}</span></code> - a <a class="reference external" href="http://docs.python.org/3.2/library/datetime.html#datetime.datetime" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">datetime</span></code></a> instance</li>
</ul>
<p>The table below contains several example values of <em>output</em> and the
sequence of filenames those values could produce:</p>
<table border="1" class="docutils">
<colgroup>
<col width="46%" />
<col width="46%" />
<col width="7%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><em>output</em> Value</th>
<th class="head">Filenames</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'image{counter}.jpg'</span></code></td>
<td>image1.jpg, image2.jpg, image3.jpg, ...</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'image{counter:02d}.jpg'</span></code></td>
<td>image01.jpg, image02.jpg, image03.jpg, ...</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'image{timestamp}.jpg'</span></code></td>
<td>image2013-10-05 12:07:12.346743.jpg,
image2013-10-05 12:07:32.498539, ...</td>
<td><ol class="first last arabic simple">
<li></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'image{timestamp:%H-%M-%S-%f}.jpg'</span></code></td>
<td>image12-10-02-561527.jpg,
image12-10-14-905398.jpg</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'{timestamp:%H%M%S}-{counter:03d}.jpg'</span></code></td>
<td>121002-001.jpg, 121013-002.jpg,
121014-003.jpg, ...</td>
<td><ol class="first last arabic simple" start="2">
<li></li>
</ol>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple">
<li>Note that because timestamp&#8217;s default output includes colons (:),
the resulting filenames are not suitable for use on Windows. For
this reason (and the fact the default contains spaces) it is
strongly recommended you always specify a format when using
<code class="docutils literal"><span class="pre">{timestamp}</span></code>.</li>
<li>You can use both <code class="docutils literal"><span class="pre">{timestamp}</span></code> and <code class="docutils literal"><span class="pre">{counter}</span></code> in a single
format string (multiple times too!) although this tends to be
redundant.</li>
</ol>
<p>If <em>output</em> is not a string, it is assumed to be a file-like object
and each image is simply written to this object sequentially. In this
case you will likely either want to write something to the object
between the images to distinguish them, or clear the object between
iterations.</p>
<p>The <em>format</em>, <em>use_video_port</em>, <em>splitter_port</em>, <em>resize</em>, and
<em>options</em> parameters are the same as in <a class="reference internal" href="#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a>.</p>
<p>If <em>use_video_port</em> is <code class="docutils literal"><span class="pre">False</span></code> (the default), the <em>burst</em> parameter
can be used to make still port captures faster.  Specifically, this
prevents the preview from switching resolutions between captures which
significantly speeds up consecutive captures from the still port. The
downside is that this mode is currently has several bugs; the major
issue is that if captures are performed too quickly some frames will
come back severely underexposed. It is recommended that users avoid the
<em>burst</em> parameter unless they absolutely require it and are prepared to
work around such issues.</p>
<p>For example, to capture 60 images with a one second delay between them,
writing the output to a series of JPEG files named image01.jpg,
image02.jpg, etc. one could do the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>
<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">filename</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">camera</span><span class="o">.</span><span class="n">capture_continuous</span><span class="p">(</span><span class="s">&#39;image{counter:02d}.jpg&#39;</span><span class="p">)):</span>
            <span class="k">print</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">59</span><span class="p">:</span>
                <span class="k">break</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">stop_preview</span><span class="p">()</span>
</pre></div>
</div>
<p>Alternatively, to capture JPEG frames as fast as possible into an
in-memory stream, performing some processing on each stream until
some condition is satisfied:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>
<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">stream</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">foo</span> <span class="ow">in</span> <span class="n">camera</span><span class="o">.</span><span class="n">capture_continuous</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;jpeg&#39;</span><span class="p">):</span>
        <span class="c"># Truncate the stream to the current position (in case</span>
        <span class="c"># prior iterations output a longer image)</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">process</span><span class="p">(</span><span class="n">stream</span><span class="p">):</span>
            <span class="k">break</span>
</pre></div>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.0: </span>The <em>resize</em> parameter was added, and raw capture formats can now
be specified directly</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.3: </span>The <em>splitter_port</em> parameter was added</p>
</div>
</dd></dl>

<dl class="method">
<dt id="picamera.camera.PiCamera.capture_sequence">
<code class="descname">capture_sequence</code><span class="sig-paren">(</span><em>outputs</em>, <em>format='jpeg'</em>, <em>use_video_port=False</em>, <em>resize=None</em>, <em>splitter_port=0</em>, <em>burst=False</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera.capture_sequence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera.capture_sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Capture a sequence of consecutive images from the camera.</p>
<p>This method accepts a sequence or iterator of <em>outputs</em> each of which
must either be a string specifying a filename for output, or a
file-like object with a <code class="docutils literal"><span class="pre">write</span></code> method. For each item in the sequence
or iterator of outputs, the camera captures a single image as fast as
it can.</p>
<p>The <em>format</em>, <em>use_video_port</em>, <em>splitter_port</em>, <em>resize</em>, and
<em>options</em> parameters are the same as in <a class="reference internal" href="#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a>, but <em>format</em>
defaults to <code class="docutils literal"><span class="pre">'jpeg'</span></code>.  The format is <strong>not</strong> derived from the
filenames in <em>outputs</em> by this method.</p>
<p>If <em>use_video_port</em> is <code class="docutils literal"><span class="pre">False</span></code> (the default), the <em>burst</em> parameter
can be used to make still port captures faster.  Specifically, this
prevents the preview from switching resolutions between captures which
significantly speeds up consecutive captures from the still port. The
downside is that this mode is currently has several bugs; the major
issue is that if captures are performed too quickly some frames will
come back severely underexposed. It is recommended that users avoid the
<em>burst</em> parameter unless they absolutely require it and are prepared to
work around such issues.</p>
<p>For example, to capture 3 consecutive images:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>
<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture_sequence</span><span class="p">([</span>
        <span class="s">&#39;image1.jpg&#39;</span><span class="p">,</span>
        <span class="s">&#39;image2.jpg&#39;</span><span class="p">,</span>
        <span class="s">&#39;image3.jpg&#39;</span><span class="p">,</span>
        <span class="p">])</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">stop_preview</span><span class="p">()</span>
</pre></div>
</div>
<p>If you wish to capture a large number of images, a list comprehension
or generator expression can be used to construct the list of filenames
to use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">picamera</span>
<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">capture_sequence</span><span class="p">([</span>
        <span class="s">&#39;image</span><span class="si">%02d</span><span class="s">.jpg&#39;</span> <span class="o">%</span> <span class="n">i</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
        <span class="p">])</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">stop_preview</span><span class="p">()</span>
</pre></div>
</div>
<p>More complex effects can be obtained by using a generator function to
provide the filenames or output objects.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.0: </span>The <em>resize</em> parameter was added, and raw capture formats can now
be specified directly</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.3: </span>The <em>splitter_port</em> parameter was added</p>
</div>
</dd></dl>

<dl class="method">
<dt id="picamera.camera.PiCamera.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Finalizes the state of the camera.</p>
<p>After successfully constructing a <a class="reference internal" href="#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a> object, you should
ensure you call the <a class="reference internal" href="#picamera.camera.PiCamera.close" title="picamera.camera.PiCamera.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> method once you are finished with the
camera (e.g. in the <code class="docutils literal"><span class="pre">finally</span></code> section of a <code class="docutils literal"><span class="pre">try..finally</span></code> block).
This method stops all recording and preview activities and releases all
resources associated with the camera; this is necessary to prevent GPU
memory leaks.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.camera.PiCamera.record_sequence">
<code class="descname">record_sequence</code><span class="sig-paren">(</span><em>outputs</em>, <em>format='h264'</em>, <em>resize=None</em>, <em>splitter_port=1</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera.record_sequence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera.record_sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Record a sequence of video clips from the camera.</p>
<p>This method accepts a sequence or iterator of <em>outputs</em> each of which
must either be a string specifying a filename for output, or a
file-like object with a <code class="docutils literal"><span class="pre">write</span></code> method.</p>
<p>The method acts as an iterator itself, yielding each item of the
sequence in turn. In this way, the caller can control how long to
record to each item by only permitting the loop to continue when ready
to switch to the next output.</p>
<p>The <em>format</em>, <em>splitter_port</em>, <em>resize</em>, and <em>options</em> parameters are
the same as in <a class="reference internal" href="#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a>, but <em>format</em> defaults to
<code class="docutils literal"><span class="pre">'h264'</span></code>.  The format is <strong>not</strong> derived from the filenames in
<em>outputs</em> by this method.</p>
<p>For example, to record 3 consecutive 10-second video clips, writing the
output to a series of H.264 files named clip01.h264, clip02.h264, and
clip03.h264 one could use the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>
<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">camera</span><span class="o">.</span><span class="n">record_sequence</span><span class="p">([</span>
            <span class="s">&#39;clip01.h264&#39;</span><span class="p">,</span>
            <span class="s">&#39;clip02.h264&#39;</span><span class="p">,</span>
            <span class="s">&#39;clip03.h264&#39;</span><span class="p">]):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Recording to </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, a more flexible method of writing the previous example
(which is easier to expand to a large number of output files) is by
using a generator expression as the input sequence:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>
<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">camera</span><span class="o">.</span><span class="n">record_sequence</span><span class="p">(</span>
            <span class="s">&#39;clip</span><span class="si">%02d</span><span class="s">.h264&#39;</span> <span class="o">%</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Recording to </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>More advanced techniques are also possible by utilising infinite
sequences, such as those generated by <a class="reference external" href="http://docs.python.org/3.2/library/itertools.html#itertools.cycle" title="(in Python v3.2)"><code class="xref py py-func docutils literal"><span class="pre">itertools.cycle()</span></code></a>. In the
following example, recording is switched between two in-memory streams.
Whilst one stream is recording, the other is being analysed. The script
only stops recording when a video recording meets some criteria defined
by the <code class="docutils literal"><span class="pre">process</span></code> function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">picamera</span>
<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">analyse</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">for</span> <span class="n">stream</span> <span class="ow">in</span> <span class="n">camera</span><span class="o">.</span><span class="n">record_sequence</span><span class="p">(</span>
            <span class="n">itertools</span><span class="o">.</span><span class="n">cycle</span><span class="p">((</span><span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(),</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()))):</span>
        <span class="k">if</span> <span class="n">analyse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">process</span><span class="p">(</span><span class="n">analyse</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="n">analyse</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">analyse</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">analyse</span> <span class="o">=</span> <span class="n">stream</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.3.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="picamera.camera.PiCamera.remove_overlay">
<code class="descname">remove_overlay</code><span class="sig-paren">(</span><em>overlay</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera.remove_overlay"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera.remove_overlay" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes a static overlay from the preview output.</p>
<p>This method removes an overlay which was previously created by
<a class="reference internal" href="#picamera.camera.PiCamera.add_overlay" title="picamera.camera.PiCamera.add_overlay"><code class="xref py py-meth docutils literal"><span class="pre">add_overlay()</span></code></a>. The <em>overlay</em> parameter specifies the
<a class="reference internal" href="index.html#picamera.renderers.PiRenderer" title="picamera.renderers.PiRenderer"><code class="xref py py-class docutils literal"><span class="pre">PiRenderer</span></code></a> instance that was returned by
<a class="reference internal" href="#picamera.camera.PiCamera.add_overlay" title="picamera.camera.PiCamera.add_overlay"><code class="xref py py-meth docutils literal"><span class="pre">add_overlay()</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="picamera.camera.PiCamera.split_recording">
<code class="descname">split_recording</code><span class="sig-paren">(</span><em>output</em>, <em>splitter_port=1</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera.split_recording"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera.split_recording" title="Permalink to this definition">¶</a></dt>
<dd><p>Continue the recording in the specified output; close existing output.</p>
<p>When called, the video encoder will wait for the next appropriate
split point (an inline SPS header), then will cease writing to the
current output (and close it, if it was specified as a filename), and
continue writing to the newly specified <em>output</em>.</p>
<p>If <em>output</em> is a string, it will be treated as a filename for a new
file which the video will be written to. Otherwise, <em>output</em> is assumed
to be a file-like object and the video data is appended to it (the
implementation only assumes the object has a <code class="docutils literal"><span class="pre">write()</span></code> method - no
other methods will be called).</p>
<p>The <em>motion_output</em> parameter can be used to redirect the output of the
motion vector data in the same fashion as <em>output</em>. If <em>motion_output</em>
is <code class="docutils literal"><span class="pre">None</span></code> (the default) then motion vector data will not be
redirected and will continue being written to the output specified by
the <em>motion_output</em> parameter given to <a class="reference internal" href="#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a>.
Alternatively, if you only wish to redirect motion vector data, you can
set <em>output</em> to <code class="docutils literal"><span class="pre">None</span></code> and given a new value for <em>motion_output</em>.</p>
<p>The <em>splitter_port</em> parameter specifies which port of the video
splitter the encoder you wish to change outputs is attached to. This
defaults to <code class="docutils literal"><span class="pre">1</span></code> and most users will have no need to specify anything
different. Valid values are between <code class="docutils literal"><span class="pre">0</span></code> and <code class="docutils literal"><span class="pre">3</span></code> inclusive.</p>
<p>Note that unlike <a class="reference internal" href="#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a>, you cannot specify format or
other options as these cannot be changed in the middle of recording.
Only the new <em>output</em> (and <em>motion_output</em>) can be specified.
Furthermore, the format of the recording is currently limited to H264,
and <em>inline_headers</em> must be <code class="docutils literal"><span class="pre">True</span></code> when <a class="reference internal" href="#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> is
called (this is the default).</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.3: </span>The <em>splitter_port</em> parameter was added</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.5: </span>The <em>motion_output</em> parameter was added</p>
</div>
</dd></dl>

<dl class="method">
<dt id="picamera.camera.PiCamera.start_preview">
<code class="descname">start_preview</code><span class="sig-paren">(</span><em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera.start_preview"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera.start_preview" title="Permalink to this definition">¶</a></dt>
<dd><p>Displays the preview overlay.</p>
<p>This method starts a camera preview as an overlay on the Pi&#8217;s primary
display (HDMI or composite). A <a class="reference internal" href="index.html#picamera.renderers.PiRenderer" title="picamera.renderers.PiRenderer"><code class="xref py py-class docutils literal"><span class="pre">PiRenderer</span></code></a>
instance (more specifically, a
<a class="reference internal" href="index.html#picamera.renderers.PiPreviewRenderer" title="picamera.renderers.PiPreviewRenderer"><code class="xref py py-class docutils literal"><span class="pre">PiPreviewRenderer</span></code></a>) is constructed with the
keyword arguments captured in <em>options</em>, and is returned from the
method (this instance is also accessible from the <a class="reference internal" href="#picamera.camera.PiCamera.preview" title="picamera.camera.PiCamera.preview"><code class="xref py py-attr docutils literal"><span class="pre">preview</span></code></a>
attribute for as long as the renderer remains active).  By default, the
renderer will be opaque and fullscreen.</p>
<p>This means the default preview overrides whatever is currently visible
on the display. More specifically, the preview does not rely on a
graphical environment like X-Windows (it can run quite happily from a
TTY console); it is simply an overlay on the Pi&#8217;s video output. To stop
the preview and reveal the display again, call <a class="reference internal" href="#picamera.camera.PiCamera.stop_preview" title="picamera.camera.PiCamera.stop_preview"><code class="xref py py-meth docutils literal"><span class="pre">stop_preview()</span></code></a>.
The preview can be started and stopped multiple times during the
lifetime of the <a class="reference internal" href="#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a> object.</p>
<p>All other camera properties can be modified &#8220;live&#8221; while the preview is
running (e.g. <a class="reference internal" href="#picamera.camera.PiCamera.brightness" title="picamera.camera.PiCamera.brightness"><code class="xref py py-attr docutils literal"><span class="pre">brightness</span></code></a>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Because the default preview typically obscures the screen, ensure
you have a means of stopping a preview before starting one. If the
preview obscures your interactive console you won&#8217;t be able to
Alt+Tab back to it as the preview isn&#8217;t in a window. If you are in
an interactive Python session, simply pressing Ctrl+D usually
suffices to terminate the environment, including the camera and its
associated preview.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="picamera.camera.PiCamera.start_recording">
<code class="descname">start_recording</code><span class="sig-paren">(</span><em>output</em>, <em>format=None</em>, <em>resize=None</em>, <em>splitter_port=1</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera.start_recording"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera.start_recording" title="Permalink to this definition">¶</a></dt>
<dd><p>Start recording video from the camera, storing it in <em>output</em>.</p>
<p>If <em>output</em> is a string, it will be treated as a filename for a new
file which the video will be written to. Otherwise, <em>output</em> is assumed
to be a file-like object and the video data is appended to it (the
implementation only assumes the object has a <code class="docutils literal"><span class="pre">write()</span></code> method - no
other methods will be called).</p>
<p>If <em>format</em> is <code class="docutils literal"><span class="pre">None</span></code> (the default), the method will attempt to guess
the required video format from the extension of <em>output</em> (if it&#8217;s a
string), or from the <em>name</em> attribute of <em>output</em> (if it has one). In
the case that the format cannot be determined, a
<a class="reference internal" href="index.html#picamera.exc.PiCameraValueError" title="picamera.exc.PiCameraValueError"><code class="xref py py-exc docutils literal"><span class="pre">PiCameraValueError</span></code></a> will be raised.</p>
<p>If <em>format</em> is not <code class="docutils literal"><span class="pre">None</span></code>, it must be a string specifying the format
that you want the video output in. The format can be a MIME-type or
one of the following strings:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'h264'</span></code> - Write an H.264 video stream</li>
<li><code class="docutils literal"><span class="pre">'mjpeg'</span></code> - Write an M-JPEG video stream</li>
<li><code class="docutils literal"><span class="pre">'yuv'</span></code> - Write the raw video data to a file in YUV420 format</li>
<li><code class="docutils literal"><span class="pre">'rgb'</span></code> - Write the raw video data to a file in 24-bit RGB format</li>
<li><code class="docutils literal"><span class="pre">'rgba'</span></code> - Write the raw video data to a file in 32-bit RGBA format</li>
<li><code class="docutils literal"><span class="pre">'bgr'</span></code> - Write the raw video data to a file in 24-bit BGR format</li>
<li><code class="docutils literal"><span class="pre">'bgra'</span></code> - Write the raw video data to a file in 32-bit BGRA format</li>
</ul>
<p>If <em>resize</em> is not <code class="docutils literal"><span class="pre">None</span></code> (the default), it must be a two-element
tuple specifying the width and height that the video recording should
be resized to. This is particularly useful for recording video using
the full resolution of the camera sensor (which is not possible in
H.264 without down-sizing the output).</p>
<p>The <em>splitter_port</em> parameter specifies the port of the built-in
splitter that the video encoder will be attached to. This defaults to
<code class="docutils literal"><span class="pre">1</span></code> and most users will have no need to specify anything different.
If you wish to record multiple (presumably resized) streams
simultaneously, specify a value between <code class="docutils literal"><span class="pre">0</span></code> and <code class="docutils literal"><span class="pre">3</span></code> inclusive for
this parameter, ensuring that you do not specify a port that is
currently in use.</p>
<p>Certain formats accept additional options which can be specified
as keyword arguments. The <code class="docutils literal"><span class="pre">'h264'</span></code> format accepts the following
additional options:</p>
<ul class="simple">
<li><em>profile</em> - The H.264 profile to use for encoding. Defaults to
&#8216;high&#8217;, but can be one of &#8216;baseline&#8217;, &#8216;main&#8217;, &#8216;high&#8217;, or
&#8216;constrained&#8217;.</li>
<li><em>intra_period</em> - The key frame rate (the rate at which I-frames are
inserted in the output). Defaults to <code class="docutils literal"><span class="pre">None</span></code>, but can be any 32-bit
integer value representing the number of frames between successive
I-frames. The special value 0 causes the encoder to produce a single
initial I-frame, and then only P-frames subsequently. Note that
<a class="reference internal" href="#picamera.camera.PiCamera.split_recording" title="picamera.camera.PiCamera.split_recording"><code class="xref py py-meth docutils literal"><span class="pre">split_recording()</span></code></a> will fail in this mode.</li>
<li><em>intra_refresh</em> - The key frame format (the way in which I-frames
will be inserted into the output stream). Defaults to <code class="docutils literal"><span class="pre">None</span></code>, but
can be one of &#8216;cyclic&#8217;, &#8216;adaptive&#8217;, &#8216;both&#8217;, or &#8216;cyclicrows&#8217;.</li>
<li><em>inline_headers</em> - When <code class="docutils literal"><span class="pre">True</span></code>, specifies that the encoder should
output SPS/PPS headers within the stream to ensure GOPs (groups of
pictures) are self describing. This is important for streaming
applications where the client may wish to seek within the stream, and
enables the use of <a class="reference internal" href="#picamera.camera.PiCamera.split_recording" title="picamera.camera.PiCamera.split_recording"><code class="xref py py-meth docutils literal"><span class="pre">split_recording()</span></code></a>. Defaults to <code class="docutils literal"><span class="pre">True</span></code> if
not specified.</li>
<li><em>sei</em> - When <code class="docutils literal"><span class="pre">True</span></code>, specifies the encoder should include
&#8220;Supplemental Enhancement Information&#8221; within the output stream.
Defaults to <code class="docutils literal"><span class="pre">False</span></code> if not specified.</li>
<li><em>motion_output</em> - Indicates the output destination for motion vector
estimation data. When <code class="docutils literal"><span class="pre">None</span></code> (the default), motion data is not
output. If set to a string, it is assumed to be a filename which
should be opened for motion data to be written to. Any other value is
assumed to be a file-like object which motion vector is to be written
to (the object must have a <code class="docutils literal"><span class="pre">write</span></code> method).</li>
</ul>
<p>All encoded formats accept the following additional options:</p>
<ul class="simple">
<li><em>bitrate</em> - The bitrate at which video will be encoded. Defaults to
17000000 (17Mbps) if not specified.  The maximum value is 25000000
(25Mbps). Bitrate 0 indicates the encoder should not use bitrate
control (the encoder is limited by the quality only).</li>
<li><em>quality</em> - Specifies the quality that the encoder should attempt
to maintain. For the <code class="docutils literal"><span class="pre">'h264'</span></code> format, use values between 10 and 40
where 10 is extremely high quality, and 40 is extremely low (20-25 is
usually a reasonable range for H.264 encoding). For the <code class="docutils literal"><span class="pre">mjpeg</span></code>
format, use JPEG quality values between 1 and 100 (where higher
values are higher quality). Quality 0 is special and seems to be
a &#8220;reasonable quality&#8221; default.</li>
<li><em>quantization</em> - Deprecated alias for <em>quality</em>.</li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.0: </span>The <em>resize</em> parameter was added, and <code class="docutils literal"><span class="pre">'mjpeg'</span></code> was added as a
recording format</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.3: </span>The <em>splitter_port</em> parameter was added</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.5: </span>The <em>quantization</em> parameter was deprecated in favor of <em>quality</em>,
and the <em>motion_output</em> parameter was added.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="picamera.camera.PiCamera.stop_preview">
<code class="descname">stop_preview</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera.stop_preview"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera.stop_preview" title="Permalink to this definition">¶</a></dt>
<dd><p>Hides the preview overlay.</p>
<p>If <a class="reference internal" href="#picamera.camera.PiCamera.start_preview" title="picamera.camera.PiCamera.start_preview"><code class="xref py py-meth docutils literal"><span class="pre">start_preview()</span></code></a> has previously been called, this method shuts
down the preview display which generally results in the underlying
display becoming visible again. If a preview is not currently running,
no exception is raised - the method will simply do nothing.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.camera.PiCamera.stop_recording">
<code class="descname">stop_recording</code><span class="sig-paren">(</span><em>splitter_port=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera.stop_recording"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera.stop_recording" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop recording video from the camera.</p>
<p>After calling this method the video encoder will be shut down and
output will stop being written to the file-like object specified with
<a class="reference internal" href="#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a>. If an error occurred during recording and
<a class="reference internal" href="#picamera.camera.PiCamera.wait_recording" title="picamera.camera.PiCamera.wait_recording"><code class="xref py py-meth docutils literal"><span class="pre">wait_recording()</span></code></a> has not been called since the error then this
method will raise the exception.</p>
<p>The <em>splitter_port</em> parameter specifies which port of the video
splitter the encoder you wish to stop is attached to. This defaults to
<code class="docutils literal"><span class="pre">1</span></code> and most users will have no need to specify anything different.
Valid values are between <code class="docutils literal"><span class="pre">0</span></code> and <code class="docutils literal"><span class="pre">3</span></code> inclusive.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.3: </span>The <em>splitter_port</em> parameter was added</p>
</div>
</dd></dl>

<dl class="method">
<dt id="picamera.camera.PiCamera.wait_recording">
<code class="descname">wait_recording</code><span class="sig-paren">(</span><em>timeout=0</em>, <em>splitter_port=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/camera.html#PiCamera.wait_recording"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.camera.PiCamera.wait_recording" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait on the video encoder for timeout seconds.</p>
<p>It is recommended that this method is called while recording to check
for exceptions. If an error occurs during recording (for example out of
disk space) the recording will stop, but an exception will only be
raised when the <a class="reference internal" href="#picamera.camera.PiCamera.wait_recording" title="picamera.camera.PiCamera.wait_recording"><code class="xref py py-meth docutils literal"><span class="pre">wait_recording()</span></code></a> or <a class="reference internal" href="#picamera.camera.PiCamera.stop_recording" title="picamera.camera.PiCamera.stop_recording"><code class="xref py py-meth docutils literal"><span class="pre">stop_recording()</span></code></a>
methods are called.</p>
<p>If <code class="docutils literal"><span class="pre">timeout</span></code> is 0 (the default) the function will immediately return
(or raise an exception if an error has occurred).</p>
<p>The <em>splitter_port</em> parameter specifies which port of the video
splitter the encoder you wish to wait on is attached to. This
defaults to <code class="docutils literal"><span class="pre">1</span></code> and most users will have no need to specify anything
different. Valid values are between <code class="docutils literal"><span class="pre">0</span></code> and <code class="docutils literal"><span class="pre">3</span></code> inclusive.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.3: </span>The <em>splitter_port</em> parameter was added</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.ISO">
<code class="descname">ISO</code><a class="headerlink" href="#picamera.camera.PiCamera.ISO" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the apparent ISO setting of the camera.</p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 1.8: </span>Please use the <a class="reference internal" href="#picamera.camera.PiCamera.iso" title="picamera.camera.PiCamera.iso"><code class="xref py py-attr docutils literal"><span class="pre">iso</span></code></a> attribute instead.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera._still_encoding">
<code class="descname">_still_encoding</code><a class="headerlink" href="#picamera.camera.PiCamera._still_encoding" title="Permalink to this definition">¶</a></dt>
<dd><p>Configures the encoding of the camera&#8217;s still port.</p>
<p>This attribute controls the encoding of the camera&#8217;s still port (see
<a class="reference internal" href="index.html#under-the-hood"><span>Under the Hood</span></a> for more information). It is intended for
internal use, but may be useful to developers wishing to implement
<a class="reference internal" href="index.html#custom-encoders"><span>custom encoders</span></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.analog_gain">
<code class="descname">analog_gain</code><a class="headerlink" href="#picamera.camera.PiCamera.analog_gain" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the current analog gain of the camera.</p>
<p>When queried, this property returns the analog gain currently being
used by the camera. The value represents the analog gain of the sensor
prior to digital conversion. The value is returned as a
<a class="reference external" href="http://docs.python.org/3.2/library/fractions.html#fractions.Fraction" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">Fraction</span></code></a> instance.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.6.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.annotate_background">
<code class="descname">annotate_background</code><a class="headerlink" href="#picamera.camera.PiCamera.annotate_background" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls what background is drawn behind the annotation.</p>
<p>The <a class="reference internal" href="#picamera.camera.PiCamera.annotate_background" title="picamera.camera.PiCamera.annotate_background"><code class="xref py py-attr docutils literal"><span class="pre">annotate_background</span></code></a> attribute specifies if a background
will be drawn behind the <a class="reference internal" href="#picamera.camera.PiCamera.annotate_text" title="picamera.camera.PiCamera.annotate_text"><code class="xref py py-attr docutils literal"><span class="pre">annotation</span> <span class="pre">text</span></code></a> and,
if so, what color it will be. The value is specified as a
<a class="reference internal" href="index.html#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> or <code class="docutils literal"><span class="pre">None</span></code> if no background should be
drawn. The default is <code class="docutils literal"><span class="pre">None</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For backward compatibility purposes, the value <code class="docutils literal"><span class="pre">False</span></code> will be
treated as <code class="docutils literal"><span class="pre">None</span></code>, and the value <code class="docutils literal"><span class="pre">True</span></code> will be treated as the
color black. The &#8220;truthiness&#8221; of the values returned by the
attribute are backward compatible although the values themselves
are not.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.</span></p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.10: </span>In prior versions this was a bool value with <code class="docutils literal"><span class="pre">True</span></code> representing
a black background.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.annotate_foreground">
<code class="descname">annotate_foreground</code><a class="headerlink" href="#picamera.camera.PiCamera.annotate_foreground" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls the color of the annotation text.</p>
<p>The <a class="reference internal" href="#picamera.camera.PiCamera.annotate_foreground" title="picamera.camera.PiCamera.annotate_foreground"><code class="xref py py-attr docutils literal"><span class="pre">annotate_foreground</span></code></a> attribute specifies, partially, the
color of the annotation text. The value is specified as a
<a class="reference internal" href="index.html#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a>. The default is white.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The underlying firmware does not directly support setting all
components of the text color, only the Y&#8217; component of a <a class="reference external" href="https://en.wikipedia.org/wiki/YUV">Y&#8217;UV</a>
tuple. This is roughly (but not precisely) analogous to the
&#8220;brightness&#8221; of a color, so you may choose to think of this as
setting how bright the annotation text will be relative to its
background. In order to specify just the Y&#8217; component when setting
this attribute, you may choose to construct the
<a class="reference internal" href="index.html#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> instance as follows:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">camera</span><span class="o">.</span><span class="n">annotate_foreground</span> <span class="o">=</span> <span class="n">picamera</span><span class="o">.</span><span class="n">Color</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.10.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.annotate_frame_num">
<code class="descname">annotate_frame_num</code><a class="headerlink" href="#picamera.camera.PiCamera.annotate_frame_num" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls whether the current frame number is drawn as an annotation.</p>
<p>The <a class="reference internal" href="#picamera.camera.PiCamera.annotate_frame_num" title="picamera.camera.PiCamera.annotate_frame_num"><code class="xref py py-attr docutils literal"><span class="pre">annotate_frame_num</span></code></a> attribute is a bool indicating whether
or not the current frame number is rendered as an annotation, similar
to <a class="reference internal" href="#picamera.camera.PiCamera.annotate_text" title="picamera.camera.PiCamera.annotate_text"><code class="xref py py-attr docutils literal"><span class="pre">annotate_text</span></code></a>. The default is <code class="docutils literal"><span class="pre">False</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.annotate_text">
<code class="descname">annotate_text</code><a class="headerlink" href="#picamera.camera.PiCamera.annotate_text" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets a text annotation for all output.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.annotate_text" title="picamera.camera.PiCamera.annotate_text"><code class="xref py py-attr docutils literal"><span class="pre">annotate_text</span></code></a> property returns the current
annotation (if no annotation has been set, this is simply a blank
string).</p>
<p>When set, the property immediately applies the annotation to the
preview (if it is running) and to any future captures or video
recording. Strings longer than 255 characters, or strings containing
non-ASCII characters will raise a
<a class="reference internal" href="index.html#picamera.exc.PiCameraValueError" title="picamera.exc.PiCameraValueError"><code class="xref py py-exc docutils literal"><span class="pre">PiCameraValueError</span></code></a>. The default value is <code class="docutils literal"><span class="pre">''</span></code>.</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.8: </span>Text annotations can now be 255 characters long. The prior limit
was 32 characters.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.annotate_text_size">
<code class="descname">annotate_text_size</code><a class="headerlink" href="#picamera.camera.PiCamera.annotate_text_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Controls the size of the annotation text.</p>
<p>The <a class="reference internal" href="#picamera.camera.PiCamera.annotate_text_size" title="picamera.camera.PiCamera.annotate_text_size"><code class="xref py py-attr docutils literal"><span class="pre">annotate_text_size</span></code></a> attribute is an int which determines how
large the annotation text will appear on the display. Valid values are
in the range 6 to 160, inclusive. The default is 32.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.10.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.awb_gains">
<code class="descname">awb_gains</code><a class="headerlink" href="#picamera.camera.PiCamera.awb_gains" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets or sets the auto-white-balance gains of the camera.</p>
<p>When queried, this attribute returns a tuple of values representing
the <cite>(red, blue)</cite> balance of the camera. The <cite>red</cite> and <cite>blue</cite> values
are returned <a class="reference external" href="http://docs.python.org/3.2/library/fractions.html#fractions.Fraction" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">Fraction</span></code></a> instances. The values will
be between 0.0 and 8.0.</p>
<p>When set, this attribute adjusts the camera&#8217;s auto-white-balance gains.
The property can be specified as a single value in which case both red
and blue gains will be adjusted equally, or as a <cite>(red, blue)</cite> tuple.
Values can be specified as an <a class="reference external" href="http://docs.python.org/3.2/library/stdtypes.html#typesnumeric" title="(in Python v3.2)"><span class="xref std std-ref">int</span></a>, <a class="reference external" href="http://docs.python.org/3.2/library/stdtypes.html#typesnumeric" title="(in Python v3.2)"><span class="xref std std-ref">float</span></a> or <a class="reference external" href="http://docs.python.org/3.2/library/fractions.html#fractions.Fraction" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">Fraction</span></code></a> and each gain must be
between 0.0 and 8.0.  Typical values for the gains are between 0.9 and
1.9.  The property can be set while recordings or previews are in
progress.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This attribute only has an effect when <a class="reference internal" href="#picamera.camera.PiCamera.awb_mode" title="picamera.camera.PiCamera.awb_mode"><code class="xref py py-attr docutils literal"><span class="pre">awb_mode</span></code></a> is set to
<code class="docutils literal"><span class="pre">'off'</span></code>.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.6: </span>Prior to version 1.6, this attribute was write-only.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.awb_mode">
<code class="descname">awb_mode</code><a class="headerlink" href="#picamera.camera.PiCamera.awb_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the auto-white-balance mode of the camera.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.awb_mode" title="picamera.camera.PiCamera.awb_mode"><code class="xref py py-attr docutils literal"><span class="pre">awb_mode</span></code></a> property returns a string
representing the auto white balance setting of the camera. The possible
values can be obtained from the <code class="docutils literal"><span class="pre">PiCamera.AWB_MODES</span></code> attribute, and
are as follows:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'off'</span></code></li>
<li><code class="docutils literal"><span class="pre">'auto'</span></code></li>
<li><code class="docutils literal"><span class="pre">'sunlight'</span></code></li>
<li><code class="docutils literal"><span class="pre">'cloudy'</span></code></li>
<li><code class="docutils literal"><span class="pre">'shade'</span></code></li>
<li><code class="docutils literal"><span class="pre">'tungsten'</span></code></li>
<li><code class="docutils literal"><span class="pre">'fluorescent'</span></code></li>
<li><code class="docutils literal"><span class="pre">'incandescent'</span></code></li>
<li><code class="docutils literal"><span class="pre">'flash'</span></code></li>
<li><code class="docutils literal"><span class="pre">'horizon'</span></code></li>
</ul>
<p>When set, the property adjusts the camera&#8217;s auto-white-balance mode.
The property can be set while recordings or previews are in progress.
The default value is <code class="docutils literal"><span class="pre">'auto'</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">AWB mode <code class="docutils literal"><span class="pre">'off'</span></code> is special: this disables the camera&#8217;s automatic
white balance permitting manual control of the white balance via
the <a class="reference internal" href="#picamera.camera.PiCamera.awb_gains" title="picamera.camera.PiCamera.awb_gains"><code class="xref py py-attr docutils literal"><span class="pre">awb_gains</span></code></a> property.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.brightness">
<code class="descname">brightness</code><a class="headerlink" href="#picamera.camera.PiCamera.brightness" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the brightness setting of the camera.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.brightness" title="picamera.camera.PiCamera.brightness"><code class="xref py py-attr docutils literal"><span class="pre">brightness</span></code></a> property returns the brightness
level of the camera as an integer between 0 and 100.  When set, the
property adjusts the brightness of the camera. Brightness can be
adjusted while previews or recordings are in progress. The default
value is 50.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.closed">
<code class="descname">closed</code><a class="headerlink" href="#picamera.camera.PiCamera.closed" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code> if the <a class="reference internal" href="#picamera.camera.PiCamera.close" title="picamera.camera.PiCamera.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a> method has been called.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.color_effects">
<code class="descname">color_effects</code><a class="headerlink" href="#picamera.camera.PiCamera.color_effects" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the current color effect applied by the camera.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.color_effects" title="picamera.camera.PiCamera.color_effects"><code class="xref py py-attr docutils literal"><span class="pre">color_effects</span></code></a> property either returns
<code class="docutils literal"><span class="pre">None</span></code> which indicates that the camera is using normal color
settings, or a <code class="docutils literal"><span class="pre">(u,</span> <span class="pre">v)</span></code> tuple where <code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">v</span></code> are integer
values between 0 and 255.</p>
<p>When set, the property changes the color effect applied by the camera.
The property can be set while recordings or previews are in progress.
For example, to make the image black and white set the value to <code class="docutils literal"><span class="pre">(128,</span>
<span class="pre">128)</span></code>. The default value is <code class="docutils literal"><span class="pre">None</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.contrast">
<code class="descname">contrast</code><a class="headerlink" href="#picamera.camera.PiCamera.contrast" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the contrast setting of the camera.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.contrast" title="picamera.camera.PiCamera.contrast"><code class="xref py py-attr docutils literal"><span class="pre">contrast</span></code></a> property returns the contrast level
of the camera as an integer between -100 and 100.  When set, the
property adjusts the contrast of the camera. Contrast can be adjusted
while previews or recordings are in progress. The default value is 0.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.crop">
<code class="descname">crop</code><a class="headerlink" href="#picamera.camera.PiCamera.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the zoom applied to the camera&#8217;s input.</p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 1.8: </span>Please use the <a class="reference internal" href="#picamera.camera.PiCamera.zoom" title="picamera.camera.PiCamera.zoom"><code class="xref py py-attr docutils literal"><span class="pre">zoom</span></code></a> attribute instead.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.digital_gain">
<code class="descname">digital_gain</code><a class="headerlink" href="#picamera.camera.PiCamera.digital_gain" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the current digital gain of the camera.</p>
<p>When queried, this property returns the digital gain currently being
used by the camera. The value represents the digital gain the camera
applies after conversion of the sensor&#8217;s analog output. The value is
returned as a <a class="reference external" href="http://docs.python.org/3.2/library/fractions.html#fractions.Fraction" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">Fraction</span></code></a> instance.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.6.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.drc_strength">
<code class="descname">drc_strength</code><a class="headerlink" href="#picamera.camera.PiCamera.drc_strength" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the dynamic range compression strength of the camera.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.drc_strength" title="picamera.camera.PiCamera.drc_strength"><code class="xref py py-attr docutils literal"><span class="pre">drc_strength</span></code></a> property returns a string
indicating the amount of <a class="reference external" href="http://en.wikipedia.org/wiki/Gain_compression">dynamic range compression</a> the camera
applies to images.</p>
<p>When set, the attributes adjusts the strength of the dynamic range
compression applied to the camera&#8217;s output. Valid values are given
in the list below:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'off'</span></code></li>
<li><code class="docutils literal"><span class="pre">'low'</span></code></li>
<li><code class="docutils literal"><span class="pre">'medium'</span></code></li>
<li><code class="docutils literal"><span class="pre">'high'</span></code></li>
</ul>
<p>The default value is <code class="docutils literal"><span class="pre">'off'</span></code>. All possible values for the attribute
can be obtained from the <code class="docutils literal"><span class="pre">PiCamera.DRC_STRENGTHS</span></code> attribute.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.6.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.exif_tags">
<code class="descname">exif_tags</code><a class="headerlink" href="#picamera.camera.PiCamera.exif_tags" title="Permalink to this definition">¶</a></dt>
<dd><p>Holds a mapping of the Exif tags to apply to captured images.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Please note that Exif tagging is only supported with the <code class="docutils literal"><span class="pre">jpeg</span></code>
format.</p>
</div>
<p>By default several Exif tags are automatically applied to any images
taken with the <a class="reference internal" href="#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a> method: <code class="docutils literal"><span class="pre">IFD0.Make</span></code> (which is set to
<code class="docutils literal"><span class="pre">RaspberryPi</span></code>), <code class="docutils literal"><span class="pre">IFD0.Model</span></code> (which is set to <code class="docutils literal"><span class="pre">RP_OV5647</span></code>), and
three timestamp tags: <code class="docutils literal"><span class="pre">IFD0.DateTime</span></code>, <code class="docutils literal"><span class="pre">EXIF.DateTimeOriginal</span></code>, and
<code class="docutils literal"><span class="pre">EXIF.DateTimeDigitized</span></code> which are all set to the current date and
time just before the picture is taken.</p>
<p>If you wish to set additional Exif tags, or override any of the
aforementioned tags, simply add entries to the exif_tags map before
calling <a class="reference internal" href="#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a>. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">camera</span><span class="o">.</span><span class="n">exif_tags</span><span class="p">[</span><span class="s">&#39;IFD0.Copyright&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;Copyright (c) 2013 Foo Industries&#39;</span>
</pre></div>
</div>
<p>The Exif standard mandates ASCII encoding for all textual values, hence
strings containing non-ASCII characters will cause an encoding error to
be raised when <a class="reference internal" href="#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a> is called.  If you wish to set binary
values, use a <a class="reference external" href="http://docs.python.org/3.2/library/functions.html#bytes" title="(in Python v3.2)"><code class="xref py py-func docutils literal"><span class="pre">bytes()</span></code></a> value:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">camera</span><span class="o">.</span><span class="n">exif_tags</span><span class="p">[</span><span class="s">&#39;EXIF.UserComment&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="s">&#39;Something containing</span><span class="se">\x00</span><span class="s">NULL characters&#39;</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Binary Exif values are currently ignored; this appears to be a
libmmal or firmware bug.</p>
</div>
<p>You may also specify datetime values, integer, or float values, all of
which will be converted to appropriate ASCII strings (datetime values
are formatted as <code class="docutils literal"><span class="pre">YYYY:MM:DD</span> <span class="pre">HH:MM:SS</span></code> in accordance with the Exif
standard).</p>
<p>The currently supported Exif tags are:</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Group</th>
<th class="head">Tags</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>IFD0,
IFD1</td>
<td>ImageWidth, ImageLength, BitsPerSample, Compression,
PhotometricInterpretation, ImageDescription, Make, Model,
StripOffsets, Orientation, SamplesPerPixel, RowsPerString,
StripByteCounts, Xresolution, Yresolution,
PlanarConfiguration, ResolutionUnit, TransferFunction,
Software, DateTime, Artist, WhitePoint,
PrimaryChromaticities, JPEGInterchangeFormat,
JPEGInterchangeFormatLength, YcbCrCoefficients,
YcbCrSubSampling, YcbCrPositioning, ReferenceBlackWhite,
Copyright</td>
</tr>
<tr class="row-odd"><td>EXIF</td>
<td>ExposureTime, FNumber, ExposureProgram,
SpectralSensitivity, ISOSpeedRatings, OECF, ExifVersion,
DateTimeOriginal, DateTimeDigitized,
ComponentsConfiguration, CompressedBitsPerPixel,
ShutterSpeedValue, ApertureValue, BrightnessValue,
ExposureBiasValue, MaxApertureValue, SubjectDistance,
MeteringMode, LightSource, Flash, FocalLength, SubjectArea,
MakerNote, UserComment, SubSecTime, SubSecTimeOriginal,
SubSecTimeDigitized, FlashpixVersion, ColorSpace,
PixelXDimension, PixelYDimension, RelatedSoundFile,
FlashEnergy, SpacialFrequencyResponse,
FocalPlaneXResolution, FocalPlaneYResolution,
FocalPlaneResolutionUnit, SubjectLocation, ExposureIndex,
SensingMethod, FileSource, SceneType, CFAPattern,
CustomRendered, ExposureMode, WhiteBalance,
DigitalZoomRatio, FocalLengthIn35mmFilm, SceneCaptureType,
GainControl, Contrast, Saturation, Sharpness,
DeviceSettingDescription, SubjectDistanceRange,
ImageUniqueID</td>
</tr>
<tr class="row-even"><td>GPS</td>
<td>GPSVersionID, GPSLatitudeRef, GPSLatitude, GPSLongitudeRef,
GPSLongitude, GPSAltitudeRef, GPSAltitude, GPSTimeStamp,
GPSSatellites, GPSStatus, GPSMeasureMode, GPSDOP,
GPSSpeedRef, GPSSpeed, GPSTrackRef, GPSTrack,
GPSImgDirectionRef, GPSImgDirection, GPSMapDatum,
GPSDestLatitudeRef, GPSDestLatitude, GPSDestLongitudeRef,
GPSDestLongitude, GPSDestBearingRef, GPSDestBearing,
GPSDestDistanceRef, GPSDestDistance, GPSProcessingMethod,
GPSAreaInformation, GPSDateStamp, GPSDifferential</td>
</tr>
<tr class="row-odd"><td>EINT</td>
<td>InteroperabilityIndex, InteroperabilityVersion,
RelatedImageFileFormat, RelatedImageWidth,
RelatedImageLength</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.exposure_compensation">
<code class="descname">exposure_compensation</code><a class="headerlink" href="#picamera.camera.PiCamera.exposure_compensation" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the exposure compensation level of the camera.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.exposure_compensation" title="picamera.camera.PiCamera.exposure_compensation"><code class="xref py py-attr docutils literal"><span class="pre">exposure_compensation</span></code></a> property returns an
integer value between -25 and 25 indicating the exposure level of the
camera. Larger values result in brighter images.</p>
<p>When set, the property adjusts the camera&#8217;s exposure compensation
level. Each increment represents 1/6th of a stop. Hence setting the
attribute to 6 increases exposure by 1 stop. The property can be set
while recordings or previews are in progress. The default value is 0.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.exposure_mode">
<code class="descname">exposure_mode</code><a class="headerlink" href="#picamera.camera.PiCamera.exposure_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the exposure mode of the camera.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.exposure_mode" title="picamera.camera.PiCamera.exposure_mode"><code class="xref py py-attr docutils literal"><span class="pre">exposure_mode</span></code></a> property returns a string
representing the exposure setting of the camera. The possible values
can be obtained from the <code class="docutils literal"><span class="pre">PiCamera.EXPOSURE_MODES</span></code> attribute, and
are as follows:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'off'</span></code></li>
<li><code class="docutils literal"><span class="pre">'auto'</span></code></li>
<li><code class="docutils literal"><span class="pre">'night'</span></code></li>
<li><code class="docutils literal"><span class="pre">'nightpreview'</span></code></li>
<li><code class="docutils literal"><span class="pre">'backlight'</span></code></li>
<li><code class="docutils literal"><span class="pre">'spotlight'</span></code></li>
<li><code class="docutils literal"><span class="pre">'sports'</span></code></li>
<li><code class="docutils literal"><span class="pre">'snow'</span></code></li>
<li><code class="docutils literal"><span class="pre">'beach'</span></code></li>
<li><code class="docutils literal"><span class="pre">'verylong'</span></code></li>
<li><code class="docutils literal"><span class="pre">'fixedfps'</span></code></li>
<li><code class="docutils literal"><span class="pre">'antishake'</span></code></li>
<li><code class="docutils literal"><span class="pre">'fireworks'</span></code></li>
</ul>
<p>When set, the property adjusts the camera&#8217;s exposure mode.  The
property can be set while recordings or previews are in progress. The
default value is <code class="docutils literal"><span class="pre">'auto'</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Exposure mode <code class="docutils literal"><span class="pre">'off'</span></code> is special: this disables the camera&#8217;s
automatic gain control, fixing the values of <a class="reference internal" href="#picamera.camera.PiCamera.digital_gain" title="picamera.camera.PiCamera.digital_gain"><code class="xref py py-attr docutils literal"><span class="pre">digital_gain</span></code></a>
and <a class="reference internal" href="#picamera.camera.PiCamera.analog_gain" title="picamera.camera.PiCamera.analog_gain"><code class="xref py py-attr docutils literal"><span class="pre">analog_gain</span></code></a>. Please note that these properties are not
directly settable, and default to low values when the camera is
first initialized. Therefore it is important to let them settle on
higher values before disabling automatic gain control otherwise
all frames captured will appear black.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.exposure_speed">
<code class="descname">exposure_speed</code><a class="headerlink" href="#picamera.camera.PiCamera.exposure_speed" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the current shutter speed of the camera.</p>
<p>When queried, this property returns the shutter speed currently being
used by the camera. If you have set <a class="reference internal" href="#picamera.camera.PiCamera.shutter_speed" title="picamera.camera.PiCamera.shutter_speed"><code class="xref py py-attr docutils literal"><span class="pre">shutter_speed</span></code></a> to a non-zero
value, then <a class="reference internal" href="#picamera.camera.PiCamera.exposure_speed" title="picamera.camera.PiCamera.exposure_speed"><code class="xref py py-attr docutils literal"><span class="pre">exposure_speed</span></code></a> and <a class="reference internal" href="#picamera.camera.PiCamera.shutter_speed" title="picamera.camera.PiCamera.shutter_speed"><code class="xref py py-attr docutils literal"><span class="pre">shutter_speed</span></code></a> should be
equal. However, if <a class="reference internal" href="#picamera.camera.PiCamera.shutter_speed" title="picamera.camera.PiCamera.shutter_speed"><code class="xref py py-attr docutils literal"><span class="pre">shutter_speed</span></code></a> is set to 0 (auto), then you
can read the actual shutter speed being used from this attribute.  The
value is returned as an integer representing a number of microseconds.
This is a read-only property.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.6.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.flash_mode">
<code class="descname">flash_mode</code><a class="headerlink" href="#picamera.camera.PiCamera.flash_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the flash mode of the camera.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.flash_mode" title="picamera.camera.PiCamera.flash_mode"><code class="xref py py-attr docutils literal"><span class="pre">flash_mode</span></code></a> property returns a string
representing the flash setting of the camera. The possible values can
be obtained from the <code class="docutils literal"><span class="pre">PiCamera.FLASH_MODES</span></code> attribute, and are as
follows:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'off'</span></code></li>
<li><code class="docutils literal"><span class="pre">'auto'</span></code></li>
<li><code class="docutils literal"><span class="pre">'on'</span></code></li>
<li><code class="docutils literal"><span class="pre">'redeye'</span></code></li>
<li><code class="docutils literal"><span class="pre">'fillin'</span></code></li>
<li><code class="docutils literal"><span class="pre">'torch'</span></code></li>
</ul>
<p>When set, the property adjusts the camera&#8217;s flash mode.  The property
can be set while recordings or previews are in progress.  The default
value is <code class="docutils literal"><span class="pre">'off'</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You must define which GPIO pins the camera is to use for flash and
privacy indicators. This is done within the <a class="reference external" href="http://www.raspberrypi.org/documentation/configuration/pin-configuration.md">Device Tree
configuration</a> which is considered an advanced topic.
Specifically, you need to define pins <code class="docutils literal"><span class="pre">FLASH_0_ENABLE</span></code> and
optionally <code class="docutils literal"><span class="pre">FLASH_0_INDICATOR</span></code> (for the privacy indicator). More
information can be found in this <a class="reference internal" href="index.html#flash-configuration"><span>recipe</span></a>.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.frame">
<code class="descname">frame</code><a class="headerlink" href="#picamera.camera.PiCamera.frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves information about the current frame recorded from the camera.</p>
<p>When video recording is active (after a call to
<a class="reference internal" href="#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a>), this attribute will return a
<a class="reference internal" href="index.html#picamera.encoders.PiVideoFrame" title="picamera.encoders.PiVideoFrame"><code class="xref py py-class docutils literal"><span class="pre">PiVideoFrame</span></code></a> tuple containing information
about the current frame that the camera is recording.</p>
<p>If multiple video recordings are currently in progress (after multiple
calls to <a class="reference internal" href="#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> with different values for the
<code class="docutils literal"><span class="pre">splitter_port</span></code> parameter), which encoder&#8217;s frame information is
returned is arbitrary. If you require information from a specific
encoder, you will need to extract it from <code class="xref py py-attr docutils literal"><span class="pre">_encoders</span></code> explicitly.</p>
<p>Querying this property when the camera is not recording will result in
an exception.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There is a small window of time when querying this attribute will
return <code class="docutils literal"><span class="pre">None</span></code> after calling <a class="reference internal" href="#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a>. If this
attribute returns <code class="docutils literal"><span class="pre">None</span></code>, this means that the video encoder has
been initialized, but the camera has not yet returned any frames.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.framerate">
<code class="descname">framerate</code><a class="headerlink" href="#picamera.camera.PiCamera.framerate" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the framerate at which video-port based image
captures, video recordings, and previews will run.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.framerate" title="picamera.camera.PiCamera.framerate"><code class="xref py py-attr docutils literal"><span class="pre">framerate</span></code></a> property returns the rate at which
the camera&#8217;s video and preview ports will operate as a
<a class="reference external" href="http://docs.python.org/3.2/library/fractions.html#fractions.Fraction" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">Fraction</span></code></a> instance which can be easily converted to
an <code class="xref py py-class docutils literal"><span class="pre">int</span></code> or <code class="xref py py-class docutils literal"><span class="pre">float</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>For backwards compatibility, a derivative of the
<a class="reference external" href="http://docs.python.org/3.2/library/fractions.html#fractions.Fraction" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">Fraction</span></code></a> class is actually used which permits
the value to be treated as a tuple of <code class="docutils literal"><span class="pre">(numerator,</span> <span class="pre">denominator)</span></code>.</p>
<p class="last">Setting and retrieving framerate as a <code class="docutils literal"><span class="pre">(numerator,</span> <span class="pre">denominator)</span></code>
tuple is deprecated and will be removed in 2.0. Please use a
<a class="reference external" href="http://docs.python.org/3.2/library/fractions.html#fractions.Fraction" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">Fraction</span></code></a> instance instead (which is just as
accurate and also permits direct use with math operators).</p>
</div>
<p>When set, the property reconfigures the camera so that the next call to
recording and previewing methods will use the new framerate.  The
framerate can be specified as an <a class="reference external" href="http://docs.python.org/3.2/library/stdtypes.html#typesnumeric" title="(in Python v3.2)"><span class="xref std std-ref">int</span></a>, <a class="reference external" href="http://docs.python.org/3.2/library/stdtypes.html#typesnumeric" title="(in Python v3.2)"><span class="xref std std-ref">float</span></a>, <a class="reference external" href="http://docs.python.org/3.2/library/fractions.html#fractions.Fraction" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">Fraction</span></code></a>, or a <code class="docutils literal"><span class="pre">(numerator,</span>
<span class="pre">denominator)</span></code> tuple.  The camera must not be closed, and no recording
must be active when the property is set.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This attribute, in combination with <a class="reference internal" href="#picamera.camera.PiCamera.resolution" title="picamera.camera.PiCamera.resolution"><code class="xref py py-attr docutils literal"><span class="pre">resolution</span></code></a>, determines
the mode that the camera operates in. The actual sensor framerate
and resolution used by the camera is influenced, but not directly
set, by this property. See <a class="reference internal" href="#picamera.camera.PiCamera.sensor_mode" title="picamera.camera.PiCamera.sensor_mode"><code class="xref py py-attr docutils literal"><span class="pre">sensor_mode</span></code></a> for more
information.</p>
</div>
<p>The initial value of this property can be specified with the
<em>framerate</em> parameter in the <a class="reference internal" href="#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a> constructor.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.hflip">
<code class="descname">hflip</code><a class="headerlink" href="#picamera.camera.PiCamera.hflip" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets whether the camera&#8217;s output is horizontally flipped.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.hflip" title="picamera.camera.PiCamera.hflip"><code class="xref py py-attr docutils literal"><span class="pre">hflip</span></code></a> property returns a boolean indicating
whether or not the camera&#8217;s output is horizontally flipped. The
property can be set while recordings or previews are in progress. The
default value is <code class="docutils literal"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.image_denoise">
<code class="descname">image_denoise</code><a class="headerlink" href="#picamera.camera.PiCamera.image_denoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets whether denoise will be applied to image captures.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.image_denoise" title="picamera.camera.PiCamera.image_denoise"><code class="xref py py-attr docutils literal"><span class="pre">image_denoise</span></code></a> property returns a boolean
value indicating whether or not the camera software will apply a
denoise algorithm to image captures.</p>
<p>When set, the property activates or deactivates the denoise algorithm
for image captures. The property can be set while recordings or
previews are in progress. The default value is <code class="docutils literal"><span class="pre">True</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.image_effect">
<code class="descname">image_effect</code><a class="headerlink" href="#picamera.camera.PiCamera.image_effect" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the current image effect applied by the camera.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.image_effect" title="picamera.camera.PiCamera.image_effect"><code class="xref py py-attr docutils literal"><span class="pre">image_effect</span></code></a> property returns a string
representing the effect the camera will apply to captured video. The
possible values can be obtained from the <code class="docutils literal"><span class="pre">PiCamera.IMAGE_EFFECTS</span></code>
attribute, and are as follows:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'none'</span></code></li>
<li><code class="docutils literal"><span class="pre">'negative'</span></code></li>
<li><code class="docutils literal"><span class="pre">'solarize'</span></code></li>
<li><code class="docutils literal"><span class="pre">'sketch'</span></code></li>
<li><code class="docutils literal"><span class="pre">'denoise'</span></code></li>
<li><code class="docutils literal"><span class="pre">'emboss'</span></code></li>
<li><code class="docutils literal"><span class="pre">'oilpaint'</span></code></li>
<li><code class="docutils literal"><span class="pre">'hatch'</span></code></li>
<li><code class="docutils literal"><span class="pre">'gpen'</span></code></li>
<li><code class="docutils literal"><span class="pre">'pastel'</span></code></li>
<li><code class="docutils literal"><span class="pre">'watercolor'</span></code></li>
<li><code class="docutils literal"><span class="pre">'film'</span></code></li>
<li><code class="docutils literal"><span class="pre">'blur'</span></code></li>
<li><code class="docutils literal"><span class="pre">'saturation'</span></code></li>
<li><code class="docutils literal"><span class="pre">'colorswap'</span></code></li>
<li><code class="docutils literal"><span class="pre">'washedout'</span></code></li>
<li><code class="docutils literal"><span class="pre">'posterise'</span></code></li>
<li><code class="docutils literal"><span class="pre">'colorpoint'</span></code></li>
<li><code class="docutils literal"><span class="pre">'colorbalance'</span></code></li>
<li><code class="docutils literal"><span class="pre">'cartoon'</span></code></li>
<li><code class="docutils literal"><span class="pre">'deinterlace1'</span></code></li>
<li><code class="docutils literal"><span class="pre">'deinterlace2'</span></code></li>
</ul>
<p>When set, the property changes the effect applied by the camera.  The
property can be set while recordings or previews are in progress, but
only certain effects work while recording video (notably <code class="docutils literal"><span class="pre">'negative'</span></code>
and <code class="docutils literal"><span class="pre">'solarize'</span></code>). The default value is <code class="docutils literal"><span class="pre">'none'</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.image_effect_params">
<code class="descname">image_effect_params</code><a class="headerlink" href="#picamera.camera.PiCamera.image_effect_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the parameters for the current <a class="reference internal" href="#picamera.camera.PiCamera.image_effect" title="picamera.camera.PiCamera.image_effect"><code class="xref py py-attr docutils literal"><span class="pre">effect</span></code></a>.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.image_effect_params" title="picamera.camera.PiCamera.image_effect_params"><code class="xref py py-attr docutils literal"><span class="pre">image_effect_params</span></code></a> property either returns
<code class="docutils literal"><span class="pre">None</span></code> (for effects which have no configurable parameters, or if no
parameters have been configured), or a tuple of numeric values up to
six elements long.</p>
<p>When set, the property changes the parameters of the current
<a class="reference internal" href="#picamera.camera.PiCamera.image_effect" title="picamera.camera.PiCamera.image_effect"><code class="xref py py-attr docutils literal"><span class="pre">effect</span></code></a> as a sequence of numbers, or a single
number. Attempting to set parameters on an effect which does not
support parameters, or providing an incompatible set of parameters for
an effect will raise a <a class="reference internal" href="index.html#picamera.exc.PiCameraValueError" title="picamera.exc.PiCameraValueError"><code class="xref py py-exc docutils literal"><span class="pre">PiCameraValueError</span></code></a>
exception.</p>
<p>The effects which have parameters, and what combinations those
parameters can take is as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="21%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Effect</th>
<th class="head">Parameters</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td rowspan="3"><code class="docutils literal"><span class="pre">'solarize'</span></code></td>
<td><em>yuv</em>,
<em>x0</em>, <em>y1</em>,
<em>y2</em>, <em>y3</em></td>
<td><em>yuv</em> controls whether data is
processed as RGB (0) or YUV(1). Input
values from 0 to <em>x0</em> - 1 are remapped
linearly onto the range 0 to <em>y0</em>.
Values from <em>x0</em> to 255 are remapped
linearly onto the range <em>y1</em> to <em>y2</em>.</td>
</tr>
<tr class="row-odd"><td><em>x0</em>, <em>y0</em>,
<em>y1</em>, <em>y2</em></td>
<td>Same as above, but <em>yuv</em> defaults to
0 (process as RGB).</td>
</tr>
<tr class="row-even"><td><em>yuv</em></td>
<td>Same as above, but <em>x0</em>, <em>y0</em>, <em>y1</em>,
<em>y2</em> default to 128, 128, 128, 0
respectively.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'colorpoint'</span></code></td>
<td><em>quadrant</em></td>
<td><em>quadrant</em> specifies which quadrant
of the U/V space to retain chroma
from: 0=green, 1=red/yellow, 2=blue,
3=purple. There is no default; this
effect does nothing until parameters
are set.</td>
</tr>
<tr class="row-even"><td rowspan="3"><code class="docutils literal"><span class="pre">'colorbalance'</span></code></td>
<td><em>lens</em>,
<em>r</em>, <em>g</em>, <em>b</em>,
<em>u</em>, <em>v</em></td>
<td><em>lens</em> specifies the lens shading
strength (0.0 to 256.0, where 0.0
indicates lens shading has no effect).
<em>r</em>, <em>g</em>, <em>b</em> are multipliers for their
respective color channels (0.0 to
256.0). <em>u</em> and <em>v</em> are offsets added
to the U/V plane (0 to 255).</td>
</tr>
<tr class="row-odd"><td><em>lens</em>,
<em>r</em>, <em>g</em>, <em>b</em></td>
<td>Same as above but <em>u</em> are defaulted
to 0.</td>
</tr>
<tr class="row-even"><td><em>lens</em>,
<em>r</em>, <em>b</em></td>
<td>Same as above but <em>g</em> also defaults to
to 1.0.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'colorswap'</span></code></td>
<td><em>dir</em></td>
<td>If <em>dir</em> is 0, swap RGB to BGR. If
<em>dir</em> is 1, swap RGB to BRG.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'posterise'</span></code></td>
<td><em>steps</em></td>
<td>Control the quantization steps for the
image. Valid values are 2 to 32, and
the default is 4.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">'blur'</span></code></td>
<td><em>size</em></td>
<td>Specifies the size of the kernel. Valid
values are 1 or 2.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">'film'</span></code></td>
<td><em>strength</em>,
<em>u</em>, <em>v</em></td>
<td><em>strength</em> specifies the strength of
effect. <em>u</em> and <em>v</em> are offsets added
to the U/V plane (0 to 255).</td>
</tr>
<tr class="row-odd"><td rowspan="2"><code class="docutils literal"><span class="pre">'watercolor'</span></code></td>
<td><em>u</em>, <em>v</em></td>
<td><em>u</em> and <em>v</em> specify offsets to add to
the U/V plane (0 to 255).</td>
</tr>
<tr class="row-even"><td>&nbsp;</td>
<td>No parameters indicates no U/V effect.</td>
</tr>
</tbody>
</table>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.iso">
<code class="descname">iso</code><a class="headerlink" href="#picamera.camera.PiCamera.iso" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the apparent ISO setting of the camera.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.iso" title="picamera.camera.PiCamera.iso"><code class="xref py py-attr docutils literal"><span class="pre">iso</span></code></a> property returns the ISO setting of the
camera, a value which represents the <a class="reference external" href="http://en.wikipedia.org/wiki/Film_speed#Digital">sensitivity of the camera to
light</a>. Lower values (e.g. 100) imply less sensitivity than higher
values (e.g. 400 or 800). Lower sensitivities tend to produce less
&#8220;noisy&#8221; (smoother) images, but operate poorly in low light conditions.</p>
<p>When set, the property adjusts the sensitivity of the camera. Valid
values are between 0 (auto) and 1600. The actual value used when iso is
explicitly set will be one of the following values (whichever is
closest): 100, 200, 320, 400, 500, 640, 800.</p>
<p>The attribute can be adjusted while previews or recordings are in
progress. The default value is 0 which means automatically determine a
value according to image-taking conditions.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You can query the <a class="reference internal" href="#picamera.camera.PiCamera.analog_gain" title="picamera.camera.PiCamera.analog_gain"><code class="xref py py-attr docutils literal"><span class="pre">analog_gain</span></code></a> and <a class="reference internal" href="#picamera.camera.PiCamera.digital_gain" title="picamera.camera.PiCamera.digital_gain"><code class="xref py py-attr docutils literal"><span class="pre">digital_gain</span></code></a>
attributes to determine the actual gains being used by the camera.
If both are 1.0 this equates to ISO 100.  Please note that this
capability requires an up to date firmware (#692 or later).</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">With iso settings other than 0 (auto), the <a class="reference internal" href="#picamera.camera.PiCamera.exposure_mode" title="picamera.camera.PiCamera.exposure_mode"><code class="xref py py-attr docutils literal"><span class="pre">exposure_mode</span></code></a>
property becomes non-functional.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Some users on the Pi camera forum have noted that higher ISO values
than 800 (specifically up to 1600) can be achieved in certain
conditions with <a class="reference internal" href="#picamera.camera.PiCamera.exposure_mode" title="picamera.camera.PiCamera.exposure_mode"><code class="xref py py-attr docutils literal"><span class="pre">exposure_mode</span></code></a> set to <code class="docutils literal"><span class="pre">'sports'</span></code> and
<a class="reference internal" href="#picamera.camera.PiCamera.iso" title="picamera.camera.PiCamera.iso"><code class="xref py py-attr docutils literal"><span class="pre">iso</span></code></a> set to 0.  It doesn&#8217;t appear to be possible to manually
request an ISO setting higher than 800, but the picamera library
will permit settings up to 1600 in case the underlying firmware
permits such settings in particular circumstances.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.led">
<code class="descname">led</code><a class="headerlink" href="#picamera.camera.PiCamera.led" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the state of the camera&#8217;s LED via GPIO.</p>
<p>If a GPIO library is available (only RPi.GPIO is currently supported),
and if the python process has the necessary privileges (typically this
means running as root via sudo), this property can be used to set the
state of the camera&#8217;s LED as a boolean value (<code class="docutils literal"><span class="pre">True</span></code> is on, <code class="docutils literal"><span class="pre">False</span></code>
is off).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is a write-only property. While it can be used to control the
camera&#8217;s LED, you cannot query the state of the camera&#8217;s LED using
this property.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">There are circumstances in which the camera firmware may override
an existing LED setting. For example, in the case that the firmware
resets the camera (as can happen with a CSI-2 timeout), the LED may
also be reset. If you wish to guarantee that the LED remain off at
all times, you may prefer to use the <code class="docutils literal"><span class="pre">disable_camera_led</span></code> option
in <a class="reference external" href="http://www.raspberrypi.org/documentation/configuration/config-txt.md">config.txt</a> (this has the added advantage that sudo privileges
and GPIO access are not required, at least for LED control).</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.meter_mode">
<code class="descname">meter_mode</code><a class="headerlink" href="#picamera.camera.PiCamera.meter_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the metering mode of the camera.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.meter_mode" title="picamera.camera.PiCamera.meter_mode"><code class="xref py py-attr docutils literal"><span class="pre">meter_mode</span></code></a> property returns the method by
which the camera <a class="reference external" href="http://en.wikipedia.org/wiki/Metering_mode">determines the exposure</a> as one of the following
strings:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'average'</span></code></li>
<li><code class="docutils literal"><span class="pre">'spot'</span></code></li>
<li><code class="docutils literal"><span class="pre">'backlit'</span></code></li>
<li><code class="docutils literal"><span class="pre">'matrix'</span></code></li>
</ul>
<p>When set, the property adjusts the camera&#8217;s metering mode. All modes
set up two regions: a center region, and an outer region. The major
<a class="reference external" href="http://www.raspberrypi.org/forums/viewtopic.php?p=565644#p565644">difference between each mode</a> is the size of the center region. The
<code class="docutils literal"><span class="pre">'backlit'</span></code> mode has the largest central region (30% of the width),
while <code class="docutils literal"><span class="pre">'spot'</span></code> has the smallest (10% of the width).</p>
<p>The property can be set while recordings or previews are in progress.
The default value is <code class="docutils literal"><span class="pre">'average'</span></code>. All possible values for the
attribute can be obtained from the <code class="docutils literal"><span class="pre">PiCamera.METER_MODES</span></code> attribute.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.overlays">
<code class="descname">overlays</code><a class="headerlink" href="#picamera.camera.PiCamera.overlays" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves all active <code class="xref py py-class docutils literal"><span class="pre">PiRenderer</span></code> overlays.</p>
<p>If no overlays are current active, <a class="reference internal" href="#picamera.camera.PiCamera.overlays" title="picamera.camera.PiCamera.overlays"><code class="xref py py-attr docutils literal"><span class="pre">overlays</span></code></a> will return an
empty iterable. Otherwise, it will return an iterable of
<a class="reference internal" href="index.html#picamera.renderers.PiRenderer" title="picamera.renderers.PiRenderer"><code class="xref py py-class docutils literal"><span class="pre">PiRenderer</span></code></a> instances which are currently
acting as overlays.  Note that the preview renderer is an exception to
this: it is <em>not</em> included as an overlay despite being derived from
<a class="reference internal" href="index.html#picamera.renderers.PiRenderer" title="picamera.renderers.PiRenderer"><code class="xref py py-class docutils literal"><span class="pre">PiRenderer</span></code></a>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.preview">
<code class="descname">preview</code><a class="headerlink" href="#picamera.camera.PiCamera.preview" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the <a class="reference internal" href="index.html#picamera.renderers.PiRenderer" title="picamera.renderers.PiRenderer"><code class="xref py py-class docutils literal"><span class="pre">PiRenderer</span></code></a> displaying the
camera preview.</p>
<p>If no preview is currently active, <a class="reference internal" href="#picamera.camera.PiCamera.preview" title="picamera.camera.PiCamera.preview"><code class="xref py py-attr docutils literal"><span class="pre">preview</span></code></a> will return
<code class="docutils literal"><span class="pre">None</span></code>.  Otherwise, it will return the instance of
<a class="reference internal" href="index.html#picamera.renderers.PiRenderer" title="picamera.renderers.PiRenderer"><code class="xref py py-class docutils literal"><span class="pre">PiRenderer</span></code></a> which is currently connected to
the camera&#8217;s preview port for rendering what the camera sees. You can
use the attributes of the <a class="reference internal" href="index.html#picamera.renderers.PiRenderer" title="picamera.renderers.PiRenderer"><code class="xref py py-class docutils literal"><span class="pre">PiRenderer</span></code></a> class
to configure the appearance of the preview. For example, to make the
preview semi-transparent:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">start_preview</span><span class="p">()</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">preview</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="mi">128</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.8.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.preview_alpha">
<code class="descname">preview_alpha</code><a class="headerlink" href="#picamera.camera.PiCamera.preview_alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the opacity of the preview window.</p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 1.8: </span>Please use the <a class="reference internal" href="index.html#picamera.renderers.PiRenderer.alpha" title="picamera.renderers.PiRenderer.alpha"><code class="xref py py-attr docutils literal"><span class="pre">alpha</span></code></a>
attribute of the <a class="reference internal" href="#picamera.camera.PiCamera.preview" title="picamera.camera.PiCamera.preview"><code class="xref py py-attr docutils literal"><span class="pre">preview</span></code></a> object instead.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.preview_fullscreen">
<code class="descname">preview_fullscreen</code><a class="headerlink" href="#picamera.camera.PiCamera.preview_fullscreen" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets full-screen for the preview window.</p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 1.8: </span>Please use the <a class="reference internal" href="index.html#picamera.renderers.PiRenderer.fullscreen" title="picamera.renderers.PiRenderer.fullscreen"><code class="xref py py-attr docutils literal"><span class="pre">fullscreen</span></code></a>
attribute of the <a class="reference internal" href="#picamera.camera.PiCamera.preview" title="picamera.camera.PiCamera.preview"><code class="xref py py-attr docutils literal"><span class="pre">preview</span></code></a> object instead.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.preview_layer">
<code class="descname">preview_layer</code><a class="headerlink" href="#picamera.camera.PiCamera.preview_layer" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves of sets the layer of the preview window.</p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 1.8: </span>Please use the <a class="reference internal" href="index.html#picamera.renderers.PiRenderer.layer" title="picamera.renderers.PiRenderer.layer"><code class="xref py py-attr docutils literal"><span class="pre">layer</span></code></a>
attribute of the <a class="reference internal" href="#picamera.camera.PiCamera.preview" title="picamera.camera.PiCamera.preview"><code class="xref py py-attr docutils literal"><span class="pre">preview</span></code></a> object instead.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.preview_window">
<code class="descname">preview_window</code><a class="headerlink" href="#picamera.camera.PiCamera.preview_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the size of the preview window.</p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 1.8: </span>Please use the <a class="reference internal" href="index.html#picamera.renderers.PiRenderer.window" title="picamera.renderers.PiRenderer.window"><code class="xref py py-attr docutils literal"><span class="pre">window</span></code></a>
attribute of the <a class="reference internal" href="#picamera.camera.PiCamera.preview" title="picamera.camera.PiCamera.preview"><code class="xref py py-attr docutils literal"><span class="pre">preview</span></code></a> object instead.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.previewing">
<code class="descname">previewing</code><a class="headerlink" href="#picamera.camera.PiCamera.previewing" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code> if the <a class="reference internal" href="#picamera.camera.PiCamera.start_preview" title="picamera.camera.PiCamera.start_preview"><code class="xref py py-meth docutils literal"><span class="pre">start_preview()</span></code></a> method has been called,
and no <a class="reference internal" href="#picamera.camera.PiCamera.stop_preview" title="picamera.camera.PiCamera.stop_preview"><code class="xref py py-meth docutils literal"><span class="pre">stop_preview()</span></code></a> call has been made yet.</p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 1.8: </span>Test whether <a class="reference internal" href="#picamera.camera.PiCamera.preview" title="picamera.camera.PiCamera.preview"><code class="xref py py-attr docutils literal"><span class="pre">preview</span></code></a> is <code class="docutils literal"><span class="pre">None</span></code> instead.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.raw_format">
<code class="descname">raw_format</code><a class="headerlink" href="#picamera.camera.PiCamera.raw_format" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the raw format of the camera&#8217;s ports.</p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 1.0: </span>Please use <code class="docutils literal"><span class="pre">'yuv'</span></code> or <code class="docutils literal"><span class="pre">'rgb'</span></code> directly as a format in the
various capture methods instead.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.recording">
<code class="descname">recording</code><a class="headerlink" href="#picamera.camera.PiCamera.recording" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code> if the <a class="reference internal" href="#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> method has been called,
and no <a class="reference internal" href="#picamera.camera.PiCamera.stop_recording" title="picamera.camera.PiCamera.stop_recording"><code class="xref py py-meth docutils literal"><span class="pre">stop_recording()</span></code></a> call has been made yet.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.resolution">
<code class="descname">resolution</code><a class="headerlink" href="#picamera.camera.PiCamera.resolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the resolution at which image captures, video
recordings, and previews will be captured.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.resolution" title="picamera.camera.PiCamera.resolution"><code class="xref py py-attr docutils literal"><span class="pre">resolution</span></code></a> property returns the resolution at
which the camera will operate as a tuple of <code class="docutils literal"><span class="pre">(width,</span> <span class="pre">height)</span></code>
measured in pixels. This is the resolution that the <a class="reference internal" href="#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a>
method will produce images at, and the resolution that
<a class="reference internal" href="#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> will produce videos at.</p>
<p>When set, the property reconfigures the camera so that the next call to
these methods will use the new resolution.  The resolution must be
specified as a <code class="docutils literal"><span class="pre">(width,</span> <span class="pre">height)</span></code> tuple, the camera must not be
closed, and no recording must be active when the property is set.</p>
<p>The property defaults to the Pi&#8217;s currently configured display
resolution unless the display has been disabled (with <cite>tvservice -o</cite>)
in which case it defaults to 1280x720 (720p).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This attribute, in combination with <a class="reference internal" href="#picamera.camera.PiCamera.framerate" title="picamera.camera.PiCamera.framerate"><code class="xref py py-attr docutils literal"><span class="pre">framerate</span></code></a>, determines
the mode that the camera operates in. The actual sensor framerate
and resolution used by the camera is influenced, but not directly
set, by this property. See <a class="reference internal" href="#picamera.camera.PiCamera.sensor_mode" title="picamera.camera.PiCamera.sensor_mode"><code class="xref py py-attr docutils literal"><span class="pre">sensor_mode</span></code></a> for more
information.</p>
</div>
<p>The initial value of this property can be specified with the
<em>resolution</em> parameter in the <a class="reference internal" href="#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a> constructor.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.rotation">
<code class="descname">rotation</code><a class="headerlink" href="#picamera.camera.PiCamera.rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the current rotation of the camera&#8217;s image.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.rotation" title="picamera.camera.PiCamera.rotation"><code class="xref py py-attr docutils literal"><span class="pre">rotation</span></code></a> property returns the rotation
applied to the image. Valid values are 0, 90, 180, and 270.</p>
<p>When set, the property changes the rotation applied to the camera&#8217;s
input. The property can be set while recordings or previews are in
progress. The default value is <code class="docutils literal"><span class="pre">0</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.saturation">
<code class="descname">saturation</code><a class="headerlink" href="#picamera.camera.PiCamera.saturation" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the saturation setting of the camera.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.saturation" title="picamera.camera.PiCamera.saturation"><code class="xref py py-attr docutils literal"><span class="pre">saturation</span></code></a> property returns the color
saturation of the camera as an integer between -100 and 100. When set,
the property adjusts the saturation of the camera. Saturation can be
adjusted while previews or recordings are in progress. The default
value is 0.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.sensor_mode">
<code class="descname">sensor_mode</code><a class="headerlink" href="#picamera.camera.PiCamera.sensor_mode" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the input mode of the camera&#8217;s sensor.</p>
<p>This is an advanced property which can be used to control the camera&#8217;s
sensor mode. By default, mode 0 is used which allows the camera to
automatically select an input mode based on the requested
<a class="reference internal" href="#picamera.camera.PiCamera.resolution" title="picamera.camera.PiCamera.resolution"><code class="xref py py-attr docutils literal"><span class="pre">resolution</span></code></a> and <a class="reference internal" href="#picamera.camera.PiCamera.framerate" title="picamera.camera.PiCamera.framerate"><code class="xref py py-attr docutils literal"><span class="pre">framerate</span></code></a>. Valid values are currently
between 0 and 7. The set of valid sensor modes (along with the
heuristic used to select one automatically) are detailed in the
<a class="reference internal" href="index.html#camera-modes"><span>Camera Modes</span></a> section of the documentation.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">At the time of writing, setting this property does nothing unless
the camera has been initialized with a sensor mode other than 0.
Furthermore, some mode transitions appear to require setting the
property twice (in a row). This appears to be a firmware
limitation.</p>
</div>
<p>The initial value of this property can be specified with the
<em>sensor_mode</em> parameter in the <a class="reference internal" href="#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a> constructor.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.9.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.sharpness">
<code class="descname">sharpness</code><a class="headerlink" href="#picamera.camera.PiCamera.sharpness" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the sharpness setting of the camera.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.sharpness" title="picamera.camera.PiCamera.sharpness"><code class="xref py py-attr docutils literal"><span class="pre">sharpness</span></code></a> property returns the sharpness
level of the camera (a measure of the amount of post-processing to
reduce or increase image sharpness) as an integer between -100 and 100.
When set, the property adjusts the sharpness of the camera. Sharpness
can be adjusted while previews or recordings are in progress. The
default value is 0.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.shutter_speed">
<code class="descname">shutter_speed</code><a class="headerlink" href="#picamera.camera.PiCamera.shutter_speed" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the shutter speed of the camera in microseconds.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.shutter_speed" title="picamera.camera.PiCamera.shutter_speed"><code class="xref py py-attr docutils literal"><span class="pre">shutter_speed</span></code></a> property returns the shutter
speed of the camera in microseconds, or 0 which indicates that the
speed will be automatically determined by the auto-exposure algorithm.
Faster shutter times naturally require greater amounts of illumination
and vice versa.</p>
<p>When set, the property adjusts the shutter speed of the camera, which
most obviously affects the illumination of subsequently captured
images. Shutter speed can be adjusted while previews or recordings are
running. The default value is 0 (auto).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You can query the <a class="reference internal" href="#picamera.camera.PiCamera.exposure_speed" title="picamera.camera.PiCamera.exposure_speed"><code class="xref py py-attr docutils literal"><span class="pre">exposure_speed</span></code></a> attribute to determine the
actual shutter speed being used when this attribute is set to 0.
Please note that this capability requires an up to date firmware
(#692 or later).</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In later firmwares, this attribute is limited by the value of the
<a class="reference internal" href="#picamera.camera.PiCamera.framerate" title="picamera.camera.PiCamera.framerate"><code class="xref py py-attr docutils literal"><span class="pre">framerate</span></code></a> attribute. For example, if framerate is set to
30fps, the shutter speed cannot be slower than 33,333µs (1/fps).</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.still_stats">
<code class="descname">still_stats</code><a class="headerlink" href="#picamera.camera.PiCamera.still_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets whether statistics will be calculated from still
frames or the prior preview frame.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.still_stats" title="picamera.camera.PiCamera.still_stats"><code class="xref py py-attr docutils literal"><span class="pre">still_stats</span></code></a> property returns a boolean value
indicating when scene statistics will be calculated for still captures
(that is, captures where the <em>use_video_port</em> parameter of
<a class="reference internal" href="#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a> is <code class="docutils literal"><span class="pre">False</span></code>).  When this property is <code class="docutils literal"><span class="pre">False</span></code> (the
default), statistics will be calculated from the preceding preview
frame (this also applies when the preview is not visible). When <cite>True</cite>,
statistics will be calculated from the captured image itself.</p>
<p>When set, the propetry controls when scene statistics will be
calculated for still captures. The property can be set while recordings
or previews are in progress. The default value is <code class="docutils literal"><span class="pre">False</span></code>.</p>
<p>The advantages to calculating scene statistics from the captured image
are that time between startup and capture is reduced as only the AGC
(automatic gain control) has to converge. The downside is that
processing time for captures increases and that white balance and gain
won&#8217;t necessarily match the preview.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.9.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.vflip">
<code class="descname">vflip</code><a class="headerlink" href="#picamera.camera.PiCamera.vflip" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets whether the camera&#8217;s output is vertically flipped.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.vflip" title="picamera.camera.PiCamera.vflip"><code class="xref py py-attr docutils literal"><span class="pre">vflip</span></code></a> property returns a boolean indicating
whether or not the camera&#8217;s output is vertically flipped. The property
can be set while recordings or previews are in progress. The default
value is <code class="docutils literal"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.video_denoise">
<code class="descname">video_denoise</code><a class="headerlink" href="#picamera.camera.PiCamera.video_denoise" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets whether denoise will be applied to video recordings.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.video_denoise" title="picamera.camera.PiCamera.video_denoise"><code class="xref py py-attr docutils literal"><span class="pre">video_denoise</span></code></a> property returns a boolean
value indicating whether or not the camera software will apply a
denoise algorithm to video recordings.</p>
<p>When set, the property activates or deactivates the denoise algorithm
for video recordings. The property can be set while recordings or
previews are in progress. The default value is <code class="docutils literal"><span class="pre">True</span></code>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 1.7.</span></p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.video_stabilization">
<code class="descname">video_stabilization</code><a class="headerlink" href="#picamera.camera.PiCamera.video_stabilization" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the video stabilization mode of the camera.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.video_stabilization" title="picamera.camera.PiCamera.video_stabilization"><code class="xref py py-attr docutils literal"><span class="pre">video_stabilization</span></code></a> property returns a
boolean value indicating whether or not the camera attempts to
compensate for motion.</p>
<p>When set, the property activates or deactivates video stabilization.
The property can be set while recordings or previews are in progress.
The default value is <code class="docutils literal"><span class="pre">False</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The built-in video stabilization only accounts for <a class="reference external" href="http://www.raspberrypi.org/phpBB3/viewtopic.php?p=342667&amp;sid=ec7d95e887ab74a90ffaab87888c48cd#p342667">vertical and
horizontal motion</a>, not rotation.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.camera.PiCamera.zoom">
<code class="descname">zoom</code><a class="headerlink" href="#picamera.camera.PiCamera.zoom" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the zoom applied to the camera&#8217;s input.</p>
<p>When queried, the <a class="reference internal" href="#picamera.camera.PiCamera.zoom" title="picamera.camera.PiCamera.zoom"><code class="xref py py-attr docutils literal"><span class="pre">zoom</span></code></a> property returns a <code class="docutils literal"><span class="pre">(x,</span> <span class="pre">y,</span> <span class="pre">w,</span> <span class="pre">h)</span></code>
tuple of floating point values ranging from 0.0 to 1.0, indicating the
proportion of the image to include in the output (this is also known as
the &#8220;Region of Interest&#8221; or ROI). The default value is <code class="docutils literal"><span class="pre">(0.0,</span> <span class="pre">0.0,</span>
<span class="pre">1.0,</span> <span class="pre">1.0)</span></code> which indicates that everything should be included. The
property can be set while recordings or previews are in progress.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<span id="document-api_encoders"></span><div class="section" id="module-picamera.encoders">
<span id="api-picamera-encoders-module"></span><span id="api-encoders"></span><h3>API - <code class="docutils literal"><span class="pre">picamera.encoders</span></code> Module<a class="headerlink" href="#module-picamera.encoders" title="Permalink to this headline">¶</a></h3>
<p>The encoders module defines encoder classes for use by the camera. Most users
will have no direct need to use these classes directly, but advanced users may
find them useful as base classes for <a class="reference internal" href="index.html#custom-encoders"><span>Custom encoders</span></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All classes in this module are available from the <a class="reference internal" href="index.html#module-picamera" title="picamera"><code class="xref py py-mod docutils literal"><span class="pre">picamera</span></code></a> namespace
without having to import <a class="reference internal" href="#module-picamera.encoders" title="picamera.encoders"><code class="xref py py-mod docutils literal"><span class="pre">picamera.encoders</span></code></a> directly.</p>
</div>
<p>The following classes are defined in the module:</p>
<div class="section" id="pivideoframetype">
<h4>PiVideoFrameType<a class="headerlink" href="#pivideoframetype" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.encoders.PiVideoFrameType">
<em class="property">class </em><code class="descclassname">picamera.encoders.</code><code class="descname">PiVideoFrameType</code><a class="reference internal" href="_modules/picamera/encoders.html#PiVideoFrameType"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiVideoFrameType" title="Permalink to this definition">¶</a></dt>
<dd><p>This class simply defines constants used to represent the type of a frame
in <a class="reference internal" href="#picamera.encoders.PiVideoFrame.frame_type" title="picamera.encoders.PiVideoFrame.frame_type"><code class="xref py py-attr docutils literal"><span class="pre">PiVideoFrame.frame_type</span></code></a>. Effectively it is a namespace for an
enum.</p>
<dl class="attribute">
<dt id="picamera.encoders.PiVideoFrameType.frame">
<code class="descname">frame</code><a class="headerlink" href="#picamera.encoders.PiVideoFrameType.frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates a predicted frame (P-frame). This is the most common frame
type.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.encoders.PiVideoFrameType.key_frame">
<code class="descname">key_frame</code><a class="headerlink" href="#picamera.encoders.PiVideoFrameType.key_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates an intra-frame (I-frame) also known as a key frame.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.encoders.PiVideoFrameType.sps_header">
<code class="descname">sps_header</code><a class="headerlink" href="#picamera.encoders.PiVideoFrameType.sps_header" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates an inline SPS/PPS header (rather than picture data) which is
typically used as a split point.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.encoders.PiVideoFrameType.motion_data">
<code class="descname">motion_data</code><a class="headerlink" href="#picamera.encoders.PiVideoFrameType.motion_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates the frame is inline motion vector data, rather than picture
data.</p>
</dd></dl>

<div class="versionadded">
<p><span class="versionmodified">New in version 1.5.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="pivideoframe">
<h4>PiVideoFrame<a class="headerlink" href="#pivideoframe" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.encoders.PiVideoFrame">
<em class="property">class </em><code class="descclassname">picamera.encoders.</code><code class="descname">PiVideoFrame</code><span class="sig-paren">(</span><em>index</em>, <em>frame_type</em>, <em>frame_size</em>, <em>video_size</em>, <em>split_size</em>, <em>timestamp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiVideoFrame"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiVideoFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is a namedtuple derivative used to store information about a
video frame. It is recommended that you access the information stored by
this class by attribute name rather than position (for example:
<code class="docutils literal"><span class="pre">frame.index</span></code> rather than <code class="docutils literal"><span class="pre">frame[0]</span></code>).</p>
<dl class="attribute">
<dt id="picamera.encoders.PiVideoFrame.index">
<code class="descname">index</code><a class="headerlink" href="#picamera.encoders.PiVideoFrame.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the zero-based number of the frame. This is a monotonic counter
that is simply incremented every time the camera starts outputting a
new frame. As a consequence, this attribute cannot be used to detect
dropped frames. Nor does it necessarily represent actual frames; it
will be incremented for SPS headers and motion data buffers too.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.encoders.PiVideoFrame.frame_type">
<code class="descname">frame_type</code><a class="headerlink" href="#picamera.encoders.PiVideoFrame.frame_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant indicating the kind of data that the frame contains
(see <a class="reference internal" href="#picamera.encoders.PiVideoFrameType" title="picamera.encoders.PiVideoFrameType"><code class="xref py py-class docutils literal"><span class="pre">PiVideoFrameType</span></code></a>). Please note that certain frame types
contain no image data at all.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.encoders.PiVideoFrame.frame_size">
<code class="descname">frame_size</code><a class="headerlink" href="#picamera.encoders.PiVideoFrame.frame_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the size in bytes of the current frame. If a frame is written
in multiple chunks, this value will increment while <a class="reference internal" href="#picamera.encoders.PiVideoFrame.index" title="picamera.encoders.PiVideoFrame.index"><code class="xref py py-attr docutils literal"><span class="pre">index</span></code></a>
remains static. Query <a class="reference internal" href="#picamera.encoders.PiVideoFrame.complete" title="picamera.encoders.PiVideoFrame.complete"><code class="xref py py-attr docutils literal"><span class="pre">complete</span></code></a> to determine whether the frame
has been completely output yet.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.encoders.PiVideoFrame.video_size">
<code class="descname">video_size</code><a class="headerlink" href="#picamera.encoders.PiVideoFrame.video_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the size in bytes of the entire video up to the current frame.
Note that this is unlikely to match the size of the actual file/stream
written so far. This is because a stream may utilize buffering which
will cause the actual amount written (e.g. to disk) to lag behind the
value reported by this attribute.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.encoders.PiVideoFrame.split_size">
<code class="descname">split_size</code><a class="headerlink" href="#picamera.encoders.PiVideoFrame.split_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the size in bytes of the video recorded since the last call to
either <a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> or
<a class="reference internal" href="index.html#picamera.camera.PiCamera.split_recording" title="picamera.camera.PiCamera.split_recording"><code class="xref py py-meth docutils literal"><span class="pre">split_recording()</span></code></a>. For the reasons
explained above, this may differ from the size of the actual
file/stream written so far.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.encoders.PiVideoFrame.timestamp">
<code class="descname">timestamp</code><a class="headerlink" href="#picamera.encoders.PiVideoFrame.timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the presentation timestamp (PTS) of the current frame as
reported by the encoder. This is represented by the number of
microseconds (millionths of a second) since video recording started. As
the frame attribute is only updated when the encoder outputs the end of
a frame, this value may lag behind the actual time since
<a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> was called.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Currently, the video encoder occasionally returns &#8220;time unknown&#8221;
values in this field which picamera represents as <code class="docutils literal"><span class="pre">None</span></code>. If you
are querying this property you will need to check the value is not
<code class="docutils literal"><span class="pre">None</span></code> before using it.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.encoders.PiVideoFrame.complete">
<code class="descname">complete</code><a class="headerlink" href="#picamera.encoders.PiVideoFrame.complete" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a bool indicating whether the current frame is complete or not.
If the frame is complete then <a class="reference internal" href="#picamera.encoders.PiVideoFrame.frame_size" title="picamera.encoders.PiVideoFrame.frame_size"><code class="xref py py-attr docutils literal"><span class="pre">frame_size</span></code></a> will not increment
any further, and will reset for the next frame.</p>
</dd></dl>

<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.5: </span>Deprecated <a class="reference internal" href="#picamera.encoders.PiVideoFrame.header" title="picamera.encoders.PiVideoFrame.header"><code class="xref py py-attr docutils literal"><span class="pre">header</span></code></a> and <a class="reference internal" href="#picamera.encoders.PiVideoFrame.keyframe" title="picamera.encoders.PiVideoFrame.keyframe"><code class="xref py py-attr docutils literal"><span class="pre">keyframe</span></code></a> attributes and added the
new <a class="reference internal" href="#picamera.encoders.PiVideoFrame.frame_type" title="picamera.encoders.PiVideoFrame.frame_type"><code class="xref py py-attr docutils literal"><span class="pre">frame_type</span></code></a> attribute instead.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 1.9: </span>Added the <a class="reference internal" href="#picamera.encoders.PiVideoFrame.complete" title="picamera.encoders.PiVideoFrame.complete"><code class="xref py py-attr docutils literal"><span class="pre">complete</span></code></a> attribute.</p>
</div>
<dl class="attribute">
<dt id="picamera.encoders.PiVideoFrame.header">
<code class="descname">header</code><a class="headerlink" href="#picamera.encoders.PiVideoFrame.header" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains a bool indicating whether the current frame is actually an
SPS/PPS header. Typically it is best to split an H.264 stream so that
it starts with an SPS/PPS header.</p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 1.5: </span>Please compare <a class="reference internal" href="#picamera.encoders.PiVideoFrame.frame_type" title="picamera.encoders.PiVideoFrame.frame_type"><code class="xref py py-attr docutils literal"><span class="pre">frame_type</span></code></a> to
<a class="reference internal" href="#picamera.encoders.PiVideoFrameType.sps_header" title="picamera.encoders.PiVideoFrameType.sps_header"><code class="xref py py-attr docutils literal"><span class="pre">PiVideoFrameType.sps_header</span></code></a> instead.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.encoders.PiVideoFrame.keyframe">
<code class="descname">keyframe</code><a class="headerlink" href="#picamera.encoders.PiVideoFrame.keyframe" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a bool indicating whether the current frame is a keyframe (an
intra-frame, or I-frame in MPEG parlance).</p>
<div class="deprecated">
<p><span class="versionmodified">Deprecated since version 1.5: </span>Please compare <a class="reference internal" href="#picamera.encoders.PiVideoFrame.frame_type" title="picamera.encoders.PiVideoFrame.frame_type"><code class="xref py py-attr docutils literal"><span class="pre">frame_type</span></code></a> to
<a class="reference internal" href="#picamera.encoders.PiVideoFrameType.key_frame" title="picamera.encoders.PiVideoFrameType.key_frame"><code class="xref py py-attr docutils literal"><span class="pre">PiVideoFrameType.key_frame</span></code></a> instead.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.encoders.PiVideoFrame.position">
<code class="descname">position</code><a class="headerlink" href="#picamera.encoders.PiVideoFrame.position" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the zero-based position of the frame in the stream containing
it.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="piencoder">
<h4>PiEncoder<a class="headerlink" href="#piencoder" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.encoders.PiEncoder">
<em class="property">class </em><code class="descclassname">picamera.encoders.</code><code class="descname">PiEncoder</code><span class="sig-paren">(</span><em>parent</em>, <em>camera_port</em>, <em>input_port</em>, <em>format</em>, <em>resize</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Base implementation of an MMAL encoder for use by PiCamera.</p>
<p>The <em>parent</em> parameter specifies the <a class="reference internal" href="index.html#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a>
instance that has constructed the encoder. The <em>camera_port</em> parameter
provides the MMAL camera port that the encoder should enable for capture
(this will be the still or video port of the camera component). The
<em>input_port</em> parameter specifies the MMAL port that the encoder should
connect to its input.  Sometimes this will be the same as the camera port,
but if other components are present in the pipeline (e.g. a splitter), it
may be different.</p>
<p>The <em>format</em> parameter specifies the format that the encoder should
produce in its output. This is specified as a string and will be one of
the following for image encoders:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'jpeg'</span></code></li>
<li><code class="docutils literal"><span class="pre">'png'</span></code></li>
<li><code class="docutils literal"><span class="pre">'gif'</span></code></li>
<li><code class="docutils literal"><span class="pre">'bmp'</span></code></li>
<li><code class="docutils literal"><span class="pre">'yuv'</span></code></li>
<li><code class="docutils literal"><span class="pre">'rgb'</span></code></li>
<li><code class="docutils literal"><span class="pre">'rgba'</span></code></li>
<li><code class="docutils literal"><span class="pre">'bgr'</span></code></li>
<li><code class="docutils literal"><span class="pre">'bgra'</span></code></li>
</ul>
<p>And one of the following for video encoders:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">'h264'</span></code></li>
<li><code class="docutils literal"><span class="pre">'mjpeg'</span></code></li>
</ul>
<p>The <em>resize</em> parameter is either <code class="docutils literal"><span class="pre">None</span></code> (indicating no resizing
should take place), or a <code class="docutils literal"><span class="pre">(width,</span> <span class="pre">height)</span></code> tuple specifying the
resolution that the output of the encoder should be resized to.</p>
<p>Finally, the <em>options</em> parameter specifies additional keyword arguments
that can be used to configure the encoder (e.g. bitrate for videos, or
quality for images).</p>
<p>The class has a number of attributes:</p>
<dl class="attribute">
<dt id="picamera.encoders.PiEncoder.camera_port">
<code class="descname">camera_port</code><a class="headerlink" href="#picamera.encoders.PiEncoder.camera_port" title="Permalink to this definition">¶</a></dt>
<dd><p>A pointer to the camera output port that needs to be activated and
deactivated in order to start/stop capture. This is not necessarily the
port that the encoder component&#8217;s input port is connected to (for
example, in the case of video-port based captures, this will be the
camera video port behind the splitter).</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.encoders.PiEncoder.encoder">
<code class="descname">encoder</code><a class="headerlink" href="#picamera.encoders.PiEncoder.encoder" title="Permalink to this definition">¶</a></dt>
<dd><p>A pointer to the MMAL encoder component, or None if no encoder
component has been created (some encoder classes don&#8217;t use an actual
encoder component, for example <a class="reference internal" href="#picamera.encoders.PiRawImageMixin" title="picamera.encoders.PiRawImageMixin"><code class="xref py py-class docutils literal"><span class="pre">PiRawImageMixin</span></code></a>).</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.encoders.PiEncoder.encoder_connection">
<code class="descname">encoder_connection</code><a class="headerlink" href="#picamera.encoders.PiEncoder.encoder_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>A pointer to the MMAL connection linking the encoder&#8217;s input port to
the camera, splitter, or resizer output port (depending on
configuration), if any.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.encoders.PiEncoder.event">
<code class="descname">event</code><a class="headerlink" href="#picamera.encoders.PiEncoder.event" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference external" href="http://docs.python.org/3.2/library/threading.html#threading.Event" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">threading.Event</span></code></a> instance used to synchronize operations
(like start, stop, and split) between the control thread and the
callback thread.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.encoders.PiEncoder.exception">
<code class="descname">exception</code><a class="headerlink" href="#picamera.encoders.PiEncoder.exception" title="Permalink to this definition">¶</a></dt>
<dd><p>If an exception occurs during the encoder callback, this attribute is
used to store the exception until it can be re-raised in the control
thread.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.encoders.PiEncoder.format">
<code class="descname">format</code><a class="headerlink" href="#picamera.encoders.PiEncoder.format" title="Permalink to this definition">¶</a></dt>
<dd><p>The image or video format that the encoder is expected to produce. This
is equal to the value of the <em>format</em> parameter.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.encoders.PiEncoder.input_port">
<code class="descname">input_port</code><a class="headerlink" href="#picamera.encoders.PiEncoder.input_port" title="Permalink to this definition">¶</a></dt>
<dd><p>A pointer to the MMAL port that the encoder component&#8217;s input port
should be connected to.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.encoders.PiEncoder.output_port">
<code class="descname">output_port</code><a class="headerlink" href="#picamera.encoders.PiEncoder.output_port" title="Permalink to this definition">¶</a></dt>
<dd><p>A pointer to the MMAL port of the encoder&#8217;s output. In the case no
encoder component is created, this should be the camera/component
output port responsible for producing data. In other words, this
attribute <strong>must</strong> be set on initialization.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.encoders.PiEncoder.outputs">
<code class="descname">outputs</code><a class="headerlink" href="#picamera.encoders.PiEncoder.outputs" title="Permalink to this definition">¶</a></dt>
<dd><p>A mapping of <code class="docutils literal"><span class="pre">key</span></code> to <code class="docutils literal"><span class="pre">(output,</span> <span class="pre">opened)</span></code> tuples where <code class="docutils literal"><span class="pre">output</span></code>
is a file-like object, and <code class="docutils literal"><span class="pre">opened</span></code> is a bool indicating whether or
not we opened the output object (and thus whether we are responsible
for eventually closing it).</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.encoders.PiEncoder.outputs_lock">
<code class="descname">outputs_lock</code><a class="headerlink" href="#picamera.encoders.PiEncoder.outputs_lock" title="Permalink to this definition">¶</a></dt>
<dd><p>A <a class="reference external" href="http://docs.python.org/3.2/library/threading.html#threading.Lock" title="(in Python v3.2)"><code class="xref py py-func docutils literal"><span class="pre">threading.Lock()</span></code></a> instance used to protect access to
<a class="reference internal" href="#picamera.encoders.PiEncoder.outputs" title="picamera.encoders.PiEncoder.outputs"><code class="xref py py-attr docutils literal"><span class="pre">outputs</span></code></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.encoders.PiEncoder.parent">
<code class="descname">parent</code><a class="headerlink" href="#picamera.encoders.PiEncoder.parent" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="index.html#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a> instance that created this
PiEncoder instance.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.encoders.PiEncoder.pool">
<code class="descname">pool</code><a class="headerlink" href="#picamera.encoders.PiEncoder.pool" title="Permalink to this definition">¶</a></dt>
<dd><p>A pointer to a pool of MMAL buffers.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.encoders.PiEncoder.resizer">
<code class="descname">resizer</code><a class="headerlink" href="#picamera.encoders.PiEncoder.resizer" title="Permalink to this definition">¶</a></dt>
<dd><p>A pointer to the MMAL resizer component, or None if no resizer
component has been created.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.encoders.PiEncoder.resizer_connection">
<code class="descname">resizer_connection</code><a class="headerlink" href="#picamera.encoders.PiEncoder.resizer_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>A pointer to the MMAL connection linking the resizer&#8217;s input port to
the camera or splitter&#8217;s output port, if any.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.encoders.PiEncoder._callback">
<code class="descname">_callback</code><span class="sig-paren">(</span><em>port</em>, <em>buf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiEncoder._callback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiEncoder._callback" title="Permalink to this definition">¶</a></dt>
<dd><p>The encoder&#8217;s main callback function.</p>
<p>When the encoder is active, this method is periodically called in a
background thread. The <em>port</em> parameter specifies the MMAL port
providing the output (typically this is the encoder&#8217;s output port, but
in the case of unencoded captures may simply be a camera port), while
the <em>buf</em> parameter is an MMAL buffer header pointer which can be used
to obtain the data to write, along with meta-data about the current
frame.</p>
<p>This method <em>must</em> release the MMAL buffer header before returning
(failure to do so will cause a lockup), and should recycle buffers if
expecting further data (the <a class="reference internal" href="#picamera.encoders.PiEncoder._callback_recycle" title="picamera.encoders.PiEncoder._callback_recycle"><code class="xref py py-meth docutils literal"><span class="pre">_callback_recycle()</span></code></a> method can be
called to perform the latter duty). Finally, this method must set
<a class="reference internal" href="#picamera.encoders.PiEncoder.event" title="picamera.encoders.PiEncoder.event"><code class="xref py py-attr docutils literal"><span class="pre">event</span></code></a> when the encoder has finished (and should set
<a class="reference internal" href="#picamera.encoders.PiEncoder.exception" title="picamera.encoders.PiEncoder.exception"><code class="xref py py-attr docutils literal"><span class="pre">exception</span></code></a> if an exception occurred during encoding).</p>
<p>Developers wishing to write a custom encoder class may find it simpler
to override the <a class="reference internal" href="#picamera.encoders.PiEncoder._callback_write" title="picamera.encoders.PiEncoder._callback_write"><code class="xref py py-meth docutils literal"><span class="pre">_callback_write()</span></code></a> method, rather than deal with
these complexities.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.encoders.PiEncoder._callback_recycle">
<code class="descname">_callback_recycle</code><span class="sig-paren">(</span><em>port</em>, <em>buf</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiEncoder._callback_recycle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiEncoder._callback_recycle" title="Permalink to this definition">¶</a></dt>
<dd><p>Recycles the buffer on behalf of the encoder callback function.</p>
<p>This method is called by <a class="reference internal" href="#picamera.encoders.PiEncoder._callback" title="picamera.encoders.PiEncoder._callback"><code class="xref py py-meth docutils literal"><span class="pre">_callback()</span></code></a> when there is a buffer to
recycle (because further output is expected). It is unlikely descendent
classes will have a need to override this method, but if they override
the <a class="reference internal" href="#picamera.encoders.PiEncoder._callback" title="picamera.encoders.PiEncoder._callback"><code class="xref py py-meth docutils literal"><span class="pre">_callback()</span></code></a> method they may wish to call it.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.encoders.PiEncoder._callback_write">
<code class="descname">_callback_write</code><span class="sig-paren">(</span><em>buf</em>, <em>key=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiEncoder._callback_write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiEncoder._callback_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes output on behalf of the encoder callback function.</p>
<p>This method is called by <a class="reference internal" href="#picamera.encoders.PiEncoder._callback" title="picamera.encoders.PiEncoder._callback"><code class="xref py py-meth docutils literal"><span class="pre">_callback()</span></code></a> to handle writing to an
object in <a class="reference internal" href="#picamera.encoders.PiEncoder.outputs" title="picamera.encoders.PiEncoder.outputs"><code class="xref py py-attr docutils literal"><span class="pre">outputs</span></code></a> identified by <em>key</em>. The <em>buf</em> parameter is
an MMAL buffer header pointer which can be used to obtain the length of
data available (<code class="docutils literal"><span class="pre">buf[0].length</span></code>), a pointer to the data
(<code class="docutils literal"><span class="pre">buf[0].data</span></code>) which should typically be used with
<a class="reference external" href="http://docs.python.org/3.2/library/ctypes.html#ctypes.string_at" title="(in Python v3.2)"><code class="xref py py-func docutils literal"><span class="pre">ctypes.string_at()</span></code></a>, and meta-data about the contents of the
buffer (<code class="docutils literal"><span class="pre">buf[0].flags</span></code>). The method is expected to return a boolean
to indicate whether output is complete (<code class="docutils literal"><span class="pre">True</span></code>) or whether more data
is expected (<code class="docutils literal"><span class="pre">False</span></code>).</p>
<p>The default implementation simply writes the contents of the buffer to
the output identified by <em>key</em>, and returns <code class="docutils literal"><span class="pre">True</span></code> if the buffer
flags indicate end of stream. Image encoders will typically override
the return value to indicate <code class="docutils literal"><span class="pre">True</span></code> on end of frame (as they only
wish to output a single image). Video encoders will typically override
this method to determine where key-frames and SPS headers occur.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.encoders.PiEncoder._close_output">
<code class="descname">_close_output</code><span class="sig-paren">(</span><em>key=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiEncoder._close_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiEncoder._close_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Closes the output associated with <em>key</em> in <a class="reference internal" href="#picamera.encoders.PiEncoder.outputs" title="picamera.encoders.PiEncoder.outputs"><code class="xref py py-attr docutils literal"><span class="pre">outputs</span></code></a>.</p>
<p>Closes the output object associated with the specified <em>key</em>, and
removes it from the <a class="reference internal" href="#picamera.encoders.PiEncoder.outputs" title="picamera.encoders.PiEncoder.outputs"><code class="xref py py-attr docutils literal"><span class="pre">outputs</span></code></a> dictionary (if we didn&#8217;t open the
object then we attempt to flush it instead).</p>
</dd></dl>

<dl class="method">
<dt id="picamera.encoders.PiEncoder._create_connections">
<code class="descname">_create_connections</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiEncoder._create_connections"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiEncoder._create_connections" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates all connections between MMAL components.</p>
<p>This method is called to connect the encoder and the optional resizer
to the input port provided by the camera. It sets the
<a class="reference internal" href="#picamera.encoders.PiEncoder.encoder_connection" title="picamera.encoders.PiEncoder.encoder_connection"><code class="xref py py-attr docutils literal"><span class="pre">encoder_connection</span></code></a> and <a class="reference internal" href="#picamera.encoders.PiEncoder.resizer_connection" title="picamera.encoders.PiEncoder.resizer_connection"><code class="xref py py-attr docutils literal"><span class="pre">resizer_connection</span></code></a> attributes as
required.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.encoders.PiEncoder._create_encoder">
<code class="descname">_create_encoder</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiEncoder._create_encoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiEncoder._create_encoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates and configures the MMAL encoder component.</p>
<p>This method only constructs the encoder; it does not connect it to the
input port. The method sets the <a class="reference internal" href="#picamera.encoders.PiEncoder.encoder" title="picamera.encoders.PiEncoder.encoder"><code class="xref py py-attr docutils literal"><span class="pre">encoder</span></code></a> attribute to the
constructed encoder component, and the <a class="reference internal" href="#picamera.encoders.PiEncoder.output_port" title="picamera.encoders.PiEncoder.output_port"><code class="xref py py-attr docutils literal"><span class="pre">output_port</span></code></a> attribute to
the encoder&#8217;s output port (or the previously constructed resizer&#8217;s
output port if one has been requested). Descendent classes extend this
method to finalize encoder configuration.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It should be noted that this method is called with the
initializer&#8217;s <code class="docutils literal"><span class="pre">option</span></code> keyword arguments. This base
implementation expects no additional arguments, but descendent
classes extend the parameter list to include options relevant to
them.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="picamera.encoders.PiEncoder._create_pool">
<code class="descname">_create_pool</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiEncoder._create_pool"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiEncoder._create_pool" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocates a pool of MMAL buffers for the encoder.</p>
<p>This method is expected to construct an MMAL pool of buffers for the
<a class="reference internal" href="#picamera.encoders.PiEncoder.output_port" title="picamera.encoders.PiEncoder.output_port"><code class="xref py py-attr docutils literal"><span class="pre">output_port</span></code></a>, and store the result in the <a class="reference internal" href="#picamera.encoders.PiEncoder.pool" title="picamera.encoders.PiEncoder.pool"><code class="xref py py-attr docutils literal"><span class="pre">pool</span></code></a>
attribute.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.encoders.PiEncoder._create_resizer">
<code class="descname">_create_resizer</code><span class="sig-paren">(</span><em>width</em>, <em>height</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiEncoder._create_resizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiEncoder._create_resizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates and configures an MMAL resizer component.</p>
<p>This is called when the initializer&#8217;s <em>resize</em> parameter is something
other than <code class="docutils literal"><span class="pre">None</span></code>. The <em>width</em> and <em>height</em> parameters are passed to
the constructed resizer. Note that this method only constructs the
resizer - it does not connect it to the encoder. The method sets the
<a class="reference internal" href="#picamera.encoders.PiEncoder.resizer" title="picamera.encoders.PiEncoder.resizer"><code class="xref py py-attr docutils literal"><span class="pre">resizer</span></code></a> attribute to the constructed resizer component.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.encoders.PiEncoder._open_output">
<code class="descname">_open_output</code><span class="sig-paren">(</span><em>output</em>, <em>key=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiEncoder._open_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiEncoder._open_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Opens <em>output</em> and associates it with <em>key</em> in <a class="reference internal" href="#picamera.encoders.PiEncoder.outputs" title="picamera.encoders.PiEncoder.outputs"><code class="xref py py-attr docutils literal"><span class="pre">outputs</span></code></a>.</p>
<p>If <em>output</em> is a string, this method opens it as a filename and keeps
track of the fact that the encoder was the one to open it (which
implies that <a class="reference internal" href="#picamera.encoders.PiEncoder._close_output" title="picamera.encoders.PiEncoder._close_output"><code class="xref py py-meth docutils literal"><span class="pre">_close_output()</span></code></a> should eventually close it).
Otherwise, <em>output</em> is assumed to be a file-like object and is used
verbatim. The opened output is added to the <a class="reference internal" href="#picamera.encoders.PiEncoder.outputs" title="picamera.encoders.PiEncoder.outputs"><code class="xref py py-attr docutils literal"><span class="pre">outputs</span></code></a> dictionary
with the specified <em>key</em>.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.encoders.PiEncoder.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiEncoder.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiEncoder.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Finalizes the encoder and deallocates all structures.</p>
<p>This method is called by the camera prior to destroying the encoder (or
more precisely, letting it go out of scope to permit the garbage
collector to destroy it at some future time). The method destroys all
components that the various create methods constructed and resets their
attributes.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.encoders.PiEncoder.start">
<code class="descname">start</code><span class="sig-paren">(</span><em>output</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiEncoder.start"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiEncoder.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Starts the encoder object writing to the specified output.</p>
<p>This method is called by the camera to start the encoder capturing
data from the camera to the specified output. The <em>output</em> parameter
is either a filename, or a file-like object (for image and video
encoders), or an iterable of filenames or file-like objects (for
multi-image encoders).</p>
</dd></dl>

<dl class="method">
<dt id="picamera.encoders.PiEncoder.stop">
<code class="descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiEncoder.stop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiEncoder.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Stops the encoder, regardless of whether it&#8217;s finished.</p>
<p>This method is called by the camera to terminate the execution of the
encoder. Typically, this is used with video to stop the recording, but
can potentially be called in the middle of image capture to terminate
the capture.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.encoders.PiEncoder.wait">
<code class="descname">wait</code><span class="sig-paren">(</span><em>timeout=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiEncoder.wait"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiEncoder.wait" title="Permalink to this definition">¶</a></dt>
<dd><p>Waits for the encoder to finish (successfully or otherwise).</p>
<p>This method is called by the owning camera object to block execution
until the encoder has completed its task. If the <em>timeout</em> parameter
is None, the method will block indefinitely. Otherwise, the <em>timeout</em>
parameter specifies the (potentially fractional) number of seconds
to block for. If the encoder finishes successfully within the timeout,
the method returns <code class="docutils literal"><span class="pre">True</span></code>. Otherwise, it returns <code class="docutils literal"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.encoders.PiEncoder.active">
<code class="descname">active</code><a class="headerlink" href="#picamera.encoders.PiEncoder.active" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code> if the MMAL encoder exists and is enabled.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="pivideoencoder">
<h4>PiVideoEncoder<a class="headerlink" href="#pivideoencoder" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.encoders.PiVideoEncoder">
<em class="property">class </em><code class="descclassname">picamera.encoders.</code><code class="descname">PiVideoEncoder</code><span class="sig-paren">(</span><em>parent</em>, <em>camera_port</em>, <em>input_port</em>, <em>format</em>, <em>resize</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiVideoEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiVideoEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Encoder for video recording.</p>
<p>This derivative of <a class="reference internal" href="#picamera.encoders.PiEncoder" title="picamera.encoders.PiEncoder"><code class="xref py py-class docutils literal"><span class="pre">PiEncoder</span></code></a> configures itself for H.264 or MJPEG
encoding.  It also introduces a <a class="reference internal" href="#picamera.encoders.PiVideoEncoder.split" title="picamera.encoders.PiVideoEncoder.split"><code class="xref py py-meth docutils literal"><span class="pre">split()</span></code></a> method which is used by
<a class="reference internal" href="index.html#picamera.camera.PiCamera.split_recording" title="picamera.camera.PiCamera.split_recording"><code class="xref py py-meth docutils literal"><span class="pre">split_recording()</span></code></a> and
<a class="reference internal" href="index.html#picamera.camera.PiCamera.record_sequence" title="picamera.camera.PiCamera.record_sequence"><code class="xref py py-meth docutils literal"><span class="pre">record_sequence()</span></code></a> to redirect future output
to a new filename or object. Finally, it also extends
<a class="reference internal" href="#picamera.encoders.PiEncoder.start" title="picamera.encoders.PiEncoder.start"><code class="xref py py-meth docutils literal"><span class="pre">PiEncoder.start()</span></code></a> and <a class="reference internal" href="#picamera.encoders.PiEncoder._callback_write" title="picamera.encoders.PiEncoder._callback_write"><code class="xref py py-meth docutils literal"><span class="pre">PiEncoder._callback_write()</span></code></a> to track
video frame meta-data, and to permit recording motion data to a separate
output object.</p>
<dl class="method">
<dt id="picamera.encoders.PiVideoEncoder._callback_write">
<code class="descname">_callback_write</code><span class="sig-paren">(</span><em>buf</em>, <em>key=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiVideoEncoder._callback_write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiVideoEncoder._callback_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Extended to implement video frame meta-data tracking, and to handle
splitting video recording to the next output when <a class="reference internal" href="#picamera.encoders.PiVideoEncoder.split" title="picamera.encoders.PiVideoEncoder.split"><code class="xref py py-meth docutils literal"><span class="pre">split()</span></code></a> is
called.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.encoders.PiVideoEncoder._create_encoder">
<code class="descname">_create_encoder</code><span class="sig-paren">(</span><em>bitrate=17000000</em>, <em>intra_period=None</em>, <em>profile='high'</em>, <em>quantization=0</em>, <em>quality=0</em>, <em>inline_headers=True</em>, <em>sei=False</em>, <em>motion_output=None</em>, <em>intra_refresh=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiVideoEncoder._create_encoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiVideoEncoder._create_encoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Extends the base <a class="reference internal" href="#picamera.encoders.PiEncoder._create_encoder" title="picamera.encoders.PiEncoder._create_encoder"><code class="xref py py-meth docutils literal"><span class="pre">_create_encoder()</span></code></a> implementation to
configure the video encoder for H.264 or MJPEG output.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.encoders.PiVideoEncoder.split">
<code class="descname">split</code><span class="sig-paren">(</span><em>output</em>, <em>motion_output=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiVideoEncoder.split"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiVideoEncoder.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Called to switch the encoder&#8217;s output.</p>
<p>This method is called by
<a class="reference internal" href="index.html#picamera.camera.PiCamera.split_recording" title="picamera.camera.PiCamera.split_recording"><code class="xref py py-meth docutils literal"><span class="pre">split_recording()</span></code></a> and
<a class="reference internal" href="index.html#picamera.camera.PiCamera.record_sequence" title="picamera.camera.PiCamera.record_sequence"><code class="xref py py-meth docutils literal"><span class="pre">record_sequence()</span></code></a> to switch the
encoder&#8217;s <code class="xref py py-attr docutils literal"><span class="pre">output</span></code> object to the <em>output</em> parameter (which can be
a filename or a file-like object, as with <a class="reference internal" href="#picamera.encoders.PiVideoEncoder.start" title="picamera.encoders.PiVideoEncoder.start"><code class="xref py py-meth docutils literal"><span class="pre">start()</span></code></a>).</p>
</dd></dl>

<dl class="method">
<dt id="picamera.encoders.PiVideoEncoder.start">
<code class="descname">start</code><span class="sig-paren">(</span><em>output</em>, <em>motion_output=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiVideoEncoder.start"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiVideoEncoder.start" title="Permalink to this definition">¶</a></dt>
<dd><p>Extended to initialize video frame meta-data tracking.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="piimageencoder">
<h4>PiImageEncoder<a class="headerlink" href="#piimageencoder" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.encoders.PiImageEncoder">
<em class="property">class </em><code class="descclassname">picamera.encoders.</code><code class="descname">PiImageEncoder</code><span class="sig-paren">(</span><em>parent</em>, <em>camera_port</em>, <em>input_port</em>, <em>format</em>, <em>resize</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiImageEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiImageEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Encoder for image capture.</p>
<p>This derivative of <a class="reference internal" href="#picamera.encoders.PiEncoder" title="picamera.encoders.PiEncoder"><code class="xref py py-class docutils literal"><span class="pre">PiEncoder</span></code></a> extends the <a class="reference internal" href="#picamera.encoders.PiImageEncoder._create_encoder" title="picamera.encoders.PiImageEncoder._create_encoder"><code class="xref py py-meth docutils literal"><span class="pre">_create_encoder()</span></code></a>
method to configure the encoder for a variety of encoded image outputs
(JPEG, PNG, etc.).</p>
<dl class="method">
<dt id="picamera.encoders.PiImageEncoder._create_encoder">
<code class="descname">_create_encoder</code><span class="sig-paren">(</span><em>quality=85</em>, <em>thumbnail=(64</em>, <em>48</em>, <em>35)</em>, <em>bayer=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiImageEncoder._create_encoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiImageEncoder._create_encoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Extends the base <a class="reference internal" href="#picamera.encoders.PiEncoder._create_encoder" title="picamera.encoders.PiEncoder._create_encoder"><code class="xref py py-meth docutils literal"><span class="pre">_create_encoder()</span></code></a> implementation to
configure the image encoder for JPEG, PNG, etc.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="pirawmixin">
<h4>PiRawMixin<a class="headerlink" href="#pirawmixin" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.encoders.PiRawMixin">
<em class="property">class </em><code class="descclassname">picamera.encoders.</code><code class="descname">PiRawMixin</code><span class="sig-paren">(</span><em>parent</em>, <em>camera_port</em>, <em>input_port</em>, <em>format</em>, <em>resize</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiRawMixin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiRawMixin" title="Permalink to this definition">¶</a></dt>
<dd><p>Mixin class for &#8220;raw&#8221; (unencoded) output.</p>
<p>This mixin class overrides the initializer of <a class="reference internal" href="#picamera.encoders.PiEncoder" title="picamera.encoders.PiEncoder"><code class="xref py py-class docutils literal"><span class="pre">PiEncoder</span></code></a>, along
with <a class="reference internal" href="#picamera.encoders.PiRawMixin._create_resizer" title="picamera.encoders.PiRawMixin._create_resizer"><code class="xref py py-meth docutils literal"><span class="pre">_create_resizer()</span></code></a> and <a class="reference internal" href="#picamera.encoders.PiRawMixin._create_encoder" title="picamera.encoders.PiRawMixin._create_encoder"><code class="xref py py-meth docutils literal"><span class="pre">_create_encoder()</span></code></a> to configure the
pipeline for unencoded output. Specifically, it disables the construction
of an encoder, and sets the output port to the input port passed to the
initializer, unless resizing is required (either for actual resizing, or
for format conversion) in which case the resizer&#8217;s output is used.</p>
<dl class="method">
<dt id="picamera.encoders.PiRawMixin._callback_write">
<code class="descname">_callback_write</code><span class="sig-paren">(</span><em>buf</em>, <em>key=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiRawMixin._callback_write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiRawMixin._callback_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Overridden to strip alpha bytes when required.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.encoders.PiRawMixin._create_connections">
<code class="descname">_create_connections</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiRawMixin._create_connections"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiRawMixin._create_connections" title="Permalink to this definition">¶</a></dt>
<dd><p>Overridden to skip creating an encoder connection; only a resizer
connection is required (if one has been configured).</p>
</dd></dl>

<dl class="method">
<dt id="picamera.encoders.PiRawMixin._create_encoder">
<code class="descname">_create_encoder</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiRawMixin._create_encoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiRawMixin._create_encoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Overridden to skip creating an encoder. Instead, this class simply uses
the resizer&#8217;s port as the output port (if a resizer has been
configured) or the specified input port otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.encoders.PiRawMixin._create_resizer">
<code class="descname">_create_resizer</code><span class="sig-paren">(</span><em>width</em>, <em>height</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiRawMixin._create_resizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiRawMixin._create_resizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Overridden to configure the resizer&#8217;s output with the required
encoding.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="picookedvideoencoder">
<h4>PiCookedVideoEncoder<a class="headerlink" href="#picookedvideoencoder" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.encoders.PiCookedVideoEncoder">
<em class="property">class </em><code class="descclassname">picamera.encoders.</code><code class="descname">PiCookedVideoEncoder</code><span class="sig-paren">(</span><em>parent</em>, <em>camera_port</em>, <em>input_port</em>, <em>format</em>, <em>resize</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiCookedVideoEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiCookedVideoEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Video encoder for encoded recordings.</p>
<p>This class is a derivative of <a class="reference internal" href="#picamera.encoders.PiVideoEncoder" title="picamera.encoders.PiVideoEncoder"><code class="xref py py-class docutils literal"><span class="pre">PiVideoEncoder</span></code></a> and only exists to
provide naming symmetry with the image encoder classes.</p>
</dd></dl>

</div>
<div class="section" id="pirawvideoencoder">
<h4>PiRawVideoEncoder<a class="headerlink" href="#pirawvideoencoder" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.encoders.PiRawVideoEncoder">
<em class="property">class </em><code class="descclassname">picamera.encoders.</code><code class="descname">PiRawVideoEncoder</code><span class="sig-paren">(</span><em>parent</em>, <em>camera_port</em>, <em>input_port</em>, <em>format</em>, <em>resize</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiRawVideoEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiRawVideoEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Video encoder for unencoded recordings.</p>
<p>This class is a derivative of <a class="reference internal" href="#picamera.encoders.PiVideoEncoder" title="picamera.encoders.PiVideoEncoder"><code class="xref py py-class docutils literal"><span class="pre">PiVideoEncoder</span></code></a> and the
<a class="reference internal" href="#picamera.encoders.PiRawMixin" title="picamera.encoders.PiRawMixin"><code class="xref py py-class docutils literal"><span class="pre">PiRawMixin</span></code></a> class intended for use with
<a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> when it is called with an
unencoded format.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This class creates an inheritance diamond. Take care to determine the
MRO of super-class calls.</p>
</div>
</dd></dl>

</div>
<div class="section" id="pioneimageencoder">
<h4>PiOneImageEncoder<a class="headerlink" href="#pioneimageencoder" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.encoders.PiOneImageEncoder">
<em class="property">class </em><code class="descclassname">picamera.encoders.</code><code class="descname">PiOneImageEncoder</code><span class="sig-paren">(</span><em>parent</em>, <em>camera_port</em>, <em>input_port</em>, <em>format</em>, <em>resize</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiOneImageEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiOneImageEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Encoder for single image capture.</p>
<p>This class simply extends <a class="reference internal" href="#picamera.encoders.PiEncoder._callback_write" title="picamera.encoders.PiEncoder._callback_write"><code class="xref py py-meth docutils literal"><span class="pre">_callback_write()</span></code></a> to terminate
capture at frame end (i.e. after a single frame has been received).</p>
</dd></dl>

</div>
<div class="section" id="pimultiimageencoder">
<h4>PiMultiImageEncoder<a class="headerlink" href="#pimultiimageencoder" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.encoders.PiMultiImageEncoder">
<em class="property">class </em><code class="descclassname">picamera.encoders.</code><code class="descname">PiMultiImageEncoder</code><span class="sig-paren">(</span><em>parent</em>, <em>camera_port</em>, <em>input_port</em>, <em>format</em>, <em>resize</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiMultiImageEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiMultiImageEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Encoder for multiple image capture.</p>
<p>This class extends <a class="reference internal" href="#picamera.encoders.PiImageEncoder" title="picamera.encoders.PiImageEncoder"><code class="xref py py-class docutils literal"><span class="pre">PiImageEncoder</span></code></a> to handle an iterable of outputs
instead of a single output. The <a class="reference internal" href="#picamera.encoders.PiEncoder._callback_write" title="picamera.encoders.PiEncoder._callback_write"><code class="xref py py-meth docutils literal"><span class="pre">_callback_write()</span></code></a> method
is extended to terminate capture when the iterable is exhausted, while
<a class="reference internal" href="#picamera.encoders.PiEncoder._open_output" title="picamera.encoders.PiEncoder._open_output"><code class="xref py py-meth docutils literal"><span class="pre">PiEncoder._open_output()</span></code></a> is overridden to begin iteration and rely
on the new <a class="reference internal" href="#picamera.encoders.PiMultiImageEncoder._next_output" title="picamera.encoders.PiMultiImageEncoder._next_output"><code class="xref py py-meth docutils literal"><span class="pre">_next_output()</span></code></a> method to advance output to the next item
in the iterable.</p>
<dl class="method">
<dt id="picamera.encoders.PiMultiImageEncoder._next_output">
<code class="descname">_next_output</code><span class="sig-paren">(</span><em>key=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiMultiImageEncoder._next_output"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiMultiImageEncoder._next_output" title="Permalink to this definition">¶</a></dt>
<dd><p>This method moves output to the next item from the iterable passed to
<a class="reference internal" href="#picamera.encoders.PiEncoder.start" title="picamera.encoders.PiEncoder.start"><code class="xref py py-meth docutils literal"><span class="pre">start()</span></code></a>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="pirawimagemixin">
<h4>PiRawImageMixin<a class="headerlink" href="#pirawimagemixin" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.encoders.PiRawImageMixin">
<em class="property">class </em><code class="descclassname">picamera.encoders.</code><code class="descname">PiRawImageMixin</code><span class="sig-paren">(</span><em>parent</em>, <em>camera_port</em>, <em>input_port</em>, <em>format</em>, <em>resize</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiRawImageMixin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiRawImageMixin" title="Permalink to this definition">¶</a></dt>
<dd><p>Mixin class for &#8220;raw&#8221; (unencoded) image capture.</p>
<p>The <a class="reference internal" href="#picamera.encoders.PiRawImageMixin._callback_write" title="picamera.encoders.PiRawImageMixin._callback_write"><code class="xref py py-meth docutils literal"><span class="pre">_callback_write()</span></code></a> method is overridden to manually calculate when
to terminate output.</p>
<dl class="method">
<dt id="picamera.encoders.PiRawImageMixin._callback_write">
<code class="descname">_callback_write</code><span class="sig-paren">(</span><em>buf</em>, <em>key=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiRawImageMixin._callback_write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiRawImageMixin._callback_write" title="Permalink to this definition">¶</a></dt>
<dd><p>Overridden to manually calculate when to terminate capture (see
comments in <code class="xref py py-meth docutils literal"><span class="pre">__init__()</span></code>).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="picookedoneimageencoder">
<h4>PiCookedOneImageEncoder<a class="headerlink" href="#picookedoneimageencoder" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.encoders.PiCookedOneImageEncoder">
<em class="property">class </em><code class="descclassname">picamera.encoders.</code><code class="descname">PiCookedOneImageEncoder</code><span class="sig-paren">(</span><em>parent</em>, <em>camera_port</em>, <em>input_port</em>, <em>format</em>, <em>resize</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiCookedOneImageEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiCookedOneImageEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Encoder for &#8220;cooked&#8221; (encoded) single image output.</p>
<p>This encoder extends <a class="reference internal" href="#picamera.encoders.PiOneImageEncoder" title="picamera.encoders.PiOneImageEncoder"><code class="xref py py-class docutils literal"><span class="pre">PiOneImageEncoder</span></code></a> to include Exif tags in the
output.</p>
</dd></dl>

</div>
<div class="section" id="pirawoneimageencoder">
<h4>PiRawOneImageEncoder<a class="headerlink" href="#pirawoneimageencoder" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.encoders.PiRawOneImageEncoder">
<em class="property">class </em><code class="descclassname">picamera.encoders.</code><code class="descname">PiRawOneImageEncoder</code><span class="sig-paren">(</span><em>parent</em>, <em>camera_port</em>, <em>input_port</em>, <em>format</em>, <em>resize</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiRawOneImageEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiRawOneImageEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Single image encoder for unencoded capture.</p>
<p>This class is a derivative of <a class="reference internal" href="#picamera.encoders.PiOneImageEncoder" title="picamera.encoders.PiOneImageEncoder"><code class="xref py py-class docutils literal"><span class="pre">PiOneImageEncoder</span></code></a> and the
<a class="reference internal" href="#picamera.encoders.PiRawImageMixin" title="picamera.encoders.PiRawImageMixin"><code class="xref py py-class docutils literal"><span class="pre">PiRawImageMixin</span></code></a> class intended for use with
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a> (et al) when it is called with an
unencoded image format.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This class creates an inheritance diamond. Take care to determine the
MRO of super-class calls.</p>
</div>
</dd></dl>

</div>
<div class="section" id="picookedmultiimageencoder">
<h4>PiCookedMultiImageEncoder<a class="headerlink" href="#picookedmultiimageencoder" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.encoders.PiCookedMultiImageEncoder">
<em class="property">class </em><code class="descclassname">picamera.encoders.</code><code class="descname">PiCookedMultiImageEncoder</code><span class="sig-paren">(</span><em>parent</em>, <em>camera_port</em>, <em>input_port</em>, <em>format</em>, <em>resize</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiCookedMultiImageEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiCookedMultiImageEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Encoder for &#8220;cooked&#8221; (encoded) multiple image output.</p>
<p>This encoder descends from <a class="reference internal" href="#picamera.encoders.PiMultiImageEncoder" title="picamera.encoders.PiMultiImageEncoder"><code class="xref py py-class docutils literal"><span class="pre">PiMultiImageEncoder</span></code></a> but includes no
new functionality as video-port based encodes (which is all this class
is used for) don&#8217;t support Exif tag output.</p>
</dd></dl>

</div>
<div class="section" id="pirawmultiimageencoder">
<h4>PiRawMultiImageEncoder<a class="headerlink" href="#pirawmultiimageencoder" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.encoders.PiRawMultiImageEncoder">
<em class="property">class </em><code class="descclassname">picamera.encoders.</code><code class="descname">PiRawMultiImageEncoder</code><span class="sig-paren">(</span><em>parent</em>, <em>camera_port</em>, <em>input_port</em>, <em>format</em>, <em>resize</em>, <em>**options</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/encoders.html#PiRawMultiImageEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.encoders.PiRawMultiImageEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiple image encoder for unencoded capture.</p>
<p>This class is a derivative of <a class="reference internal" href="#picamera.encoders.PiMultiImageEncoder" title="picamera.encoders.PiMultiImageEncoder"><code class="xref py py-class docutils literal"><span class="pre">PiMultiImageEncoder</span></code></a> and the
<a class="reference internal" href="#picamera.encoders.PiRawImageMixin" title="picamera.encoders.PiRawImageMixin"><code class="xref py py-class docutils literal"><span class="pre">PiRawImageMixin</span></code></a> class intended for use with
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture_sequence" title="picamera.camera.PiCamera.capture_sequence"><code class="xref py py-meth docutils literal"><span class="pre">capture_sequence()</span></code></a> when it is called with
an unencoded image format.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This class creates an inheritance diamond. Take care to determine the
MRO of super-class calls.</p>
</div>
</dd></dl>

</div>
</div>
<span id="document-api_streams"></span><div class="section" id="module-picamera.streams">
<span id="api-picamera-streams-module"></span><span id="api-streams"></span><h3>API - <code class="docutils literal"><span class="pre">picamera.streams</span></code> Module<a class="headerlink" href="#module-picamera.streams" title="Permalink to this headline">¶</a></h3>
<p>The streams module defines stream classes suited to generating certain types of
camera output (beyond those provided by Python by default). Currently, this
consists primarily of <a class="reference internal" href="#picamera.streams.PiCameraCircularIO" title="picamera.streams.PiCameraCircularIO"><code class="xref py py-class docutils literal"><span class="pre">PiCameraCircularIO</span></code></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All classes in this module are available from the <a class="reference internal" href="index.html#module-picamera" title="picamera"><code class="xref py py-mod docutils literal"><span class="pre">picamera</span></code></a> namespace
without having to import <a class="reference internal" href="#module-picamera.streams" title="picamera.streams"><code class="xref py py-mod docutils literal"><span class="pre">picamera.streams</span></code></a> directly.</p>
</div>
<p>The following classes are defined in the module:</p>
<div class="section" id="picameracirculario">
<h4>PiCameraCircularIO<a class="headerlink" href="#picameracirculario" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.streams.PiCameraCircularIO">
<em class="property">class </em><code class="descclassname">picamera.streams.</code><code class="descname">PiCameraCircularIO</code><span class="sig-paren">(</span><em>camera</em>, <em>size=None</em>, <em>seconds=None</em>, <em>bitrate=17000000</em>, <em>splitter_port=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/streams.html#PiCameraCircularIO"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.streams.PiCameraCircularIO" title="Permalink to this definition">¶</a></dt>
<dd><p>A derivative of <a class="reference internal" href="#picamera.streams.CircularIO" title="picamera.streams.CircularIO"><code class="xref py py-class docutils literal"><span class="pre">CircularIO</span></code></a> which tracks camera frames.</p>
<p>PiCameraCircularIO provides an in-memory stream based on a ring buffer. It
is a specialization of <a class="reference internal" href="#picamera.streams.CircularIO" title="picamera.streams.CircularIO"><code class="xref py py-class docutils literal"><span class="pre">CircularIO</span></code></a> which associates video frame
meta-data with the recorded stream, accessible from the <a class="reference internal" href="#picamera.streams.PiCameraCircularIO.frames" title="picamera.streams.PiCameraCircularIO.frames"><code class="xref py py-attr docutils literal"><span class="pre">frames</span></code></a>
property.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>The class makes a couple of assumptions which will cause the frame
meta-data tracking to break if they are not adhered to:</p>
<ul class="last simple">
<li>the stream is only ever appended to - no writes ever start from
the middle of the stream</li>
<li>the stream is never truncated (from the right; being ring buffer
based, left truncation will occur automatically)</li>
</ul>
</div>
<p>The <em>camera</em> parameter specifies the <a class="reference internal" href="index.html#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a>
instance that will be recording video to the stream. If specified, the
<em>size</em> parameter determines the maximum size of the stream in bytes. If
<em>size</em> is not specified (or <code class="docutils literal"><span class="pre">None</span></code>), then <em>seconds</em> must be specified
instead. This provides the maximum length of the stream in seconds,
assuming a data rate in bits-per-second given by the <em>bitrate</em> parameter
(which defaults to <code class="docutils literal"><span class="pre">17000000</span></code>, or 17Mbps, which is also the default
bitrate used for video recording by <a class="reference internal" href="index.html#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a>).
You cannot specify both <em>size</em> and <em>seconds</em>.</p>
<p>The <em>splitter_port</em> parameter specifies the port of the built-in splitter
that the video encoder will be attached to. This defaults to <code class="docutils literal"><span class="pre">1</span></code> and most
users will have no need to specify anything different. If you do specify
something else, ensure it is equal to the <em>splitter_port</em> parameter of the
corresponding call to <a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a>.
For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCameraCircularIO</span><span class="p">(</span><span class="n">camera</span><span class="p">,</span> <span class="n">splitter_port</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="k">as</span> <span class="n">stream</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">start_recording</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;h264&#39;</span><span class="p">,</span> <span class="n">splitter_port</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">splitter_port</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">stop_recording</span><span class="p">(</span><span class="n">splitter_port</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<dl class="attribute">
<dt id="picamera.streams.PiCameraCircularIO.frames">
<code class="descname">frames</code><a class="headerlink" href="#picamera.streams.PiCameraCircularIO.frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an iterator over the frame meta-data.</p>
<p>As the camera records video to the stream, the class captures the
meta-data associated with each frame (in the form of a
<a class="reference internal" href="index.html#picamera.encoders.PiVideoFrame" title="picamera.encoders.PiVideoFrame"><code class="xref py py-class docutils literal"><span class="pre">PiVideoFrame</span></code></a> tuple), discarding meta-data
for frames which are no longer fully stored within the underlying ring
buffer.  You can use the frame meta-data to locate, for example, the
first keyframe present in the stream in order to determine an
appropriate range to extract.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="circulario">
<h4>CircularIO<a class="headerlink" href="#circulario" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.streams.CircularIO">
<em class="property">class </em><code class="descclassname">picamera.streams.</code><code class="descname">CircularIO</code><span class="sig-paren">(</span><em>size</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/streams.html#CircularIO"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.streams.CircularIO" title="Permalink to this definition">¶</a></dt>
<dd><p>A thread-safe stream which uses a ring buffer for storage.</p>
<p>CircularIO provides an in-memory stream similar to the <a class="reference external" href="http://docs.python.org/3.2/library/io.html#io.BytesIO" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">io.BytesIO</span></code></a>
class. However, unlike BytesIO its underlying storage is a <a class="reference external" href="http://en.wikipedia.org/wiki/Circular_buffer">ring buffer</a>
with a fixed maximum size. Once the maximum size is reached, writing
effectively loops round to the beginning to the ring and starts overwriting
the oldest content.</p>
<p>The <em>size</em> parameter specifies the maximum size of the stream in bytes. The
<a class="reference internal" href="#picamera.streams.CircularIO.read" title="picamera.streams.CircularIO.read"><code class="xref py py-meth docutils literal"><span class="pre">read()</span></code></a>, <a class="reference internal" href="#picamera.streams.CircularIO.tell" title="picamera.streams.CircularIO.tell"><code class="xref py py-meth docutils literal"><span class="pre">tell()</span></code></a>, and <a class="reference internal" href="#picamera.streams.CircularIO.seek" title="picamera.streams.CircularIO.seek"><code class="xref py py-meth docutils literal"><span class="pre">seek()</span></code></a> methods all operate
equivalently to those in <a class="reference external" href="http://docs.python.org/3.2/library/io.html#io.BytesIO" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">io.BytesIO</span></code></a> whilst <a class="reference internal" href="#picamera.streams.CircularIO.write" title="picamera.streams.CircularIO.write"><code class="xref py py-meth docutils literal"><span class="pre">write()</span></code></a> only
differs in the wrapping behaviour described above. A <a class="reference internal" href="#picamera.streams.CircularIO.read1" title="picamera.streams.CircularIO.read1"><code class="xref py py-meth docutils literal"><span class="pre">read1()</span></code></a> method
is also provided for efficient reading of the underlying ring buffer in
write-sized chunks (or less).</p>
<p>A re-entrant threading lock guards all operations, and is accessible for
external use via the <a class="reference internal" href="#picamera.streams.CircularIO.lock" title="picamera.streams.CircularIO.lock"><code class="xref py py-attr docutils literal"><span class="pre">lock</span></code></a> attribute.</p>
<p>The performance of the class is geared toward faster writing than reading
on the assumption that writing will be the common operation and reading the
rare operation (a reasonable assumption for the camera use-case, but not
necessarily for more general usage).</p>
<dl class="method">
<dt id="picamera.streams.CircularIO.getvalue">
<code class="descname">getvalue</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/streams.html#CircularIO.getvalue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.streams.CircularIO.getvalue" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <code class="docutils literal"><span class="pre">bytes</span></code> containing the entire contents of the buffer.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.streams.CircularIO.read">
<code class="descname">read</code><span class="sig-paren">(</span><em>n=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/streams.html#CircularIO.read"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.streams.CircularIO.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Read up to <em>n</em> bytes from the stream and return them. As a convenience,
if <em>n</em> is unspecified or -1, <a class="reference internal" href="#picamera.streams.CircularIO.readall" title="picamera.streams.CircularIO.readall"><code class="xref py py-meth docutils literal"><span class="pre">readall()</span></code></a> is called. Fewer than <em>n</em>
bytes may be returned if there are fewer than <em>n</em> bytes from the
current stream position to the end of the stream.</p>
<p>If 0 bytes are returned, and <em>n</em> was not 0, this indicates end of the
stream.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.streams.CircularIO.read1">
<code class="descname">read1</code><span class="sig-paren">(</span><em>n=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/streams.html#CircularIO.read1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.streams.CircularIO.read1" title="Permalink to this definition">¶</a></dt>
<dd><p>Read up to <em>n</em> bytes from the stream using only a single call to the
underlying object.</p>
<p>In the case of <a class="reference internal" href="#picamera.streams.CircularIO" title="picamera.streams.CircularIO"><code class="xref py py-class docutils literal"><span class="pre">CircularIO</span></code></a> this roughly corresponds to
returning the content from the current position up to the end of the
write that added that content to the stream (assuming no subsequent
writes overwrote the content). <a class="reference internal" href="#picamera.streams.CircularIO.read1" title="picamera.streams.CircularIO.read1"><code class="xref py py-meth docutils literal"><span class="pre">read1()</span></code></a> is particularly useful
for efficient copying of the stream&#8217;s content.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.streams.CircularIO.readable">
<code class="descname">readable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/streams.html#CircularIO.readable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.streams.CircularIO.readable" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code>, indicating that the stream supports <a class="reference internal" href="#picamera.streams.CircularIO.read" title="picamera.streams.CircularIO.read"><code class="xref py py-meth docutils literal"><span class="pre">read()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.streams.CircularIO.readall">
<code class="descname">readall</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/streams.html#CircularIO.readall"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.streams.CircularIO.readall" title="Permalink to this definition">¶</a></dt>
<dd><p>Read and return all bytes from the stream until EOF, using multiple
calls to the stream if necessary.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.streams.CircularIO.seek">
<code class="descname">seek</code><span class="sig-paren">(</span><em>offset</em>, <em>whence=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/streams.html#CircularIO.seek"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.streams.CircularIO.seek" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the stream position to the given byte <em>offset</em>. <em>offset</em> is
interpreted relative to the position indicated by <em>whence</em>. Values for
<em>whence</em> are:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">SEEK_SET</span></code> or <code class="docutils literal"><span class="pre">0</span></code> – start of the stream (the default); <em>offset</em>
should be zero or positive</li>
<li><code class="docutils literal"><span class="pre">SEEK_CUR</span></code> or <code class="docutils literal"><span class="pre">1</span></code> – current stream position; <em>offset</em> may be
negative</li>
<li><code class="docutils literal"><span class="pre">SEEK_END</span></code> or <code class="docutils literal"><span class="pre">2</span></code> – end of the stream; <em>offset</em> is usually
negative</li>
</ul>
<p>Return the new absolute position.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.streams.CircularIO.seekable">
<code class="descname">seekable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/streams.html#CircularIO.seekable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.streams.CircularIO.seekable" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code>, indicating the stream supports <a class="reference internal" href="#picamera.streams.CircularIO.seek" title="picamera.streams.CircularIO.seek"><code class="xref py py-meth docutils literal"><span class="pre">seek()</span></code></a> and
<a class="reference internal" href="#picamera.streams.CircularIO.tell" title="picamera.streams.CircularIO.tell"><code class="xref py py-meth docutils literal"><span class="pre">tell()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.streams.CircularIO.tell">
<code class="descname">tell</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/streams.html#CircularIO.tell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.streams.CircularIO.tell" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the current stream position.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.streams.CircularIO.truncate">
<code class="descname">truncate</code><span class="sig-paren">(</span><em>size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/streams.html#CircularIO.truncate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.streams.CircularIO.truncate" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize the stream to the given <em>size</em> in bytes (or the current position
if <em>size</em> is not specified). This resizing can extend or reduce the
current stream size. In case of extension, the contents of the new file
area will be NUL (<code class="docutils literal"><span class="pre">\x00</span></code>) bytes. The new stream size is returned.</p>
<p>The current stream position isn’t changed unless the resizing is
expanding the stream, in which case it may be set to the maximum stream
size if the expansion causes the ring buffer to loop around.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.streams.CircularIO.writable">
<code class="descname">writable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/streams.html#CircularIO.writable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.streams.CircularIO.writable" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">True</span></code>, indicating that the stream supports <a class="reference internal" href="#picamera.streams.CircularIO.write" title="picamera.streams.CircularIO.write"><code class="xref py py-meth docutils literal"><span class="pre">write()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.streams.CircularIO.write">
<code class="descname">write</code><span class="sig-paren">(</span><em>b</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/streams.html#CircularIO.write"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.streams.CircularIO.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the given bytes or bytearray object, <em>b</em>, to the underlying
stream and return the number of bytes written.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.streams.CircularIO.lock">
<code class="descname">lock</code><a class="headerlink" href="#picamera.streams.CircularIO.lock" title="Permalink to this definition">¶</a></dt>
<dd><p>A re-entrant threading lock which is used to guard all operations.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.streams.CircularIO.size">
<code class="descname">size</code><a class="headerlink" href="#picamera.streams.CircularIO.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum size of the buffer in bytes.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<span id="document-api_renderers"></span><div class="section" id="module-picamera.renderers">
<span id="api-picamera-renderers-module"></span><span id="api-renderers"></span><h3>API - <code class="docutils literal"><span class="pre">picamera.renderers</span></code> Module<a class="headerlink" href="#module-picamera.renderers" title="Permalink to this headline">¶</a></h3>
<p>The renderers module defines the renderer classes used by the camera to provide
preview and overlay output on the Pi&#8217;s display. Users will rarely need to
construct instances of these classes directly
(<a class="reference internal" href="index.html#picamera.camera.PiCamera.start_preview" title="picamera.camera.PiCamera.start_preview"><code class="xref py py-meth docutils literal"><span class="pre">start_preview()</span></code></a> and
<a class="reference internal" href="index.html#picamera.camera.PiCamera.add_overlay" title="picamera.camera.PiCamera.add_overlay"><code class="xref py py-meth docutils literal"><span class="pre">add_overlay()</span></code></a> are generally used instead) but
may find the attribute references for them useful.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All classes in this module are available from the <a class="reference internal" href="index.html#module-picamera" title="picamera"><code class="xref py py-mod docutils literal"><span class="pre">picamera</span></code></a> namespace
without having to import <a class="reference internal" href="#module-picamera.renderers" title="picamera.renderers"><code class="xref py py-mod docutils literal"><span class="pre">picamera.renderers</span></code></a> directly.</p>
</div>
<p>The following classes are defined in the module:</p>
<div class="section" id="pirenderer">
<h4>PiRenderer<a class="headerlink" href="#pirenderer" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.renderers.PiRenderer">
<em class="property">class </em><code class="descclassname">picamera.renderers.</code><code class="descname">PiRenderer</code><span class="sig-paren">(</span><em>parent</em>, <em>layer=0</em>, <em>alpha=255</em>, <em>fullscreen=True</em>, <em>window=None</em>, <em>crop=None</em>, <em>rotation=0</em>, <em>vflip=False</em>, <em>hflip=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/renderers.html#PiRenderer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.renderers.PiRenderer" title="Permalink to this definition">¶</a></dt>
<dd><p>Base implementation of an MMAL video renderer for use by PiCamera.</p>
<p>The <em>parent</em> parameter specifies the <a class="reference internal" href="index.html#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a>
instance that has constructed this renderer. The <em>layer</em> parameter
specifies the layer that the renderer will inhabit. Higher numbered layers
obscure lower numbered layers (unless they are partially transparent). The
initial opacity of the renderer is specified by the <em>alpha</em> parameter
(which defaults to 255, meaning completely opaque). The <em>fullscreen</em>
parameter which defaults to <code class="docutils literal"><span class="pre">True</span></code> indicates whether the renderer should
occupy the entire display.  Finally, the <em>window</em> parameter (which only has
meaning when <em>fullscreen</em> is <code class="docutils literal"><span class="pre">False</span></code>) is a four-tuple of <code class="docutils literal"><span class="pre">(x,</span> <span class="pre">y,</span> <span class="pre">width,</span>
<span class="pre">height)</span></code> which gives the screen coordinates that the renderer should
occupy when it isn&#8217;t full-screen.</p>
<p>This base class isn&#8217;t directly used by <a class="reference internal" href="index.html#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a>,
but the two derivatives defined below, <a class="reference internal" href="#picamera.renderers.PiOverlayRenderer" title="picamera.renderers.PiOverlayRenderer"><code class="xref py py-class docutils literal"><span class="pre">PiOverlayRenderer</span></code></a> and
<a class="reference internal" href="#picamera.renderers.PiPreviewRenderer" title="picamera.renderers.PiPreviewRenderer"><code class="xref py py-class docutils literal"><span class="pre">PiPreviewRenderer</span></code></a>, are used to produce overlays and the camera
preview respectively.</p>
<dl class="method">
<dt id="picamera.renderers.PiRenderer.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/renderers.html#PiRenderer.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.renderers.PiRenderer.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Finalizes the renderer and deallocates all structures.</p>
<p>This method is called by the camera prior to destroying the renderer
(or more precisely, letting it go out of scope to permit the garbage
collector to destroy it at some future time).</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.renderers.PiRenderer.alpha">
<code class="descname">alpha</code><a class="headerlink" href="#picamera.renderers.PiRenderer.alpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the opacity of the renderer.</p>
<p>When queried, the <a class="reference internal" href="#picamera.renderers.PiRenderer.alpha" title="picamera.renderers.PiRenderer.alpha"><code class="xref py py-attr docutils literal"><span class="pre">alpha</span></code></a> property returns a value between 0 and
255 indicating the opacity of the renderer, where 0 is completely
transparent and 255 is completely opaque. The default value is 255. The
property can be set while recordings or previews are in progress.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.renderers.PiRenderer.crop">
<code class="descname">crop</code><a class="headerlink" href="#picamera.renderers.PiRenderer.crop" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the area to read from the source.</p>
<p>The <a class="reference internal" href="#picamera.renderers.PiRenderer.crop" title="picamera.renderers.PiRenderer.crop"><code class="xref py py-attr docutils literal"><span class="pre">crop</span></code></a> property specifies the rectangular area that the
renderer will read from the source as a 4-tuple of <code class="docutils literal"><span class="pre">(x,</span> <span class="pre">y,</span> <span class="pre">width,</span>
<span class="pre">height)</span></code>. The special value <code class="docutils literal"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0,</span> <span class="pre">0)</span></code> (which is also the
default) means to read entire area of the source. The property can be
set while recordings or previews are active.</p>
<p>For example, if the camera&#8217;s resolution is currently configured as
1280x720, setting this attribute to <code class="docutils literal"><span class="pre">(160,</span> <span class="pre">160,</span> <span class="pre">640,</span> <span class="pre">400)</span></code> will
crop the preview to the center 640x400 pixels of the input. Note that
this property does not affect the size of the output rectangle,
which is controlled with <a class="reference internal" href="#picamera.renderers.PiRenderer.fullscreen" title="picamera.renderers.PiRenderer.fullscreen"><code class="xref py py-attr docutils literal"><span class="pre">fullscreen</span></code></a> and <a class="reference internal" href="#picamera.renderers.PiRenderer.window" title="picamera.renderers.PiRenderer.window"><code class="xref py py-attr docutils literal"><span class="pre">window</span></code></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This property only affects the renderer; it has no bearing on image
captures or recordings (unlike the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.zoom" title="picamera.camera.PiCamera.zoom"><code class="xref py py-attr docutils literal"><span class="pre">zoom</span></code></a> property of the
<a class="reference internal" href="index.html#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a> class).</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.renderers.PiRenderer.fullscreen">
<code class="descname">fullscreen</code><a class="headerlink" href="#picamera.renderers.PiRenderer.fullscreen" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets whether the renderer appears full-screen.</p>
<p>The <a class="reference internal" href="#picamera.renderers.PiRenderer.fullscreen" title="picamera.renderers.PiRenderer.fullscreen"><code class="xref py py-attr docutils literal"><span class="pre">fullscreen</span></code></a> property is a bool which controls whether the
renderer takes up the entire display or not. When set to <code class="docutils literal"><span class="pre">False</span></code>, the
<a class="reference internal" href="#picamera.renderers.PiRenderer.window" title="picamera.renderers.PiRenderer.window"><code class="xref py py-attr docutils literal"><span class="pre">window</span></code></a> property can be used to control the precise size of the
renderer display. The property can be set while recordings or previews
are active.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.renderers.PiRenderer.hflip">
<code class="descname">hflip</code><a class="headerlink" href="#picamera.renderers.PiRenderer.hflip" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves of sets whether the renderer&#8217;s output is horizontally
flipped.</p>
<p>When queried, the <a class="reference internal" href="#picamera.renderers.PiRenderer.vflip" title="picamera.renderers.PiRenderer.vflip"><code class="xref py py-attr docutils literal"><span class="pre">vflip</span></code></a> property returns a boolean indicating
whether or not the renderer&#8217;s output is horizontally flipped. The
property can be set while recordings or previews are in progress. The
default is <code class="docutils literal"><span class="pre">False</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This property only affects the renderer; it has no bearing on image
captures or recordings (unlike the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.hflip" title="picamera.camera.PiCamera.hflip"><code class="xref py py-attr docutils literal"><span class="pre">hflip</span></code></a> property of the
<a class="reference internal" href="index.html#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a> class).</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.renderers.PiRenderer.layer">
<code class="descname">layer</code><a class="headerlink" href="#picamera.renderers.PiRenderer.layer" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves of sets the layer of the renderer.</p>
<p>The <a class="reference internal" href="#picamera.renderers.PiRenderer.layer" title="picamera.renderers.PiRenderer.layer"><code class="xref py py-attr docutils literal"><span class="pre">layer</span></code></a> property is an integer which controls the layer that
the renderer occupies. Higher valued layers obscure lower valued layers
(with 0 being the &#8220;bottom&#8221; layer). The default value is 2. The property
can be set while recordings or previews are in progress.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.renderers.PiRenderer.rotation">
<code class="descname">rotation</code><a class="headerlink" href="#picamera.renderers.PiRenderer.rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves of sets the current rotation of the renderer.</p>
<p>When queried, the <a class="reference internal" href="#picamera.renderers.PiRenderer.rotation" title="picamera.renderers.PiRenderer.rotation"><code class="xref py py-attr docutils literal"><span class="pre">rotation</span></code></a> property returns the rotation
applied to the renderer. Valid values are 0, 90, 180, and 270.</p>
<p>When set, the property changes the rotation applied to the renderer&#8217;s
output. The property can be set while recordings or previews are
active. The default is 0.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This property only affects the renderer; it has no bearing on image
captures or recordings (unlike the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.rotation" title="picamera.camera.PiCamera.rotation"><code class="xref py py-attr docutils literal"><span class="pre">rotation</span></code></a> property of the
<a class="reference internal" href="index.html#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a> class).</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.renderers.PiRenderer.vflip">
<code class="descname">vflip</code><a class="headerlink" href="#picamera.renderers.PiRenderer.vflip" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves of sets whether the renderer&#8217;s output is vertically flipped.</p>
<p>When queried, the <a class="reference internal" href="#picamera.renderers.PiRenderer.vflip" title="picamera.renderers.PiRenderer.vflip"><code class="xref py py-attr docutils literal"><span class="pre">vflip</span></code></a> property returns a boolean indicating
whether or not the renderer&#8217;s output is vertically flipped. The
property can be set while recordings or previews are in progress. The
default is <code class="docutils literal"><span class="pre">False</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This property only affects the renderer; it has no bearing on image
captures or recordings (unlike the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.vflip" title="picamera.camera.PiCamera.vflip"><code class="xref py py-attr docutils literal"><span class="pre">vflip</span></code></a> property of the
<a class="reference internal" href="index.html#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a> class).</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="picamera.renderers.PiRenderer.window">
<code class="descname">window</code><a class="headerlink" href="#picamera.renderers.PiRenderer.window" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves or sets the size of the renderer.</p>
<p>When the <a class="reference internal" href="#picamera.renderers.PiRenderer.fullscreen" title="picamera.renderers.PiRenderer.fullscreen"><code class="xref py py-attr docutils literal"><span class="pre">fullscreen</span></code></a> property is set to <code class="docutils literal"><span class="pre">False</span></code>, the
<a class="reference internal" href="#picamera.renderers.PiRenderer.window" title="picamera.renderers.PiRenderer.window"><code class="xref py py-attr docutils literal"><span class="pre">window</span></code></a> property specifies the size and position of the renderer
on the display. The property is a 4-tuple consisting of <code class="docutils literal"><span class="pre">(x,</span> <span class="pre">y,</span> <span class="pre">width,</span>
<span class="pre">height)</span></code>. The property can be set while recordings or previews are
active.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="pioverlayrenderer">
<h4>PiOverlayRenderer<a class="headerlink" href="#pioverlayrenderer" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.renderers.PiOverlayRenderer">
<em class="property">class </em><code class="descclassname">picamera.renderers.</code><code class="descname">PiOverlayRenderer</code><span class="sig-paren">(</span><em>parent</em>, <em>source</em>, <em>size=None</em>, <em>layer=0</em>, <em>alpha=255</em>, <em>fullscreen=True</em>, <em>window=None</em>, <em>crop=None</em>, <em>rotation=0</em>, <em>vflip=False</em>, <em>hflip=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/renderers.html#PiOverlayRenderer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.renderers.PiOverlayRenderer" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents an MMAL renderer with a static source for overlays.</p>
<p>This class descends from <a class="reference internal" href="#picamera.renderers.PiRenderer" title="picamera.renderers.PiRenderer"><code class="xref py py-class docutils literal"><span class="pre">PiRenderer</span></code></a> and adds a static source for
the MMAL renderer. The optional <em>size</em> parameter specifies the size of the
source image as a <code class="docutils literal"><span class="pre">(width,</span> <span class="pre">height)</span></code> tuple. If this is omitted or <code class="docutils literal"><span class="pre">None</span></code>
then the size is assumed to be the same as the parent camera&#8217;s current
<a class="reference internal" href="index.html#picamera.camera.PiCamera.resolution" title="picamera.camera.PiCamera.resolution"><code class="xref py py-attr docutils literal"><span class="pre">resolution</span></code></a>.</p>
<p>The <em>source</em> must be an object that supports the <a class="reference external" href="http://docs.python.org/3.2/c-api/buffer.html#bufferobjects" title="(in Python v3.2)"><span class="xref std std-ref">buffer protocol</span></a> which has the same length as an image in <a class="reference external" href="http://en.wikipedia.org/wiki/RGB">RGB</a> format
(colors represented as interleaved unsigned bytes) with the specified
<em>size</em> after the width has been rounded up to the nearest multiple of 32,
and the height has been rounded up to the nearest multiple of 16.</p>
<p>For example, if <em>size</em> is <code class="docutils literal"><span class="pre">(1280,</span> <span class="pre">720)</span></code>, then <em>source</em> must be a buffer
with length 1280 x 720 x 3 bytes, or 2,764,800 bytes (because 1280 is a
multiple of 32, and 720 is a multiple of 16 no extra rounding is required).
However, if <em>size</em> is <code class="docutils literal"><span class="pre">(97,</span> <span class="pre">57)</span></code>, then <em>source</em> must be a buffer with
length 128 x 64 x 3 bytes, or 24,576 bytes (pixels beyond column 97 and row
57 in the source will be ignored).</p>
<p>The <em>layer</em>, <em>alpha</em>, <em>fullscreen</em>, and <em>window</em> parameters are the same
as in <a class="reference internal" href="#picamera.renderers.PiRenderer" title="picamera.renderers.PiRenderer"><code class="xref py py-class docutils literal"><span class="pre">PiRenderer</span></code></a>.</p>
<dl class="method">
<dt id="picamera.renderers.PiOverlayRenderer.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>source</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/renderers.html#PiOverlayRenderer.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.renderers.PiOverlayRenderer.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the overlay with a new source of data.</p>
<p>The new <em>source</em> buffer must have the same size as the original buffer
used to create the overlay. There is currently no method for changing
the size of an existing overlay (remove and recreate the overlay if you
require this).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="pipreviewrenderer">
<h4>PiPreviewRenderer<a class="headerlink" href="#pipreviewrenderer" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.renderers.PiPreviewRenderer">
<em class="property">class </em><code class="descclassname">picamera.renderers.</code><code class="descname">PiPreviewRenderer</code><span class="sig-paren">(</span><em>parent</em>, <em>source</em>, <em>layer=2</em>, <em>alpha=255</em>, <em>fullscreen=True</em>, <em>window=None</em>, <em>crop=None</em>, <em>rotation=0</em>, <em>vflip=False</em>, <em>hflip=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/renderers.html#PiPreviewRenderer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.renderers.PiPreviewRenderer" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents an MMAL renderer which uses the camera&#8217;s preview as a source.</p>
<p>This class descends from <a class="reference internal" href="#picamera.renderers.PiRenderer" title="picamera.renderers.PiRenderer"><code class="xref py py-class docutils literal"><span class="pre">PiRenderer</span></code></a> and adds an MMAL connection to
connect the renderer to an MMAL port. The <em>source</em> parameter specifies the
MMAL port to connect to the renderer.</p>
<p>The <em>layer</em>, <em>alpha</em>, <em>fullscreen</em>, and <em>window</em> parameters are the same
as in <a class="reference internal" href="#picamera.renderers.PiRenderer" title="picamera.renderers.PiRenderer"><code class="xref py py-class docutils literal"><span class="pre">PiRenderer</span></code></a>.</p>
</dd></dl>

</div>
<div class="section" id="pinullsink">
<h4>PiNullSink<a class="headerlink" href="#pinullsink" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.renderers.PiNullSink">
<em class="property">class </em><code class="descclassname">picamera.renderers.</code><code class="descname">PiNullSink</code><span class="sig-paren">(</span><em>parent</em>, <em>source</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/renderers.html#PiNullSink"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.renderers.PiNullSink" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements an MMAL null-sink which can be used in place of a renderer.</p>
<p>The <em>parent</em> parameter specifies the <a class="reference internal" href="index.html#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a>
instance which constructed this null-sink. The <em>source</em> parameter specifies
the MMAL port which the null-sink should connect to its input.</p>
<p>The null-sink can act as a drop-in replacement for <a class="reference internal" href="#picamera.renderers.PiRenderer" title="picamera.renderers.PiRenderer"><code class="xref py py-class docutils literal"><span class="pre">PiRenderer</span></code></a> in
most cases, but obviously doesn&#8217;t implement attributes like <code class="docutils literal"><span class="pre">alpha</span></code>,
<code class="docutils literal"><span class="pre">layer</span></code>, etc. as it simply dumps any incoming frames. This is also the
reason that this class doesn&#8217;t derive from <a class="reference internal" href="#picamera.renderers.PiRenderer" title="picamera.renderers.PiRenderer"><code class="xref py py-class docutils literal"><span class="pre">PiRenderer</span></code></a> like all
other classes in this module.</p>
<dl class="method">
<dt id="picamera.renderers.PiNullSink.close">
<code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/renderers.html#PiNullSink.close"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.renderers.PiNullSink.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Finalizes the null-sink and deallocates all structures.</p>
<p>This method is called by the camera prior to destroying the null-sink
(or more precisely, letting it go out of scope to permit the garbage
collector to destroy it at some future time).</p>
</dd></dl>

</dd></dl>

</div>
</div>
<span id="document-api_color"></span><div class="section" id="module-picamera.color">
<span id="api-picamera-color-module"></span><span id="api-color"></span><h3>API - <code class="docutils literal"><span class="pre">picamera.color</span></code> Module<a class="headerlink" href="#module-picamera.color" title="Permalink to this headline">¶</a></h3>
<p>The color module defines a class for representing a color, along with various
ancillary classes which can be used to manipulate aspects of a color.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All classes in this module are available from the <a class="reference internal" href="index.html#module-picamera" title="picamera"><code class="xref py py-mod docutils literal"><span class="pre">picamera</span></code></a> namespace
without having to import <a class="reference internal" href="#module-picamera.color" title="picamera.color"><code class="xref py py-mod docutils literal"><span class="pre">picamera.color</span></code></a> directly.</p>
</div>
<p>The following classes are defined in the module:</p>
<div class="section" id="color">
<h4>Color<a class="headerlink" href="#color" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.color.Color">
<em class="property">class </em><code class="descclassname">picamera.color.</code><code class="descname">Color</code><a class="reference internal" href="_modules/picamera/color.html#Color"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.color.Color" title="Permalink to this definition">¶</a></dt>
<dd><p>The Color class is a tuple which represents a color as red, green, and
blue components.</p>
<p>The class has a flexible constructor which allows you to create an instance
from a variety of color systems including <a class="reference external" href="https://en.wikipedia.org/wiki/RGB_color_space">RGB</a>, <a class="reference external" href="https://en.wikipedia.org/wiki/YUV">Y&#8217;UV</a>, <a class="reference external" href="https://en.wikipedia.org/wiki/YIQ">Y&#8217;IQ</a>, <a class="reference external" href="https://en.wikipedia.org/wiki/HSL_and_HSV">HLS</a>,
and <a class="reference external" href="https://en.wikipedia.org/wiki/HSL_and_HSV">HSV</a>.  There are also explicit constructors for each of these systems
to allow you to force the use of a system in your code. For example, an
instance of <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> can be constructed in any of the following
ways:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="p">(</span><span class="s">&#39;#f00&#39;</span><span class="p">)</span>
<span class="go">&lt;Color &quot;#ff0000&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="p">(</span><span class="s">&#39;green&#39;</span><span class="p">)</span>
<span class="go">&lt;Color &quot;#008000&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">&lt;Color &quot;#0000ff&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="p">(</span><span class="n">hue</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">saturation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">&lt;Color &quot;#7f0000&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">u</span><span class="o">=-</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="mf">0.615</span><span class="p">)</span>
<span class="go">&lt;Color &quot;#ff0f4c&quot;&gt;</span>
</pre></div>
</div>
<p>The specific forms that the default constructor will accept are enumerated
below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Style</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Single positional parameter</td>
<td>Equivalent to calling
<a class="reference internal" href="#picamera.color.Color.from_string" title="picamera.color.Color.from_string"><code class="xref py py-meth docutils literal"><span class="pre">Color.from_string()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td>Three positional parameters</td>
<td rowspan="3">Equivalent to calling
<a class="reference internal" href="#picamera.color.Color.from_rgb" title="picamera.color.Color.from_rgb"><code class="xref py py-meth docutils literal"><span class="pre">Color.from_rgb()</span></code></a> if all three
parameters are between 0.0 and 1.0, or
<a class="reference internal" href="#picamera.color.Color.from_rgb_bytes" title="picamera.color.Color.from_rgb_bytes"><code class="xref py py-meth docutils literal"><span class="pre">Color.from_rgb_bytes()</span></code></a> otherwise.</td>
</tr>
<tr class="row-even"><td>Three named parameters,
&#8220;r&#8221;, &#8220;g&#8221;, &#8220;b&#8221;</td>
</tr>
<tr class="row-odd"><td>Three named parameters,
&#8220;red&#8221;, &#8220;green&#8221;, &#8220;blue&#8221;</td>
</tr>
<tr class="row-even"><td>Three named parameters,
&#8220;y&#8221;, &#8220;u&#8221;, &#8220;v&#8221;</td>
<td>Equivalent to calling
<a class="reference internal" href="#picamera.color.Color.from_yuv" title="picamera.color.Color.from_yuv"><code class="xref py py-meth docutils literal"><span class="pre">Color.from_yuv()</span></code></a> if &#8220;y&#8221; is between
0.0 and 1.0, &#8220;u&#8221; is between -0.436 and
0.436, and &#8220;v&#8221; is between -0.615 and
0.615, or <a class="reference internal" href="#picamera.color.Color.from_yuv_bytes" title="picamera.color.Color.from_yuv_bytes"><code class="xref py py-meth docutils literal"><span class="pre">Color.from_yuv_bytes()</span></code></a>
otherwise.</td>
</tr>
<tr class="row-odd"><td>Three named parameters,
&#8220;y&#8221;, &#8220;i&#8221;, &#8220;q&#8221;</td>
<td>Equivalent to calling
<a class="reference internal" href="#picamera.color.Color.from_yiq" title="picamera.color.Color.from_yiq"><code class="xref py py-meth docutils literal"><span class="pre">Color.from_yiq()</span></code></a>.</td>
</tr>
<tr class="row-even"><td>Three named parameters,
&#8220;h&#8221;, &#8220;l&#8221;, &#8220;s&#8221;</td>
<td rowspan="2">Equivalent to calling
<a class="reference internal" href="#picamera.color.Color.from_hls" title="picamera.color.Color.from_hls"><code class="xref py py-meth docutils literal"><span class="pre">Color.from_hls()</span></code></a>.</td>
</tr>
<tr class="row-odd"><td>Three named parameters,
&#8220;hue&#8221;, &#8220;lightness&#8221;,
&#8220;saturation&#8221;</td>
</tr>
<tr class="row-even"><td>Three named parameters
&#8220;h&#8221;, &#8220;s&#8221;, &#8220;v&#8221;</td>
<td rowspan="2">Equivalent to calling
<a class="reference internal" href="#picamera.color.Color.from_hsv" title="picamera.color.Color.from_hsv"><code class="xref py py-meth docutils literal"><span class="pre">Color.from_hsv()</span></code></a></td>
</tr>
<tr class="row-odd"><td>Three named parameters
&#8220;hue&#8221;, &#8220;saturation&#8221;, &#8220;value&#8221;</td>
</tr>
</tbody>
</table>
<p>If the constructor parameters do not conform to any of the variants in the
table above, a <a class="reference external" href="http://docs.python.org/3.2/library/exceptions.html#ValueError" title="(in Python v3.2)"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a> will be thrown.</p>
<p>Internally, the color is <em>always</em> represented as 3 float values
corresponding to the red, green, and blue components of the color. These
values take a value from 0.0 to 1.0 (least to full intensity). The class
provides several attributes which can be used to convert one color system
into another:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="p">(</span><span class="s">&#39;#f00&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hls</span>
<span class="go">(0.0, 0.5, 1.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s">&#39;green&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hue</span>
<span class="go">Hue(deg=120.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="o">.</span><span class="n">from_rgb_bytes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">yuv</span>
<span class="go">(0.114, 0.435912, -0.099978)</span>
</pre></div>
</div>
<p>As <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> derives from tuple, instances are immutable. While this
provides the advantage that they can be used as keys in a dict, it does
mean that colors themselves cannot be directly manipulated (e.g. by
reducing the red component).</p>
<p>However, several auxilliary classes in the module provide the ability to
perform simple transformations of colors via operators which produce a new
<a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> instance. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="p">(</span><span class="s">&#39;red&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">Red</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">&lt;Color &quot;#7f0000&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="p">(</span><span class="s">&#39;green&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Red</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">&lt;Color &quot;#7f8000&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="o">.</span><span class="n">from_hls</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="go">&lt;Color &quot;#00feff&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="o">.</span><span class="n">from_hls</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">Lightness</span><span class="p">(</span><span class="mf">0.8</span><span class="p">)</span>
<span class="go">&lt;Color &quot;#00cbcc&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">Color</span><span class="o">.</span><span class="n">from_hls</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">Lightness</span><span class="p">(</span><span class="mf">0.8</span><span class="p">))</span><span class="o">.</span><span class="n">hls</span>
<span class="go">(0.5, 0.4, 1.0)</span>
</pre></div>
</div>
<p>From the last example above one can see that even attributes not directly
stored by the color (such as lightness) can be manipulated in this fashion.
In this case a <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> instance is constructed from HLS (hue,
lightness, saturation) values with a lightness of 0.5. This is multiplied
by a <a class="reference internal" href="#picamera.color.Lightness" title="picamera.color.Lightness"><code class="xref py py-class docutils literal"><span class="pre">Lightness</span></code></a> instance with a value of 0.8 which constructs a new
<a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> with the same hue and saturation, but a lightness of 0.5 *
0.8 = 0.4.</p>
<p>If an instance is converted to a string (with <a class="reference external" href="http://docs.python.org/3.2/library/functions.html#str" title="(in Python v3.2)"><code class="xref py py-func docutils literal"><span class="pre">str()</span></code></a>) it will return a
string containing the 7-character HTML code for the color (e.g. &#8220;#ff0000&#8221;
for red). As can be seen in the examples above, a similar representation is
returned for <a class="reference external" href="http://docs.python.org/3.2/library/functions.html#repr" title="(in Python v3.2)"><code class="xref py py-func docutils literal"><span class="pre">repr()</span></code></a>.</p>
<dl class="classmethod">
<dt id="picamera.color.Color.from_hls">
<em class="property">classmethod </em><code class="descname">from_hls</code><span class="sig-paren">(</span><em>h</em>, <em>l</em>, <em>s</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/color.html#Color.from_hls"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.color.Color.from_hls" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> from <a class="reference external" href="https://en.wikipedia.org/wiki/HSL_and_HSV">HLS</a> (hue, lightness, saturation)
floats between 0.0 and 1.0.</p>
</dd></dl>

<dl class="classmethod">
<dt id="picamera.color.Color.from_hsv">
<em class="property">classmethod </em><code class="descname">from_hsv</code><span class="sig-paren">(</span><em>h</em>, <em>s</em>, <em>v</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/color.html#Color.from_hsv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.color.Color.from_hsv" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> from <a class="reference external" href="https://en.wikipedia.org/wiki/HSL_and_HSV">HSV</a> (hue, saturation, value) floats
between 0.0 and 1.0.</p>
</dd></dl>

<dl class="classmethod">
<dt id="picamera.color.Color.from_rgb">
<em class="property">classmethod </em><code class="descname">from_rgb</code><span class="sig-paren">(</span><em>r</em>, <em>g</em>, <em>b</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/color.html#Color.from_rgb"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.color.Color.from_rgb" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> from three <a class="reference external" href="https://en.wikipedia.org/wiki/RGB_color_space">RGB</a> float values between 0.0
and 1.0.</p>
</dd></dl>

<dl class="classmethod">
<dt id="picamera.color.Color.from_rgb_bytes">
<em class="property">classmethod </em><code class="descname">from_rgb_bytes</code><span class="sig-paren">(</span><em>r</em>, <em>g</em>, <em>b</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/color.html#Color.from_rgb_bytes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.color.Color.from_rgb_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> from three <a class="reference external" href="https://en.wikipedia.org/wiki/RGB_color_space">RGB</a> byte values between 0 and
255.</p>
</dd></dl>

<dl class="classmethod">
<dt id="picamera.color.Color.from_string">
<em class="property">classmethod </em><code class="descname">from_string</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/color.html#Color.from_string"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.color.Color.from_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> from a 4 or 7 character CSS-like
representation (e.g. &#8220;#f00&#8221; or &#8220;#ff0000&#8221; for red), or from one of the
named colors (e.g. &#8220;green&#8221; or &#8220;wheat&#8221;) from the <a class="reference external" href="http://www.w3.org/TR/css3-color/#svg-color">CSS standard</a>. Any
other string format will result in a <a class="reference external" href="http://docs.python.org/3.2/library/exceptions.html#ValueError" title="(in Python v3.2)"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>.</p>
</dd></dl>

<dl class="classmethod">
<dt id="picamera.color.Color.from_yiq">
<em class="property">classmethod </em><code class="descname">from_yiq</code><span class="sig-paren">(</span><em>y</em>, <em>i</em>, <em>q</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/color.html#Color.from_yiq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.color.Color.from_yiq" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> from three <a class="reference external" href="https://en.wikipedia.org/wiki/YIQ">Y&#8217;IQ</a> float values. Y&#8217; can be
between 0.0 and 1.0, while I and Q can be between -1.0 and 1.0.</p>
</dd></dl>

<dl class="classmethod">
<dt id="picamera.color.Color.from_yuv">
<em class="property">classmethod </em><code class="descname">from_yuv</code><span class="sig-paren">(</span><em>y</em>, <em>u</em>, <em>v</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/color.html#Color.from_yuv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.color.Color.from_yuv" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> from three <a class="reference external" href="https://en.wikipedia.org/wiki/YUV">Y&#8217;UV</a> float values. The Y value
may be between 0.0 and 1.0. U may be between -0.436 and 0.436, while
V may be between -0.615 and 0.615.</p>
</dd></dl>

<dl class="classmethod">
<dt id="picamera.color.Color.from_yuv_bytes">
<em class="property">classmethod </em><code class="descname">from_yuv_bytes</code><span class="sig-paren">(</span><em>y</em>, <em>u</em>, <em>v</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/color.html#Color.from_yuv_bytes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.color.Color.from_yuv_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> from three <a class="reference external" href="https://en.wikipedia.org/wiki/YUV">Y&#8217;UV</a> byte values between 0 and
255. The U and V values are biased by 128 to prevent negative values as
is typical in video applications. The Y value is biased by 16 for the
same purpose.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.color.Color.blue">
<code class="descname">blue</code><a class="headerlink" href="#picamera.color.Color.blue" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the blue component of the color as a <a class="reference internal" href="#picamera.color.Blue" title="picamera.color.Blue"><code class="xref py py-class docutils literal"><span class="pre">Blue</span></code></a> instance
which can be used in operations with other <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> instances.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.color.Color.green">
<code class="descname">green</code><a class="headerlink" href="#picamera.color.Color.green" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the green component of the color as a <a class="reference internal" href="#picamera.color.Green" title="picamera.color.Green"><code class="xref py py-class docutils literal"><span class="pre">Green</span></code></a> instance
which can be used in operations with other <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> instances.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.color.Color.hls">
<code class="descname">hls</code><a class="headerlink" href="#picamera.color.Color.hls" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a 3-tuple of (hue, lightness, saturation) float values (between
0.0 and 1.0).</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.color.Color.hsv">
<code class="descname">hsv</code><a class="headerlink" href="#picamera.color.Color.hsv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a 3-tuple of (hue, saturation, value) float values (between 0.0
and 1.0).</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.color.Color.hue">
<code class="descname">hue</code><a class="headerlink" href="#picamera.color.Color.hue" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the hue of the color as a <a class="reference internal" href="#picamera.color.Hue" title="picamera.color.Hue"><code class="xref py py-class docutils literal"><span class="pre">Hue</span></code></a> instance which can be
used in operations with other <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> instances.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.color.Color.lightness">
<code class="descname">lightness</code><a class="headerlink" href="#picamera.color.Color.lightness" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the lightness of the color as a <a class="reference internal" href="#picamera.color.Lightness" title="picamera.color.Lightness"><code class="xref py py-class docutils literal"><span class="pre">Lightness</span></code></a> instance
which can be used in operations with other <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> instances.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.color.Color.red">
<code class="descname">red</code><a class="headerlink" href="#picamera.color.Color.red" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the red component of the color as a <a class="reference internal" href="#picamera.color.Red" title="picamera.color.Red"><code class="xref py py-class docutils literal"><span class="pre">Red</span></code></a> instance which
can be used in operations with other <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> instances.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.color.Color.rgb">
<code class="descname">rgb</code><a class="headerlink" href="#picamera.color.Color.rgb" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a 3-tuple of (red, green, blue) float values (between 0.0 and
1.0).</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.color.Color.rgb_bytes">
<code class="descname">rgb_bytes</code><a class="headerlink" href="#picamera.color.Color.rgb_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a 3-tuple of (red, green, blue) byte values.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.color.Color.saturation">
<code class="descname">saturation</code><a class="headerlink" href="#picamera.color.Color.saturation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the saturation of the color as a <a class="reference internal" href="#picamera.color.Saturation" title="picamera.color.Saturation"><code class="xref py py-class docutils literal"><span class="pre">Saturation</span></code></a> instance
which can be used in operations with other <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> instances.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.color.Color.yiq">
<code class="descname">yiq</code><a class="headerlink" href="#picamera.color.Color.yiq" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a 3-tuple of (y, i, q) float values; y values can be between
0.0 and 1.0, whilst i and q values can be between -1.0 and 1.0.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.color.Color.yuv">
<code class="descname">yuv</code><a class="headerlink" href="#picamera.color.Color.yuv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a 3-tuple of (y, u, v) float values; y values can be between
0.0 and 1.0, u values are between -0.436 and 0.436, and v values are
between -0.615 and 0.615.</p>
</dd></dl>

<dl class="attribute">
<dt id="picamera.color.Color.yuv_bytes">
<code class="descname">yuv_bytes</code><a class="headerlink" href="#picamera.color.Color.yuv_bytes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a 3-tuple of (y, u, v) byte values. Y values are biased by 16
in the result to prevent negatives. U and V values are biased by 128
for the same purpose.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="red">
<h4>Red<a class="headerlink" href="#red" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.color.Red">
<em class="property">class </em><code class="descclassname">picamera.color.</code><code class="descname">Red</code><a class="reference internal" href="_modules/picamera/color.html#Red"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.color.Red" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents the red component of a <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> for use in
transformations. Instances of this class can be constructed directly with a
float value, or by querying the <a class="reference internal" href="#picamera.color.Color.red" title="picamera.color.Color.red"><code class="xref py py-attr docutils literal"><span class="pre">Color.red</span></code></a> attribute. Addition,
subtraction, and multiplication are supported with <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a>
instances. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="o">.</span><span class="n">from_rgb</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">Red</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="go">&lt;Color &quot;#7f0000&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="p">(</span><span class="s">&#39;#f00&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">Color</span><span class="p">(</span><span class="s">&#39;#900&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">red</span>
<span class="go">&lt;Color &quot;#660000&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">Red</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span> <span class="o">*</span> <span class="n">Color</span><span class="p">(</span><span class="s">&#39;red&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">red</span>
<span class="go">Red(0.1)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="green">
<h4>Green<a class="headerlink" href="#green" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.color.Green">
<em class="property">class </em><code class="descclassname">picamera.color.</code><code class="descname">Green</code><a class="reference internal" href="_modules/picamera/color.html#Green"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.color.Green" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents the green component of a <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> for use in
transformations.  Instances of this class can be constructed directly with
a float value, or by querying the <a class="reference internal" href="#picamera.color.Color.green" title="picamera.color.Color.green"><code class="xref py py-attr docutils literal"><span class="pre">Color.green</span></code></a> attribute. Addition,
subtraction, and multiplication are supported with <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a>
instances. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">Green</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="go">&lt;Color &quot;#001900&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="o">.</span><span class="n">from_yuv</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.4</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.6</span><span class="p">)</span> <span class="o">-</span> <span class="n">Green</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&lt;Color &quot;#50002f&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">Green</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">Color</span><span class="p">(</span><span class="s">&#39;white&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">rgb</span>
<span class="go">(Red(1.0), Green(0.5), Blue(1.0))</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="blue">
<h4>Blue<a class="headerlink" href="#blue" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.color.Blue">
<em class="property">class </em><code class="descclassname">picamera.color.</code><code class="descname">Blue</code><a class="reference internal" href="_modules/picamera/color.html#Blue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.color.Blue" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents the blue component of a <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> for use in
transformations.  Instances of this class can be constructed directly with
a float value, or by querying the <a class="reference internal" href="#picamera.color.Color.blue" title="picamera.color.Color.blue"><code class="xref py py-attr docutils literal"><span class="pre">Color.blue</span></code></a> attribute. Addition,
subtraction, and multiplication are supported with <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a>
instances. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">Blue</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>
<span class="go">&lt;Color &quot;#000033&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="o">.</span><span class="n">from_hls</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">-</span> <span class="n">Blue</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&lt;Color &quot;#00fe00&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Blue</span><span class="p">(</span><span class="mf">0.9</span><span class="p">)</span> <span class="o">*</span> <span class="n">Color</span><span class="p">(</span><span class="s">&#39;white&#39;</span><span class="p">)</span>
<span class="go">&lt;Color &quot;#ffffe5&quot;&gt;</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="hue">
<h4>Hue<a class="headerlink" href="#hue" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.color.Hue">
<em class="property">class </em><code class="descclassname">picamera.color.</code><code class="descname">Hue</code><a class="reference internal" href="_modules/picamera/color.html#Hue"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.color.Hue" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents the hue of a <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> for use in transformations.
Instances of this class can be constructed directly with a float value in
the range [0.0, 1.0) representing an angle around the <a class="reference external" href="https://en.wikipedia.org/wiki/Hue">HSL hue wheel</a>. As
this is a circular mapping, 0.0 and 1.0 effectively mean the same thing,
i.e.  out of range values will be normalized into the range [0.0, 1.0).</p>
<p>The class can also be constructed with the keyword arguments <code class="docutils literal"><span class="pre">deg</span></code> or
<code class="docutils literal"><span class="pre">rad</span></code> if you wish to specify the hue value in degrees or radians instead,
respectively. Instances can also be constructed by querying the
<a class="reference internal" href="#picamera.color.Color.hue" title="picamera.color.Color.hue"><code class="xref py py-attr docutils literal"><span class="pre">Color.hue</span></code></a> attribute.</p>
<p>Addition, subtraction, and multiplication are supported with <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a>
instances. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">hls</span>
<span class="go">(0.0, 0.5, 1.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">Color</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">Hue</span><span class="p">(</span><span class="n">deg</span><span class="o">=</span><span class="mi">180</span><span class="p">))</span><span class="o">.</span><span class="n">hls</span>
<span class="go">(0.5, 0.5, 1.0)</span>
</pre></div>
</div>
<p>Note that whilst multiplication by a <a class="reference internal" href="#picamera.color.Hue" title="picamera.color.Hue"><code class="xref py py-class docutils literal"><span class="pre">Hue</span></code></a> doesn&#8217;t make much sense,
it is still supported. However, the circular nature of a hue value can lead
to suprising effects. In particular, since 1.0 is equivalent to 0.0 the
following may be observed:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">Hue</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">Color</span><span class="o">.</span><span class="n">from_hls</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span><span class="o">.</span><span class="n">hls</span>
<span class="go">(0.0, 0.5, 1.0)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="saturation">
<h4>Saturation<a class="headerlink" href="#saturation" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.color.Saturation">
<em class="property">class </em><code class="descclassname">picamera.color.</code><code class="descname">Saturation</code><a class="reference internal" href="_modules/picamera/color.html#Saturation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.color.Saturation" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents the saturation of a <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> for use in transformations.
Instances of this class can be constructed directly with a float value, or
by querying the <a class="reference internal" href="#picamera.color.Color.saturation" title="picamera.color.Color.saturation"><code class="xref py py-attr docutils literal"><span class="pre">Color.saturation</span></code></a> attribute. Addition, subtraction,
and multiplication are supported with <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> instances. For
example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">)</span> <span class="o">+</span> <span class="n">Saturation</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="go">&lt;Color &quot;#ebeb92&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="p">(</span><span class="s">&#39;red&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">Saturation</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&lt;Color &quot;#7f7f7f&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Saturation</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">Color</span><span class="p">(</span><span class="s">&#39;wheat&#39;</span><span class="p">)</span>
<span class="go">&lt;Color &quot;#e4d9c3&quot;&gt;</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="lightness">
<h4>Lightness<a class="headerlink" href="#lightness" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.color.Lightness">
<em class="property">class </em><code class="descclassname">picamera.color.</code><code class="descname">Lightness</code><a class="reference internal" href="_modules/picamera/color.html#Lightness"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.color.Lightness" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents the lightness of a <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> for use in transformations.
Instances of this class can be constructed directly with a float value, or
by querying the <a class="reference internal" href="#picamera.color.Color.lightness" title="picamera.color.Color.lightness"><code class="xref py py-attr docutils literal"><span class="pre">Color.lightness</span></code></a> attribute. Addition, subtraction,
and multiplication are supported with <a class="reference internal" href="#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> instances. For
example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">Lightness</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="go">&lt;Color &quot;#191919&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Color</span><span class="o">.</span><span class="n">from_rgb_bytes</span><span class="p">(</span><span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">Lightness</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>
<span class="go">&lt;Color &quot;#191900&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Lightness</span><span class="p">(</span><span class="mf">0.9</span><span class="p">)</span> <span class="o">*</span> <span class="n">Color</span><span class="p">(</span><span class="s">&#39;wheat&#39;</span><span class="p">)</span>
<span class="go">&lt;Color &quot;#f0cd8d&quot;&gt;</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<span id="document-api_array"></span><div class="section" id="module-picamera.array">
<span id="api-picamera-array-module"></span><span id="api-array"></span><h3>API - <code class="docutils literal"><span class="pre">picamera.array</span></code> Module<a class="headerlink" href="#module-picamera.array" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#module-picamera.array" title="picamera.array"><code class="xref py py-mod docutils literal"><span class="pre">picamera.array</span></code></a> module provides a set of classes which aid in
constructing n-dimensional <a class="reference external" href="http://www.numpy.org/">numpy</a> arrays from the camera output. In order to
avoid adding a hard dependency on numpy to picamera, the module is not
automatically imported by the main picamera package and must be explicitly
imported.</p>
<p>The following classes are defined in the module:</p>
<div class="section" id="piarrayoutput">
<h4>PiArrayOutput<a class="headerlink" href="#piarrayoutput" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.array.PiArrayOutput">
<em class="property">class </em><code class="descclassname">picamera.array.</code><code class="descname">PiArrayOutput</code><span class="sig-paren">(</span><em>camera</em>, <em>size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/array.html#PiArrayOutput"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.array.PiArrayOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for capture arrays.</p>
<p>This class extends <a class="reference external" href="http://docs.python.org/3.2/library/io.html#io.BytesIO" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">io.BytesIO</span></code></a> with a <a class="reference external" href="http://www.numpy.org/">numpy</a> array which is
intended to be filled when <a class="reference external" href="http://docs.python.org/3.2/library/io.html#io.IOBase.flush" title="(in Python v3.2)"><code class="xref py py-meth docutils literal"><span class="pre">flush()</span></code></a> is called (i.e. at the
end of capture).</p>
<dl class="attribute">
<dt id="picamera.array.PiArrayOutput.array">
<code class="descname">array</code><a class="headerlink" href="#picamera.array.PiArrayOutput.array" title="Permalink to this definition">¶</a></dt>
<dd><p>After <a class="reference external" href="http://docs.python.org/3.2/library/io.html#io.IOBase.flush" title="(in Python v3.2)"><code class="xref py py-meth docutils literal"><span class="pre">flush()</span></code></a> is called, this attribute contains the
frame&#8217;s data as a multi-dimensional <a class="reference external" href="http://www.numpy.org/">numpy</a> array. This is typically
organized with the dimensions <code class="docutils literal"><span class="pre">(rows,</span> <span class="pre">columns,</span> <span class="pre">plane)</span></code>. Hence, an
RGB image with dimensions <em>x</em> and <em>y</em> would produce an array with shape
<code class="docutils literal"><span class="pre">(y,</span> <span class="pre">x,</span> <span class="pre">3)</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="picamera.array.PiArrayOutput.truncate">
<code class="descname">truncate</code><span class="sig-paren">(</span><em>size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/array.html#PiArrayOutput.truncate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.array.PiArrayOutput.truncate" title="Permalink to this definition">¶</a></dt>
<dd><p>Resize the stream to the given size in bytes (or the current position
if size is not specified). This resizing can extend or reduce the
current file size.  The new file size is returned.</p>
<p>In prior versions of picamera, truncation also changed the position of
the stream (because prior versions of these stream classes were
non-seekable). This functionality is now deprecated; scripts should
use <a class="reference external" href="http://docs.python.org/3.2/library/io.html#io.IOBase.seek" title="(in Python v3.2)"><code class="xref py py-meth docutils literal"><span class="pre">seek()</span></code></a> and <a class="reference internal" href="#picamera.array.PiArrayOutput.truncate" title="picamera.array.PiArrayOutput.truncate"><code class="xref py py-meth docutils literal"><span class="pre">truncate()</span></code></a> as one would with
regular <a class="reference external" href="http://docs.python.org/3.2/library/io.html#io.BytesIO" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">BytesIO</span></code></a> instances.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="pirgbarray">
<h4>PiRGBArray<a class="headerlink" href="#pirgbarray" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.array.PiRGBArray">
<em class="property">class </em><code class="descclassname">picamera.array.</code><code class="descname">PiRGBArray</code><span class="sig-paren">(</span><em>camera</em>, <em>size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/array.html#PiRGBArray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.array.PiRGBArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces a 3-dimensional RGB array from an RGB capture.</p>
<p>This custom output class can be used to easily obtain a 3-dimensional numpy
array, organized (rows, columns, colors), from an unencoded RGB capture.
The array is accessed via the <a class="reference internal" href="#picamera.array.PiArrayOutput.array" title="picamera.array.PiArrayOutput.array"><code class="xref py py-attr docutils literal"><span class="pre">array</span></code></a> attribute. For
example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">picamera.array</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">PiRGBArray</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s">&#39;rgb&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Captured </span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s"> image&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">output</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">output</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
<p>You can re-use the output to produce multiple arrays by emptying it with
<code class="docutils literal"><span class="pre">truncate(0)</span></code> between captures:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">picamera.array</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">PiRGBArray</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s">&#39;rgb&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Captured </span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s"> image&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">output</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">output</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">output</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s">&#39;rgb&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Captured </span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s"> image&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">output</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">output</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
<p>If you are using the GPU resizer when capturing (with the <em>resize</em>
parameter of the various <a class="reference internal" href="index.html#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a>
methods), specify the resized resolution as the optional <em>size</em> parameter
when constructing the array output:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">picamera.array</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">PiRGBArray</span><span class="p">(</span><span class="n">camera</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">360</span><span class="p">))</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s">&#39;rgb&#39;</span><span class="p">,</span> <span class="n">resize</span><span class="o">=</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">360</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Captured </span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s"> image&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">output</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">output</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="piyuvarray">
<h4>PiYUVArray<a class="headerlink" href="#piyuvarray" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.array.PiYUVArray">
<em class="property">class </em><code class="descclassname">picamera.array.</code><code class="descname">PiYUVArray</code><span class="sig-paren">(</span><em>camera</em>, <em>size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/array.html#PiYUVArray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.array.PiYUVArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces 3-dimensional YUV &amp; RGB arrays from a YUV capture.</p>
<p>This custom output class can be used to easily obtain a 3-dimensional numpy
array, organized (rows, columns, channel), from an unencoded YUV capture.
The array is accessed via the <a class="reference internal" href="#picamera.array.PiArrayOutput.array" title="picamera.array.PiArrayOutput.array"><code class="xref py py-attr docutils literal"><span class="pre">array</span></code></a> attribute. For
example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">picamera.array</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">PiYUVArray</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s">&#39;yuv&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Captured </span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s"> image&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">output</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">output</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
<p>The <code class="xref py py-attr docutils literal"><span class="pre">rgb_array</span></code> attribute can be queried for the equivalent RGB
array (conversion is performed using the <a class="reference external" href="http://en.wikipedia.org/wiki/YCbCr#ITU-R_BT.601_conversion">ITU-R BT.601</a> matrix):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">picamera.array</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">PiYUVArray</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s">&#39;yuv&#39;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">rgb_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<p>If you are using the GPU resizer when capturing (with the <em>resize</em>
parameter of the various <a class="reference internal" href="index.html#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a>
methods), specify the resized resolution as the optional <em>size</em> parameter
when constructing the array output:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">picamera.array</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1280</span><span class="p">,</span> <span class="mi">720</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">PiYUVArray</span><span class="p">(</span><span class="n">camera</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">360</span><span class="p">))</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s">&#39;yuv&#39;</span><span class="p">,</span> <span class="n">resize</span><span class="o">=</span><span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">360</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Captured </span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s"> image&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">output</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">output</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="pibayerarray">
<h4>PiBayerArray<a class="headerlink" href="#pibayerarray" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.array.PiBayerArray">
<em class="property">class </em><code class="descclassname">picamera.array.</code><code class="descname">PiBayerArray</code><span class="sig-paren">(</span><em>camera</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/array.html#PiBayerArray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.array.PiBayerArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces a 3-dimensional RGB array from raw Bayer data.</p>
<p>This custom output class is intended to be used with the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a> method, with the <em>bayer</em>
parameter set to <code class="docutils literal"><span class="pre">True</span></code>, to include raw Bayer data in the JPEG output.
The class strips out the raw data, constructing a 3-dimensional numpy array
organized as (rows, columns, colors). The resulting data is accessed via
the <a class="reference internal" href="#picamera.array.PiArrayOutput.array" title="picamera.array.PiArrayOutput.array"><code class="xref py py-attr docutils literal"><span class="pre">array</span></code></a> attribute:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">picamera.array</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">PiBayerArray</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s">&#39;jpeg&#39;</span><span class="p">,</span> <span class="n">bayer</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that Bayer data is <em>always</em> full resolution, so the resulting array
always has the shape (1944, 2592, 3); this also implies that the optional
<em>size</em> parameter (for specifying a resizer resolution) is not available
with this array class. As the sensor records 10-bit values, the array uses
the unsigned 16-bit integer data type.</p>
<p>By default, <a class="reference external" href="http://en.wikipedia.org/wiki/Demosaicing">de-mosaicing</a> is <strong>not</strong> performed; if the resulting array is
viewed it will therefore appear dark and too green (due to the green bias
in the <a class="reference external" href="http://en.wikipedia.org/wiki/Bayer_filter">Bayer pattern</a>). A trivial weighted-average demosaicing algorithm
is provided in the <code class="xref py py-meth docutils literal"><span class="pre">demosaic()</span></code> method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">picamera.array</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">PiBayerArray</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">capture</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s">&#39;jpeg&#39;</span><span class="p">,</span> <span class="n">bayer</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">demosaic</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<p>Viewing the result of the de-mosaiced data will look more normal but still
considerably worse quality than the regular camera output (as none of the
other usual post-processing steps like auto-exposure, white-balance,
vignette compensation, and smoothing have been performed).</p>
</dd></dl>

</div>
<div class="section" id="pimotionarray">
<h4>PiMotionArray<a class="headerlink" href="#pimotionarray" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.array.PiMotionArray">
<em class="property">class </em><code class="descclassname">picamera.array.</code><code class="descname">PiMotionArray</code><span class="sig-paren">(</span><em>camera</em>, <em>size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/array.html#PiMotionArray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.array.PiMotionArray" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces a 3-dimensional array of motion vectors from the H.264 encoder.</p>
<p>This custom output class is intended to be used with the <em>motion_output</em>
parameter of the <a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> method.
Once recording has finished, the class generates a 3-dimensional numpy
array organized as (frames, rows, columns) where <code class="docutils literal"><span class="pre">rows</span></code> and <code class="docutils literal"><span class="pre">columns</span></code>
are the number of rows and columns of <a class="reference external" href="http://en.wikipedia.org/wiki/Macroblock">macro-blocks</a> (16x16 pixel blocks)
in the original frames. There is always one extra column of macro-blocks
present in motion vector data.</p>
<p>The data-type of the <a class="reference internal" href="#picamera.array.PiArrayOutput.array" title="picamera.array.PiArrayOutput.array"><code class="xref py py-attr docutils literal"><span class="pre">array</span></code></a> is an (x, y, sad)
structure where <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> are signed 1-byte values, and <code class="docutils literal"><span class="pre">sad</span></code> is an
unsigned 2-byte value representing the <a class="reference external" href="http://en.wikipedia.org/wiki/Sum_of_absolute_differences">sum of absolute differences</a> of
the block. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">picamera.array</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">PiMotionArray</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">start_recording</span><span class="p">(</span>
              <span class="s">&#39;/dev/null&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;h264&#39;</span><span class="p">,</span> <span class="n">motion_output</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">stop_recording</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Captured </span><span class="si">%d</span><span class="s"> frames&#39;</span> <span class="o">%</span> <span class="n">output</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Frames are </span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s"> blocks big&#39;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">output</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">output</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<p>If you are using the GPU resizer with your recording, use the optional
<em>size</em> parameter to specify the resizer&#8217;s output resolution when
constructing the array:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">picamera.array</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">PiMotionArray</span><span class="p">(</span><span class="n">camera</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">320</span><span class="p">,</span> <span class="mi">240</span><span class="p">))</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">start_recording</span><span class="p">(</span>
            <span class="s">&#39;/dev/null&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;h264&#39;</span><span class="p">,</span> <span class="n">motion_output</span><span class="o">=</span><span class="n">output</span><span class="p">,</span>
            <span class="n">resize</span><span class="o">=</span><span class="p">(</span><span class="mi">320</span><span class="p">,</span> <span class="mi">240</span><span class="p">))</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">stop_recording</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Captured </span><span class="si">%d</span><span class="s"> frames&#39;</span> <span class="o">%</span> <span class="n">output</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Frames are </span><span class="si">%d</span><span class="s">x</span><span class="si">%d</span><span class="s"> blocks big&#39;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">output</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">output</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class is not suitable for real-time analysis of motion vector
data. See the <a class="reference internal" href="#picamera.array.PiMotionAnalysis" title="picamera.array.PiMotionAnalysis"><code class="xref py py-class docutils literal"><span class="pre">PiMotionAnalysis</span></code></a> class instead.</p>
</div>
</dd></dl>

</div>
<div class="section" id="pianalysisoutput">
<h4>PiAnalysisOutput<a class="headerlink" href="#pianalysisoutput" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.array.PiAnalysisOutput">
<em class="property">class </em><code class="descclassname">picamera.array.</code><code class="descname">PiAnalysisOutput</code><span class="sig-paren">(</span><em>camera</em>, <em>size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/array.html#PiAnalysisOutput"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.array.PiAnalysisOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for analysis outputs.</p>
<p>This class extends <a class="reference external" href="http://docs.python.org/3.2/library/io.html#io.IOBase" title="(in Python v3.2)"><code class="xref py py-class docutils literal"><span class="pre">io.IOBase</span></code></a> with a stub <a class="reference internal" href="#picamera.array.PiAnalysisOutput.analyse" title="picamera.array.PiAnalysisOutput.analyse"><code class="xref py py-meth docutils literal"><span class="pre">analyse()</span></code></a> method
which will be called for each frame output. In this base implementation the
method simply raises <a class="reference external" href="http://docs.python.org/3.2/library/exceptions.html#NotImplementedError" title="(in Python v3.2)"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a>.</p>
<dl class="method">
<dt id="picamera.array.PiAnalysisOutput.analyse">
<code class="descname">analyse</code><span class="sig-paren">(</span><em>array</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/array.html#PiAnalysisOutput.analyse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.array.PiAnalysisOutput.analyse" title="Permalink to this definition">¶</a></dt>
<dd><p>Stub method for users to override.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="pirgbanalysis">
<h4>PiRGBAnalysis<a class="headerlink" href="#pirgbanalysis" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.array.PiRGBAnalysis">
<em class="property">class </em><code class="descclassname">picamera.array.</code><code class="descname">PiRGBAnalysis</code><span class="sig-paren">(</span><em>camera</em>, <em>size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/array.html#PiRGBAnalysis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.array.PiRGBAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a basis for per-frame RGB analysis classes.</p>
<p>This custom output class is intended to be used with the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> method when it is called
with <em>format</em> set to <code class="docutils literal"><span class="pre">'rgb'</span></code> or <code class="docutils literal"><span class="pre">'bgr'</span></code>. While recording is in
progress, the <code class="xref py py-meth docutils literal"><span class="pre">write()</span></code> method converts incoming
frame data into a numpy array and calls the stub
<a class="reference internal" href="#picamera.array.PiAnalysisOutput.analyse" title="picamera.array.PiAnalysisOutput.analyse"><code class="xref py py-meth docutils literal"><span class="pre">analyse()</span></code></a> method with the resulting array (this
deliberately raises <a class="reference external" href="http://docs.python.org/3.2/library/exceptions.html#NotImplementedError" title="(in Python v3.2)"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a> in this class; you must
override it in your descendent class).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Because the <a class="reference internal" href="#picamera.array.PiAnalysisOutput.analyse" title="picamera.array.PiAnalysisOutput.analyse"><code class="xref py py-meth docutils literal"><span class="pre">analyse()</span></code></a> method will be running
within the encoder&#8217;s callback, it must be <strong>fast</strong>. Specifically, it
needs to return before the next frame is produced. Therefore, if the
camera is running at 30fps, analyse cannot take more than 1/30s or 33ms
to execute (and should take considerably less given that this doesn&#8217;t
take into account encoding overhead). You may wish to adjust the
framerate of the camera accordingly.</p>
</div>
<p>The array passed to <a class="reference internal" href="#picamera.array.PiAnalysisOutput.analyse" title="picamera.array.PiAnalysisOutput.analyse"><code class="xref py py-meth docutils literal"><span class="pre">analyse()</span></code></a> is organized as
(rows, columns, channel) where the channels 0, 1, and 2 are R, G, and B
respectively (or B, G, R if <em>format</em> is <code class="docutils literal"><span class="pre">'bgr'</span></code>).</p>
</dd></dl>

</div>
<div class="section" id="piyuvanalysis">
<h4>PiYUVAnalysis<a class="headerlink" href="#piyuvanalysis" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.array.PiYUVAnalysis">
<em class="property">class </em><code class="descclassname">picamera.array.</code><code class="descname">PiYUVAnalysis</code><span class="sig-paren">(</span><em>camera</em>, <em>size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/array.html#PiYUVAnalysis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.array.PiYUVAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a basis for per-frame YUV analysis classes.</p>
<p>This custom output class is intended to be used with the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> method when it is called
with <em>format</em> set to <code class="docutils literal"><span class="pre">'yuv'</span></code>. While recording is in progress, the
<code class="xref py py-meth docutils literal"><span class="pre">write()</span></code> method converts incoming frame data into a
numpy array and calls the stub <a class="reference internal" href="#picamera.array.PiAnalysisOutput.analyse" title="picamera.array.PiAnalysisOutput.analyse"><code class="xref py py-meth docutils literal"><span class="pre">analyse()</span></code></a> method
with the resulting array (this deliberately raises
<a class="reference external" href="http://docs.python.org/3.2/library/exceptions.html#NotImplementedError" title="(in Python v3.2)"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a> in this class; you must override it in your
descendent class).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Because the <a class="reference internal" href="#picamera.array.PiAnalysisOutput.analyse" title="picamera.array.PiAnalysisOutput.analyse"><code class="xref py py-meth docutils literal"><span class="pre">analyse()</span></code></a> method will be running
within the encoder&#8217;s callback, it must be <strong>fast</strong>. Specifically, it
needs to return before the next frame is produced. Therefore, if the
camera is running at 30fps, analyse cannot take more than 1/30s or 33ms
to execute (and should take considerably less given that this doesn&#8217;t
take into account encoding overhead). You may wish to adjust the
framerate of the camera accordingly.</p>
</div>
<p>The array passed to <a class="reference internal" href="#picamera.array.PiAnalysisOutput.analyse" title="picamera.array.PiAnalysisOutput.analyse"><code class="xref py py-meth docutils literal"><span class="pre">analyse()</span></code></a> is organized as
(rows, columns, channel) where the channel 0 is Y (luminance), while 1 and
2 are U and V (chrominance) respectively. The chrominance values normally
have quarter resolution of the luminance values but this class makes all
channels equal resolution for ease of use.</p>
</dd></dl>

</div>
<div class="section" id="pimotionanalysis">
<h4>PiMotionAnalysis<a class="headerlink" href="#pimotionanalysis" title="Permalink to this headline">¶</a></h4>
<dl class="class">
<dt id="picamera.array.PiMotionAnalysis">
<em class="property">class </em><code class="descclassname">picamera.array.</code><code class="descname">PiMotionAnalysis</code><span class="sig-paren">(</span><em>camera</em>, <em>size=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/array.html#PiMotionAnalysis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.array.PiMotionAnalysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a basis for real-time motion analysis classes.</p>
<p>This custom output class is intended to be used with the <em>motion_output</em>
parameter of the <a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> method.
While recording is in progress, the write method converts incoming motion
data into numpy arrays and calls the stub <a class="reference internal" href="#picamera.array.PiAnalysisOutput.analyse" title="picamera.array.PiAnalysisOutput.analyse"><code class="xref py py-meth docutils literal"><span class="pre">analyse()</span></code></a>
method with the resulting array (which deliberately raises
<a class="reference external" href="http://docs.python.org/3.2/library/exceptions.html#NotImplementedError" title="(in Python v3.2)"><code class="xref py py-exc docutils literal"><span class="pre">NotImplementedError</span></code></a> in this class).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Because the <a class="reference internal" href="#picamera.array.PiAnalysisOutput.analyse" title="picamera.array.PiAnalysisOutput.analyse"><code class="xref py py-meth docutils literal"><span class="pre">analyse()</span></code></a> method will be running
within the encoder&#8217;s callback, it must be <strong>fast</strong>. Specifically, it
needs to return before the next frame is produced. Therefore, if the
camera is running at 30fps, analyse cannot take more than 1/30s or 33ms
to execute (and should take considerably less given that this doesn&#8217;t
take into account encoding overhead). You may wish to adjust the
framerate of the camera accordingly.</p>
</div>
<p>The array passed to <a class="reference internal" href="#picamera.array.PiAnalysisOutput.analyse" title="picamera.array.PiAnalysisOutput.analyse"><code class="xref py py-meth docutils literal"><span class="pre">analyse()</span></code></a> is organized as
(rows, columns) where <code class="docutils literal"><span class="pre">rows</span></code> and <code class="docutils literal"><span class="pre">columns</span></code> are the number of rows and
columns of <a class="reference external" href="http://en.wikipedia.org/wiki/Macroblock">macro-blocks</a> (16x16 pixel blocks) in the original frames.
There is always one extra column of macro-blocks present in motion vector
data.</p>
<p>The data-type of the array is an (x, y, sad) structure where <code class="docutils literal"><span class="pre">x</span></code> and
<code class="docutils literal"><span class="pre">y</span></code> are signed 1-byte values, and <code class="docutils literal"><span class="pre">sad</span></code> is an unsigned 2-byte value
representing the <a class="reference external" href="http://en.wikipedia.org/wiki/Sum_of_absolute_differences">sum of absolute differences</a> of the block.</p>
<p>An example of a crude motion detector is given below:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">picamera</span>
<span class="kn">import</span> <span class="nn">picamera.array</span>

<span class="k">class</span> <span class="nc">DetectMotion</span><span class="p">(</span><span class="n">picamera</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">PiMotionAnalysis</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">analyse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="s">&#39;x&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">))</span> <span class="o">+</span>
            <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="s">&#39;y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">))</span>
            <span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="c"># If there&#39;re more than 10 vectors with a magnitude greater</span>
        <span class="c"># than 60, then say we&#39;ve detected motion</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">60</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;Motion detected!&#39;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">picamera</span><span class="o">.</span><span class="n">PiCamera</span><span class="p">()</span> <span class="k">as</span> <span class="n">camera</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">DetectMotion</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span> <span class="k">as</span> <span class="n">output</span><span class="p">:</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="p">(</span><span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">start_recording</span><span class="p">(</span>
              <span class="s">&#39;/dev/null&#39;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;h264&#39;</span><span class="p">,</span> <span class="n">motion_output</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">wait_recording</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
        <span class="n">camera</span><span class="o">.</span><span class="n">stop_recording</span><span class="p">()</span>
</pre></div>
</div>
<p>You can use the optional <em>size</em> parameter to specify the output resolution
of the GPU resizer, if you are using the <em>resize</em> parameter of
<a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a>.</p>
</dd></dl>

</div>
</div>
<span id="document-api_exc"></span><div class="section" id="module-picamera.exc">
<span id="api-picamera-exc-module"></span><span id="api-exc"></span><h3>API - <code class="docutils literal"><span class="pre">picamera.exc</span></code> Module<a class="headerlink" href="#module-picamera.exc" title="Permalink to this headline">¶</a></h3>
<p>This module defines the exceptions used by picamera. All exception classes
utilize multiple inheritance in order to make testing for exception types more
intuitive. For example, <a class="reference internal" href="#picamera.exc.PiCameraValueError" title="picamera.exc.PiCameraValueError"><code class="xref py py-exc docutils literal"><span class="pre">PiCameraValueError</span></code></a> derives from both
<a class="reference internal" href="#picamera.exc.PiCameraError" title="picamera.exc.PiCameraError"><code class="xref py py-exc docutils literal"><span class="pre">PiCameraError</span></code></a> and <a class="reference external" href="http://docs.python.org/3.2/library/exceptions.html#ValueError" title="(in Python v3.2)"><code class="xref py py-exc docutils literal"><span class="pre">ValueError</span></code></a>. Hence it will be caught by blocks
intended to catch any error specific to the picamera library:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">try</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">brightness</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">some_user_value</span><span class="p">)</span>
<span class="k">except</span> <span class="n">PiCameraError</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Something went wrong with the camera&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Or by blocks intended to catch value errors:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">try</span><span class="p">:</span>
    <span class="n">camera</span><span class="o">.</span><span class="n">contrast</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">some_user_value</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Invalid value&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All classes in this module are available from the <a class="reference internal" href="index.html#module-picamera" title="picamera"><code class="xref py py-mod docutils literal"><span class="pre">picamera</span></code></a> namespace
without having to import <a class="reference internal" href="index.html#module-picamera.streams" title="picamera.streams"><code class="xref py py-mod docutils literal"><span class="pre">picamera.streams</span></code></a> directly.</p>
</div>
<p>The following classes are defined in the module:</p>
<dl class="exception">
<dt id="picamera.exc.PiCameraWarning">
<em class="property">exception </em><code class="descclassname">picamera.exc.</code><code class="descname">PiCameraWarning</code><a class="reference internal" href="_modules/picamera/exc.html#PiCameraWarning"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.exc.PiCameraWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for PiCamera warnings.</p>
</dd></dl>

<dl class="exception">
<dt id="picamera.exc.PiCameraDeprecated">
<em class="property">exception </em><code class="descclassname">picamera.exc.</code><code class="descname">PiCameraDeprecated</code><a class="reference internal" href="_modules/picamera/exc.html#PiCameraDeprecated"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.exc.PiCameraDeprecated" title="Permalink to this definition">¶</a></dt>
<dd><p>Raised when deprecated functionality in picamera is used.</p>
</dd></dl>

<dl class="exception">
<dt id="picamera.exc.PiCameraFallback">
<em class="property">exception </em><code class="descclassname">picamera.exc.</code><code class="descname">PiCameraFallback</code><a class="reference internal" href="_modules/picamera/exc.html#PiCameraFallback"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.exc.PiCameraFallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Raised when picamera has to fallback on old functionality.</p>
</dd></dl>

<dl class="exception">
<dt id="picamera.exc.PiCameraError">
<em class="property">exception </em><code class="descclassname">picamera.exc.</code><code class="descname">PiCameraError</code><a class="reference internal" href="_modules/picamera/exc.html#PiCameraError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.exc.PiCameraError" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for PiCamera errors.</p>
</dd></dl>

<dl class="exception">
<dt id="picamera.exc.PiCameraValueError">
<em class="property">exception </em><code class="descclassname">picamera.exc.</code><code class="descname">PiCameraValueError</code><a class="reference internal" href="_modules/picamera/exc.html#PiCameraValueError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.exc.PiCameraValueError" title="Permalink to this definition">¶</a></dt>
<dd><p>Raised when an invalid value is fed to a <a class="reference internal" href="index.html#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a>
object.</p>
</dd></dl>

<dl class="exception">
<dt id="picamera.exc.PiCameraRuntimeError">
<em class="property">exception </em><code class="descclassname">picamera.exc.</code><code class="descname">PiCameraRuntimeError</code><a class="reference internal" href="_modules/picamera/exc.html#PiCameraRuntimeError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.exc.PiCameraRuntimeError" title="Permalink to this definition">¶</a></dt>
<dd><p>Raised when an invalid sequence of operations is attempted with a
<a class="reference internal" href="index.html#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a> object.</p>
</dd></dl>

<dl class="exception">
<dt id="picamera.exc.PiCameraClosed">
<em class="property">exception </em><code class="descclassname">picamera.exc.</code><code class="descname">PiCameraClosed</code><a class="reference internal" href="_modules/picamera/exc.html#PiCameraClosed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.exc.PiCameraClosed" title="Permalink to this definition">¶</a></dt>
<dd><p>Raised when a method is called on a camera which has already been closed.</p>
</dd></dl>

<dl class="exception">
<dt id="picamera.exc.PiCameraNotRecording">
<em class="property">exception </em><code class="descclassname">picamera.exc.</code><code class="descname">PiCameraNotRecording</code><a class="reference internal" href="_modules/picamera/exc.html#PiCameraNotRecording"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.exc.PiCameraNotRecording" title="Permalink to this definition">¶</a></dt>
<dd><p>Raised when <a class="reference internal" href="index.html#picamera.camera.PiCamera.stop_recording" title="picamera.camera.PiCamera.stop_recording"><code class="xref py py-meth docutils literal"><span class="pre">stop_recording()</span></code></a> or
<a class="reference internal" href="index.html#picamera.camera.PiCamera.split_recording" title="picamera.camera.PiCamera.split_recording"><code class="xref py py-meth docutils literal"><span class="pre">split_recording()</span></code></a> are called against a port
which has no recording active.</p>
</dd></dl>

<dl class="exception">
<dt id="picamera.exc.PiCameraAlreadyRecording">
<em class="property">exception </em><code class="descclassname">picamera.exc.</code><code class="descname">PiCameraAlreadyRecording</code><a class="reference internal" href="_modules/picamera/exc.html#PiCameraAlreadyRecording"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.exc.PiCameraAlreadyRecording" title="Permalink to this definition">¶</a></dt>
<dd><p>Raised when <a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> or
<a class="reference internal" href="index.html#picamera.camera.PiCamera.record_sequence" title="picamera.camera.PiCamera.record_sequence"><code class="xref py py-meth docutils literal"><span class="pre">record_sequence()</span></code></a> are called against a port
which already has an active recording.</p>
</dd></dl>

<dl class="exception">
<dt id="picamera.exc.PiCameraMMALError">
<em class="property">exception </em><code class="descclassname">picamera.exc.</code><code class="descname">PiCameraMMALError</code><span class="sig-paren">(</span><em>status</em>, <em>prefix=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/exc.html#PiCameraMMALError"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.exc.PiCameraMMALError" title="Permalink to this definition">¶</a></dt>
<dd><p>Raised when an MMAL operation fails for whatever reason.</p>
</dd></dl>

<dl class="function">
<dt id="picamera.exc.mmal_check">
<code class="descclassname">picamera.exc.</code><code class="descname">mmal_check</code><span class="sig-paren">(</span><em>status</em>, <em>prefix=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/picamera/exc.html#mmal_check"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#picamera.exc.mmal_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks the return status of an mmal call and raises an exception on
failure.</p>
<p>The <em>status</em> parameter is the result of an MMAL call. If <em>status</em> is
anything other than MMAL_SUCCESS, a <a class="reference internal" href="#picamera.exc.PiCameraMMALError" title="picamera.exc.PiCameraMMALError"><code class="xref py py-exc docutils literal"><span class="pre">PiCameraMMALError</span></code></a> exception is
raised. The optional <em>prefix</em> parameter specifies a prefix message to place
at the start of the exception&#8217;s message to provide some context.</p>
</dd></dl>

</div>
<span id="document-changelog"></span><div class="section" id="change-log">
<span id="changelog"></span><h3>Change log<a class="headerlink" href="#change-log" title="Permalink to this headline">¶</a></h3>
<div class="section" id="release-1-10-2014-03-31">
<h4>Release 1.10 (2014-03-31)<a class="headerlink" href="#release-1-10-2014-03-31" title="Permalink to this headline">¶</a></h4>
<p>1.10 consists mostly of minor enhancements:</p>
<ul class="simple">
<li>The major enhancement is the addition of support for the camera&#8217;s flash
driver. This is relatively complex to configure, but a full recipe has been
included in the documentation (<a class="reference external" href="https://github.com/waveform80/picamera/issues/184">#184</a>)</li>
<li>A new <cite>intra_refresh</cite> attribute is added to the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> method permitting control
of the intra-frame refresh method (<a class="reference external" href="https://github.com/waveform80/picamera/issues/193">#193</a>)</li>
<li>The GPIO pins controlling the camera&#8217;s LED are now configurable. This is
mainly for any compute module users, but also for anyone who wishes to use
the device tree blob to reconfigure the pins used (<a class="reference external" href="https://github.com/waveform80/picamera/issues/198">#198</a>)</li>
<li>The new annotate V3 struct is now supported, providing custom background
colors for annotations, and configurable text size. As part of this work
a new <a class="reference internal" href="index.html#picamera.color.Color" title="picamera.color.Color"><code class="xref py py-class docutils literal"><span class="pre">Color</span></code></a> class was introduced for representation
and manipulation of colors (<a class="reference external" href="https://github.com/waveform80/picamera/issues/203">#203</a>)</li>
<li>Reverse enumeration of frames in
<a class="reference internal" href="index.html#picamera.streams.PiCameraCircularIO" title="picamera.streams.PiCameraCircularIO"><code class="xref py py-class docutils literal"><span class="pre">PiCameraCircularIO</span></code></a> is now supported efficiently
(without having to convert frames to a list first) (<a class="reference external" href="https://github.com/waveform80/picamera/issues/204">#204</a>)</li>
<li>Finally, the API documentation has been re-worked as it was getting too
large to comfortably load on all platforms (no ticket)</li>
</ul>
</div>
<div class="section" id="release-1-9-2015-01-01">
<h4>Release 1.9 (2015-01-01)<a class="headerlink" href="#release-1-9-2015-01-01" title="Permalink to this headline">¶</a></h4>
<p>1.9 consists mostly of bug fixes with a couple of minor new features:</p>
<ul class="simple">
<li>The camera&#8217;s sensor mode can now be forced to a particular setting upon
camera initialization with the new <code class="docutils literal"><span class="pre">sensor_mode</span></code> parameter to
<a class="reference internal" href="index.html#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a> (<a class="reference external" href="https://github.com/waveform80/picamera/issues/165">#165</a>)</li>
<li>The camera&#8217;s initial framerate and resolution can also be specified as
keyword arguments to the <a class="reference internal" href="index.html#picamera.camera.PiCamera" title="picamera.camera.PiCamera"><code class="xref py py-class docutils literal"><span class="pre">PiCamera</span></code></a> initializer. This
is primarily intended to reduce initialization time (<a class="reference external" href="https://github.com/waveform80/picamera/issues/180">#180</a>)</li>
<li>Added the <a class="reference internal" href="index.html#picamera.camera.PiCamera.still_stats" title="picamera.camera.PiCamera.still_stats"><code class="xref py py-attr docutils literal"><span class="pre">still_stats</span></code></a> attribute which
controls whether an extra statistics pass is made when capturing images from
the still port (<a class="reference external" href="https://github.com/waveform80/picamera/issues/166">#166</a>)</li>
<li>Fixed the <a class="reference internal" href="index.html#picamera.camera.PiCamera.led" title="picamera.camera.PiCamera.led"><code class="xref py py-attr docutils literal"><span class="pre">led</span></code></a> attribute so it should now
work on the Raspberry Pi model B+ (<a class="reference external" href="https://github.com/waveform80/picamera/issues/170">#170</a>)</li>
<li>Fixed a nasty memory leak in overlay renderers which caused the camera to run
out of memory when overlays were repeatedly created and destroyed (<a class="reference external" href="https://github.com/waveform80/picamera/issues/174">#174</a>) *
Fixed a long standing issue with MJPEG recording which caused camera lockups
when resolutions greater than VGA were used (<a class="reference external" href="https://github.com/waveform80/picamera/issues/47">#47</a> and <a class="reference external" href="https://github.com/waveform80/picamera/issues/179">#179</a>)</li>
<li>Fixed a bug with incorrect frame metadata in
<a class="reference internal" href="index.html#picamera.streams.PiCameraCircularIO" title="picamera.streams.PiCameraCircularIO"><code class="xref py py-class docutils literal"><span class="pre">PiCameraCircularIO</span></code></a>. Unfortunately this required
breaking backwards compatibility to some extent. If you use this class and
rely on the frame metadata, please familiarize yourself with the new
<a class="reference internal" href="index.html#picamera.encoders.PiVideoFrame.complete" title="picamera.encoders.PiVideoFrame.complete"><code class="xref py py-attr docutils literal"><span class="pre">complete</span></code></a> attribute (<a class="reference external" href="https://github.com/waveform80/picamera/issues/177">#177</a>)</li>
<li>Fixed a bug which caused <a class="reference internal" href="index.html#picamera.streams.PiCameraCircularIO" title="picamera.streams.PiCameraCircularIO"><code class="xref py py-class docutils literal"><span class="pre">PiCameraCircularIO</span></code></a> to
ignore the splitter port it was recording against (<a class="reference external" href="https://github.com/waveform80/picamera/issues/176">#176</a>)</li>
<li>Several documentation issues got fixed too (<a class="reference external" href="https://github.com/waveform80/picamera/issues/167">#167</a>, <a class="reference external" href="https://github.com/waveform80/picamera/issues/168">#168</a>, <a class="reference external" href="https://github.com/waveform80/picamera/issues/171">#171</a>,
<a class="reference external" href="https://github.com/waveform80/picamera/issues/172">#172</a>, <a class="reference external" href="https://github.com/waveform80/picamera/issues/182">#182</a>)</li>
</ul>
<p>Many thanks to the community for providing several of these fixes as pull
requests, and thanks for all the great bug reports. Happy new year everyone!</p>
</div>
<div class="section" id="release-1-8-2014-09-05">
<h4>Release 1.8 (2014-09-05)<a class="headerlink" href="#release-1-8-2014-09-05" title="Permalink to this headline">¶</a></h4>
<p>1.8 consists of several new features and the usual bug fixes:</p>
<ul class="simple">
<li>A new chapter on detecting and correcting deprecated functionality was added
to the docs (<a class="reference external" href="https://github.com/waveform80/picamera/issues/149">#149</a>)</li>
<li>Stereoscopic cameras are now tentatively supported on the Pi compute module.
Please note I have no hardware for testing this, so the implementation is
possibly (probably!) wrong; bug reports welcome! (<a class="reference external" href="https://github.com/waveform80/picamera/issues/153">#153</a>)</li>
<li>Text annotation functionality has been extended; up to 255 characters are now
possible, and the new <a class="reference internal" href="index.html#picamera.camera.PiCamera.annotate_frame_num" title="picamera.camera.PiCamera.annotate_frame_num"><code class="xref py py-attr docutils literal"><span class="pre">annotate_frame_num</span></code></a>
attribute adds rendering of the current frame number. In addition, the new
<a class="reference internal" href="index.html#picamera.camera.PiCamera.annotate_background" title="picamera.camera.PiCamera.annotate_background"><code class="xref py py-attr docutils literal"><span class="pre">annotate_background</span></code></a> flag permits a dark
background to be rendered behind all annotations for contrast (<a class="reference external" href="https://github.com/waveform80/picamera/issues/160">#160</a>)</li>
<li>Arbitrary image overlays can now be drawn on the preview using the new
<a class="reference internal" href="index.html#picamera.camera.PiCamera.add_overlay" title="picamera.camera.PiCamera.add_overlay"><code class="xref py py-meth docutils literal"><span class="pre">add_overlay()</span></code></a> method. A new recipe has been
included demonstrating overlays from PIL images and numpy arrays. As part of
this work the preview system was substantially changed; all older scripts
should continue to work but please be aware that most preview attributes are
now deprecated; the new <a class="reference internal" href="index.html#picamera.camera.PiCamera.preview" title="picamera.camera.PiCamera.preview"><code class="xref py py-attr docutils literal"><span class="pre">preview</span></code></a> attribute
replaces them (<a class="reference external" href="https://github.com/waveform80/picamera/issues/144">#144</a>)</li>
<li>Image effect parameters can now be controlled via the new
<a class="reference internal" href="index.html#picamera.camera.PiCamera.image_effect_params" title="picamera.camera.PiCamera.image_effect_params"><code class="xref py py-attr docutils literal"><span class="pre">image_effect_params</span></code></a> attribute (<a class="reference external" href="https://github.com/waveform80/picamera/issues/143">#143</a>)</li>
<li>A bug in the handling of framerates meant that long exposures (&gt;1s) weren&#8217;t
operating correctly. This <em>should</em> be fixed, but I&#8217;d be grateful if users
could test this and let me know for certain (Exif metadata reports the
configured exposure speed so it can&#8217;t be used to determine if things are
actually working) (<a class="reference external" href="https://github.com/waveform80/picamera/issues/135">#135</a>)</li>
<li>A bug in 1.7 broke compatibility with older firmwares (resulting in an error
message mentioning &#8220;mmal_queue_timedwait&#8221;). The library should now on older
firmwares (<a class="reference external" href="https://github.com/waveform80/picamera/issues/154">#154</a>)</li>
<li>Finally, the confusingly named <a class="reference internal" href="index.html#picamera.camera.PiCamera.crop" title="picamera.camera.PiCamera.crop"><code class="xref py py-attr docutils literal"><span class="pre">crop</span></code></a>
attribute was changed to a deprecated alias for the new
<a class="reference internal" href="index.html#picamera.camera.PiCamera.zoom" title="picamera.camera.PiCamera.zoom"><code class="xref py py-attr docutils literal"><span class="pre">zoom</span></code></a> attribute (<a class="reference external" href="https://github.com/waveform80/picamera/issues/146">#146</a>)</li>
</ul>
</div>
<div class="section" id="release-1-7-2014-08-08">
<h4>Release 1.7 (2014-08-08)<a class="headerlink" href="#release-1-7-2014-08-08" title="Permalink to this headline">¶</a></h4>
<p>1.7 consists once more of new features, and more bug fixes:</p>
<ul class="simple">
<li>Text overlay on preview, image, and video output is now possible (<a class="reference external" href="https://github.com/waveform80/picamera/issues/16">#16</a>)</li>
<li>Support for more than one camera on the compute module has been added, but
hasn&#8217;t been tested yet (<a class="reference external" href="https://github.com/waveform80/picamera/issues/84">#84</a>)</li>
<li>The <a class="reference internal" href="index.html#picamera.camera.PiCamera.exposure_mode" title="picamera.camera.PiCamera.exposure_mode"><code class="xref py py-attr docutils literal"><span class="pre">exposure_mode</span></code></a> <code class="docutils literal"><span class="pre">'off'</span></code> has been added
to allow locking down the exposure time, along with some new recipes
demonstrating this capability (<a class="reference external" href="https://github.com/waveform80/picamera/issues/116">#116</a>)</li>
<li>The valid values for various attributes including
<a class="reference internal" href="index.html#picamera.camera.PiCamera.awb_mode" title="picamera.camera.PiCamera.awb_mode"><code class="xref py py-attr docutils literal"><span class="pre">awb_mode</span></code></a>,
<a class="reference internal" href="index.html#picamera.camera.PiCamera.meter_mode" title="picamera.camera.PiCamera.meter_mode"><code class="xref py py-attr docutils literal"><span class="pre">meter_mode</span></code></a>, and
<a class="reference internal" href="index.html#picamera.camera.PiCamera.exposure_mode" title="picamera.camera.PiCamera.exposure_mode"><code class="xref py py-attr docutils literal"><span class="pre">exposure_mode</span></code></a> are now automatically
included in the documentation (<a class="reference external" href="https://github.com/waveform80/picamera/issues/130">#130</a>)</li>
<li>Support for unencoded formats (YUV, RGB, etc.) has been added to the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> method (<a class="reference external" href="https://github.com/waveform80/picamera/issues/132">#132</a>)</li>
<li>A couple of analysis classes have been added to <a class="reference internal" href="index.html#module-picamera.array" title="picamera.array"><code class="xref py py-mod docutils literal"><span class="pre">picamera.array</span></code></a> to
support the new unencoded recording formats (<a class="reference external" href="https://github.com/waveform80/picamera/issues/139">#139</a>)</li>
<li>Several issues in the <a class="reference internal" href="index.html#picamera.array.PiBayerArray" title="picamera.array.PiBayerArray"><code class="xref py py-class docutils literal"><span class="pre">PiBayerArray</span></code></a> class were fixed;
this should now work correctly with Python 3, and the
<code class="xref py py-meth docutils literal"><span class="pre">demosaic()</span></code> method should operate correctly
(<a class="reference external" href="https://github.com/waveform80/picamera/issues/133">#133</a>, <a class="reference external" href="https://github.com/waveform80/picamera/issues/134">#134</a>)</li>
<li>A major issue with multi-resolution recordings which caused all recordings
to stop prematurely was fixed (<a class="reference external" href="https://github.com/waveform80/picamera/issues/136">#136</a>)</li>
<li>Finally, an issue with the example in the documentation for custom encoders
was fixed (<a class="reference external" href="https://github.com/waveform80/picamera/issues/128">#128</a>)</li>
</ul>
<p>Once again, many thanks to the community for another round of excellent bug
reports - and many thanks to 6by9 and jamesh for their excellent work on the
firmware and official utilities!</p>
</div>
<div class="section" id="release-1-6-2014-07-21">
<h4>Release 1.6 (2014-07-21)<a class="headerlink" href="#release-1-6-2014-07-21" title="Permalink to this headline">¶</a></h4>
<p>1.6 is half bug fixes, half new features:</p>
<ul class="simple">
<li>The <a class="reference internal" href="index.html#picamera.camera.PiCamera.awb_gains" title="picamera.camera.PiCamera.awb_gains"><code class="xref py py-attr docutils literal"><span class="pre">awb_gains</span></code></a> attribute is no longer write-only;
you can now read it to determine the red/blue balance that the camera is
using (<a class="reference external" href="https://github.com/waveform80/picamera/issues/98">#98</a>)</li>
<li>The new read-only <a class="reference internal" href="index.html#picamera.camera.PiCamera.exposure_speed" title="picamera.camera.PiCamera.exposure_speed"><code class="xref py py-attr docutils literal"><span class="pre">exposure_speed</span></code></a> attribute
will tell you the shutter speed the camera&#8217;s auto-exposure has determined, or
the shutter speed you&#8217;ve forced with a non-zero value of
<a class="reference internal" href="index.html#picamera.camera.PiCamera.shutter_speed" title="picamera.camera.PiCamera.shutter_speed"><code class="xref py py-attr docutils literal"><span class="pre">shutter_speed</span></code></a> (<a class="reference external" href="https://github.com/waveform80/picamera/issues/98">#98</a>)</li>
<li>The new read-only <a class="reference internal" href="index.html#picamera.camera.PiCamera.analog_gain" title="picamera.camera.PiCamera.analog_gain"><code class="xref py py-attr docutils literal"><span class="pre">analog_gain</span></code></a> and
<a class="reference internal" href="index.html#picamera.camera.PiCamera.digital_gain" title="picamera.camera.PiCamera.digital_gain"><code class="xref py py-attr docutils literal"><span class="pre">digital_gain</span></code></a> attributes can be used to
determine the amount of gain the camera is applying at a couple of crucial
points of the image processing pipeline (<a class="reference external" href="https://github.com/waveform80/picamera/issues/98">#98</a>)</li>
<li>The new <a class="reference internal" href="index.html#picamera.camera.PiCamera.drc_strength" title="picamera.camera.PiCamera.drc_strength"><code class="xref py py-attr docutils literal"><span class="pre">drc_strength</span></code></a> attribute can be used
to query and set the amount of dynamic range compression the camera will
apply to its output (<a class="reference external" href="https://github.com/waveform80/picamera/issues/110">#110</a>)</li>
<li>The <cite>intra_period</cite> parameter for
<a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> can now be set to <cite>0</cite>
(which means &#8220;produce one initial I-frame, then just P-frames&#8221;) (<a class="reference external" href="https://github.com/waveform80/picamera/issues/117">#117</a>)</li>
<li>The <cite>burst</cite> parameter was added to the various
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a> methods; users are strongly advised
to read the cautions in the docs before relying on this parameter (<a class="reference external" href="https://github.com/waveform80/picamera/issues/115">#115</a>)</li>
<li>One of the advanced recipes in the manual (&#8220;splitting to/from a circular
stream&#8221;) failed under 1.5 due to a lack of splitter-port support in the
circular I/O stream class. This has now been rectified by adding a
<cite>splitter_port</cite> parameter to the constructor of
<a class="reference internal" href="index.html#picamera.streams.PiCameraCircularIO" title="picamera.streams.PiCameraCircularIO"><code class="xref py py-class docutils literal"><span class="pre">PiCameraCircularIO</span></code></a> (<a class="reference external" href="https://github.com/waveform80/picamera/issues/109">#109</a>)</li>
<li>Similarly, the <a class="reference internal" href="index.html#module-picamera.array" title="picamera.array"><code class="xref py py-mod docutils literal"><span class="pre">array</span> <span class="pre">extensions</span></code></a> introduced in 1.5
failed to work when resizers were present in the pipeline. This has been
fixed by adding a <cite>size</cite> parameter to the constructor of all the custom
output classes defined in that module (<a class="reference external" href="https://github.com/waveform80/picamera/issues/121">#121</a>)</li>
<li>A bug that caused picamera to fail when the display was disabled has been
squashed (<a class="reference external" href="https://github.com/waveform80/picamera/issues/120">#120</a>)</li>
</ul>
<p>As always, many thanks to the community for another great set of bug reports!</p>
</div>
<div class="section" id="release-1-5-2014-06-11">
<h4>Release 1.5 (2014-06-11)<a class="headerlink" href="#release-1-5-2014-06-11" title="Permalink to this headline">¶</a></h4>
<p>1.5 fixed several bugs and introduced a couple of major new pieces of
functionality:</p>
<ul class="simple">
<li>The new <a class="reference internal" href="index.html#module-picamera.array" title="picamera.array"><code class="xref py py-mod docutils literal"><span class="pre">picamera.array</span></code></a> module provides a series of custom output
classes which can be used to easily obtain numpy arrays from a variety of
sources (<a class="reference external" href="https://github.com/waveform80/picamera/issues/107">#107</a>)</li>
<li>The <em>motion_output</em> parameter was added to
<a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> to enable output of motion
vector data generated by the H.264 encoder. A couple of new recipes were
added to the documentation to demonstrate this (<a class="reference external" href="https://github.com/waveform80/picamera/issues/94">#94</a>)</li>
<li>The ability to construct custom encoders was added, including some examples
in the documentation. Many thanks to user Oleksandr Sviridenko (d2rk) for
helping with the design of this feature! (<a class="reference external" href="https://github.com/waveform80/picamera/issues/97">#97</a>)</li>
<li>An example recipe was added to the documentation covering loading and
conversion of raw Bayer data (<a class="reference external" href="https://github.com/waveform80/picamera/issues/95">#95</a>)</li>
<li>Speed of unencoded RGB and BGR captures was substantially improved in both
Python 2 and 3 with a little optimization work. The warning about using
alpha-inclusive modes like RGBA has been removed as a result (<a class="reference external" href="https://github.com/waveform80/picamera/issues/103">#103</a>)</li>
<li>An issue with out-of-order calls to
<a class="reference internal" href="index.html#picamera.camera.PiCamera.stop_recording" title="picamera.camera.PiCamera.stop_recording"><code class="xref py py-meth docutils literal"><span class="pre">stop_recording()</span></code></a> when multiple recordings
were active was resolved (<a class="reference external" href="https://github.com/waveform80/picamera/issues/105">#105</a>)</li>
<li>Finally, picamera caught up with raspistill and raspivid by offering a
friendly error message when used with a disabled camera - thanks to Andrew
Scheller (lurch) for the suggestion! (<a class="reference external" href="https://github.com/waveform80/picamera/issues/89">#89</a>)</li>
</ul>
</div>
<div class="section" id="release-1-4-2014-05-06">
<h4>Release 1.4 (2014-05-06)<a class="headerlink" href="#release-1-4-2014-05-06" title="Permalink to this headline">¶</a></h4>
<p>1.4 mostly involved bug fixes with a couple of new bits of functionality:</p>
<ul class="simple">
<li>The <em>sei</em> parameter was added to
<a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> to permit inclusion of
&#8220;Supplemental Enhancement Information&#8221; in the output stream (<a class="reference external" href="https://github.com/waveform80/picamera/issues/77">#77</a>)</li>
<li>The <a class="reference internal" href="index.html#picamera.camera.PiCamera.awb_gains" title="picamera.camera.PiCamera.awb_gains"><code class="xref py py-attr docutils literal"><span class="pre">awb_gains</span></code></a> attribute was added to permit
manual control of the auto-white-balance red/blue gains (<a class="reference external" href="https://github.com/waveform80/picamera/issues/74">#74</a>)</li>
<li>A bug which cause <a class="reference internal" href="index.html#picamera.camera.PiCamera.split_recording" title="picamera.camera.PiCamera.split_recording"><code class="xref py py-meth docutils literal"><span class="pre">split_recording()</span></code></a> to fail
when low framerates were configured was fixed (<a class="reference external" href="https://github.com/waveform80/picamera/issues/87">#87</a>)</li>
<li>A bug which caused picamera to fail when used in UNIX-style daemons, unless
the module was imported <em>after</em> the double-fork to background was fixed
(<a class="reference external" href="https://github.com/waveform80/picamera/issues/85">#85</a>)</li>
<li>A bug which caused the <a class="reference internal" href="index.html#picamera.camera.PiCamera.frame" title="picamera.camera.PiCamera.frame"><code class="xref py py-attr docutils literal"><span class="pre">frame</span></code></a> attribute to
fail when queried in Python 3 was fixed (<a class="reference external" href="https://github.com/waveform80/picamera/issues/80">#80</a>)</li>
<li>A bug which caused raw captures with &#8220;odd&#8221; resolutions (like 100x100) to
fail was fixed (<a class="reference external" href="https://github.com/waveform80/picamera/issues/83">#83</a>)</li>
</ul>
<p>Known issues:</p>
<ul class="simple">
<li>Added a workaround for full-resolution YUV captures failing. This
isn&#8217;t a complete fix, and attempting to capture a JPEG before attempting to
capture full-resolution YUV data will still fail, unless the GPU memory split
is set to something huge like 256Mb (<a class="reference external" href="https://github.com/waveform80/picamera/issues/73">#73</a>)</li>
</ul>
<p>Many thanks to the community for yet more excellent quality bug reports!</p>
</div>
<div class="section" id="release-1-3-2014-03-22">
<h4>Release 1.3 (2014-03-22)<a class="headerlink" href="#release-1-3-2014-03-22" title="Permalink to this headline">¶</a></h4>
<p>1.3 was partly new functionality:</p>
<ul class="simple">
<li>The <em>bayer</em> parameter was added to the <code class="docutils literal"><span class="pre">'jpeg'</span></code> format in the capture
methods to permit output of the camera&#8217;s raw sensor data (<a class="reference external" href="https://github.com/waveform80/picamera/issues/52">#52</a>)</li>
<li>The <a class="reference internal" href="index.html#picamera.camera.PiCamera.record_sequence" title="picamera.camera.PiCamera.record_sequence"><code class="xref py py-meth docutils literal"><span class="pre">record_sequence()</span></code></a> method was added to
provide a cleaner interface for recording multiple consecutive video clips
(<a class="reference external" href="https://github.com/waveform80/picamera/issues/53">#53</a>)</li>
<li>The <em>splitter_port</em> parameter was added to all capture methods and
<a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> to permit recording
multiple simultaneous video streams (presumably with different options,
primarily <em>resize</em>) (<a class="reference external" href="https://github.com/waveform80/picamera/issues/56">#56</a>)</li>
<li>The limits on the <a class="reference internal" href="index.html#picamera.camera.PiCamera.framerate" title="picamera.camera.PiCamera.framerate"><code class="xref py py-attr docutils literal"><span class="pre">framerate</span></code></a> attribute were
increased after firmware #656 introduced numerous new camera modes including
90fps recording (at lower resolutions) (<a class="reference external" href="https://github.com/waveform80/picamera/issues/65">#65</a>)</li>
</ul>
<p>And partly bug fixes:</p>
<ul class="simple">
<li>It was reported that Exif metadata (including thumbnails) wasn&#8217;t fully
recorded in JPEG output (<a class="reference external" href="https://github.com/waveform80/picamera/issues/59">#59</a>)</li>
<li>Raw captures with <a class="reference internal" href="index.html#picamera.camera.PiCamera.capture_continuous" title="picamera.camera.PiCamera.capture_continuous"><code class="xref py py-meth docutils literal"><span class="pre">capture_continuous()</span></code></a> and
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture_sequence" title="picamera.camera.PiCamera.capture_sequence"><code class="xref py py-meth docutils literal"><span class="pre">capture_sequence()</span></code></a> were broken (<a class="reference external" href="https://github.com/waveform80/picamera/issues/55">#55</a>)</li>
</ul>
</div>
<div class="section" id="release-1-2-2014-02-02">
<h4>Release 1.2 (2014-02-02)<a class="headerlink" href="#release-1-2-2014-02-02" title="Permalink to this headline">¶</a></h4>
<p>1.2 was mostly a bug fix release:</p>
<ul class="simple">
<li>A bug introduced in 1.1 caused
<a class="reference internal" href="index.html#picamera.camera.PiCamera.split_recording" title="picamera.camera.PiCamera.split_recording"><code class="xref py py-meth docutils literal"><span class="pre">split_recording()</span></code></a> to fail if it was preceded
by a video-port-based image capture (<a class="reference external" href="https://github.com/waveform80/picamera/issues/49">#49</a>)</li>
<li>The documentation was enhanced to try and full explain the discrepancy
between preview and capture resolution, and to provide some insight into
the underlying workings of the camera (<a class="reference external" href="https://github.com/waveform80/picamera/issues/23">#23</a>)</li>
<li>A new property was introduced for configuring the preview&#8217;s layer at runtime
although this probably won&#8217;t find use until OpenGL overlays are explored
(<a class="reference external" href="https://github.com/waveform80/picamera/issues/48">#48</a>)</li>
</ul>
</div>
<div class="section" id="release-1-1-2014-01-25">
<h4>Release 1.1 (2014-01-25)<a class="headerlink" href="#release-1-1-2014-01-25" title="Permalink to this headline">¶</a></h4>
<p>1.1 was mostly a bug fix release:</p>
<ul class="simple">
<li>A nasty race condition was discovered which led to crashes with long-running
processes (<a class="reference external" href="https://github.com/waveform80/picamera/issues/40">#40</a>)</li>
<li>An assertion error raised when performing raw captures with an active resize
parameter was fixed (<a class="reference external" href="https://github.com/waveform80/picamera/issues/46">#46</a>)</li>
<li>A couple of documentation enhancements made it in (<a class="reference external" href="https://github.com/waveform80/picamera/issues/41">#41</a> and <a class="reference external" href="https://github.com/waveform80/picamera/issues/47">#47</a>)</li>
</ul>
</div>
<div class="section" id="release-1-0-2014-01-11">
<h4>Release 1.0 (2014-01-11)<a class="headerlink" href="#release-1-0-2014-01-11" title="Permalink to this headline">¶</a></h4>
<p>In 1.0 the major features added were:</p>
<ul class="simple">
<li>Debian packaging! (<a class="reference external" href="https://github.com/waveform80/picamera/issues/12">#12</a>)</li>
<li>The new <a class="reference internal" href="index.html#picamera.camera.PiCamera.frame" title="picamera.camera.PiCamera.frame"><code class="xref py py-attr docutils literal"><span class="pre">frame</span></code></a> attribute permits querying
information about the frame last written to the output stream (number,
timestamp, size, keyframe, etc.) (<a class="reference external" href="https://github.com/waveform80/picamera/issues/34">#34</a>, <a class="reference external" href="https://github.com/waveform80/picamera/issues/36">#36</a>)</li>
<li>All capture methods (<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a> et al), and
the <a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> method now accept a
<code class="docutils literal"><span class="pre">resize</span></code> parameter which invokes a resizer prior to the encoding step
(<a class="reference external" href="https://github.com/waveform80/picamera/issues/21">#21</a>)</li>
<li>A new <a class="reference internal" href="index.html#picamera.streams.PiCameraCircularIO" title="picamera.streams.PiCameraCircularIO"><code class="xref py py-class docutils literal"><span class="pre">PiCameraCircularIO</span></code></a> stream class is provided
to permit holding the last <em>n</em> seconds of video in memory, ready for writing
out to disk (or whatever you like) (<a class="reference external" href="https://github.com/waveform80/picamera/issues/39">#39</a>)</li>
<li>There&#8217;s a new way to specify raw captures - simply use the format you require
with the capture method of your choice. As a result of this, the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.raw_format" title="picamera.camera.PiCamera.raw_format"><code class="xref py py-attr docutils literal"><span class="pre">raw_format</span></code></a> attribute is now deprecated
(<a class="reference external" href="https://github.com/waveform80/picamera/issues/32">#32</a>)</li>
</ul>
<p>Some bugs were also fixed:</p>
<ul class="simple">
<li>GPIO.cleanup is no longer called on <a class="reference internal" href="index.html#picamera.camera.PiCamera.close" title="picamera.camera.PiCamera.close"><code class="xref py py-meth docutils literal"><span class="pre">close()</span></code></a>
(<a class="reference external" href="https://github.com/waveform80/picamera/issues/35">#35</a>), and GPIO set up is only done on first use of the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.led" title="picamera.camera.PiCamera.led"><code class="xref py py-attr docutils literal"><span class="pre">led</span></code></a> attribute which should resolve issues
that users have been having with using picamera in conjunction with GPIO</li>
<li>Raw RGB video-port based image captures are now working again too (<a class="reference external" href="https://github.com/waveform80/picamera/issues/32">#32</a>)</li>
</ul>
<p>As this is a new major-version, all deprecated elements were removed:</p>
<ul class="simple">
<li>The continuous method was removed; this was replaced by
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture_continuous" title="picamera.camera.PiCamera.capture_continuous"><code class="xref py py-meth docutils literal"><span class="pre">capture_continuous()</span></code></a> in 0.5 (<a class="reference external" href="https://github.com/waveform80/picamera/issues/7">#7</a>)</li>
</ul>
</div>
<div class="section" id="release-0-8-2013-12-09">
<h4>Release 0.8 (2013-12-09)<a class="headerlink" href="#release-0-8-2013-12-09" title="Permalink to this headline">¶</a></h4>
<p>In 0.8 the major features added were:</p>
<ul class="simple">
<li>Capture of images whilst recording without frame-drop. Previously, images
could be captured whilst recording but only from the still port which
resulted in dropped frames in the recorded video due to the mode switch. In
0.8, <code class="docutils literal"><span class="pre">use_video_port=True</span></code> can be specified on capture methods whilst
recording video to avoid this.</li>
<li>Splitting of video recordings into multiple files. This is done via the new
<a class="reference internal" href="index.html#picamera.camera.PiCamera.split_recording" title="picamera.camera.PiCamera.split_recording"><code class="xref py py-meth docutils literal"><span class="pre">split_recording()</span></code></a> method, and requires that the
<a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> method was called with
<em>inline_headers</em> set to True. The latter has now been made the default
(technically this is a backwards incompatible change, but it&#8217;s relatively
trivial and I don&#8217;t anticipate anyone&#8217;s code breaking because of this
change).</li>
</ul>
<p>In addition a few bugs were fixed:</p>
<ul class="simple">
<li>Documentation updates that were missing from 0.7 (specifically the new
video recording parameters)</li>
<li>The ability to perform raw captures through the video port</li>
<li>Missing exception imports in the encoders module (which caused very confusing
errors in the case that an exception was raised within an encoder thread)</li>
</ul>
</div>
<div class="section" id="release-0-7-2013-11-14">
<h4>Release 0.7 (2013-11-14)<a class="headerlink" href="#release-0-7-2013-11-14" title="Permalink to this headline">¶</a></h4>
<p>0.7 is mostly a bug fix release, with a few new video recording features:</p>
<ul class="simple">
<li>Added <code class="docutils literal"><span class="pre">quantisation</span></code> and <code class="docutils literal"><span class="pre">inline_headers</span></code> options to
<a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a> method</li>
<li>Fixed bugs in the <a class="reference internal" href="index.html#picamera.camera.PiCamera.crop" title="picamera.camera.PiCamera.crop"><code class="xref py py-attr docutils literal"><span class="pre">crop</span></code></a> property</li>
<li>The issue of captures fading to black over time when the preview is not
running has been resolved. This solution was to permanently activate the
preview, but pipe it to a null-sink when not required. Note that this means
rapid capture gets even slower when not using the video port</li>
<li>LED support is via RPi.GPIO only; the RPIO library simply doesn&#8217;t support it
at this time</li>
<li>Numerous documentation fixes</li>
</ul>
</div>
<div class="section" id="release-0-6-2013-10-30">
<h4>Release 0.6 (2013-10-30)<a class="headerlink" href="#release-0-6-2013-10-30" title="Permalink to this headline">¶</a></h4>
<p>In 0.6, the major features added were:</p>
<ul class="simple">
<li>New <code class="docutils literal"><span class="pre">'raw'</span></code> format added to all capture methods
(<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture" title="picamera.camera.PiCamera.capture"><code class="xref py py-meth docutils literal"><span class="pre">capture()</span></code></a>,
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture_continuous" title="picamera.camera.PiCamera.capture_continuous"><code class="xref py py-meth docutils literal"><span class="pre">capture_continuous()</span></code></a>, and
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture_sequence" title="picamera.camera.PiCamera.capture_sequence"><code class="xref py py-meth docutils literal"><span class="pre">capture_sequence()</span></code></a>) to permit capturing of
raw sensor data</li>
<li>New <a class="reference internal" href="index.html#picamera.camera.PiCamera.raw_format" title="picamera.camera.PiCamera.raw_format"><code class="xref py py-attr docutils literal"><span class="pre">raw_format</span></code></a> attribute to permit control
of raw format (defaults to <code class="docutils literal"><span class="pre">'yuv'</span></code>, only other setting currently is
<code class="docutils literal"><span class="pre">'rgb'</span></code>)</li>
<li>New <a class="reference internal" href="index.html#picamera.camera.PiCamera.shutter_speed" title="picamera.camera.PiCamera.shutter_speed"><code class="xref py py-attr docutils literal"><span class="pre">shutter_speed</span></code></a> attribute to permit
manual control of shutter speed (defaults to 0 for automatic shutter speed,
and requires latest firmware to operate - use <code class="docutils literal"><span class="pre">sudo</span> <span class="pre">rpi-update</span></code> to upgrade)</li>
<li>New &#8220;Recipes&#8221; chapter in the documentation which demonstrates a wide variety
of capture techniques ranging from trivial to complex</li>
</ul>
</div>
<div class="section" id="release-0-5-2013-10-21">
<h4>Release 0.5 (2013-10-21)<a class="headerlink" href="#release-0-5-2013-10-21" title="Permalink to this headline">¶</a></h4>
<p>In 0.5, the major features added were:</p>
<ul class="simple">
<li>New <a class="reference internal" href="index.html#picamera.camera.PiCamera.capture_sequence" title="picamera.camera.PiCamera.capture_sequence"><code class="xref py py-meth docutils literal"><span class="pre">capture_sequence()</span></code></a> method</li>
<li><code class="xref py py-meth docutils literal"><span class="pre">continuous()</span></code> method renamed to
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture_continuous" title="picamera.camera.PiCamera.capture_continuous"><code class="xref py py-meth docutils literal"><span class="pre">capture_continuous()</span></code></a>. Old method name
retained for compatiblity until 1.0.</li>
<li><em>use_video_port</em> option for
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture_sequence" title="picamera.camera.PiCamera.capture_sequence"><code class="xref py py-meth docutils literal"><span class="pre">capture_sequence()</span></code></a> and
<a class="reference internal" href="index.html#picamera.camera.PiCamera.capture_continuous" title="picamera.camera.PiCamera.capture_continuous"><code class="xref py py-meth docutils literal"><span class="pre">capture_continuous()</span></code></a> to allow rapid capture
of JPEGs via video port</li>
<li>New <a class="reference internal" href="index.html#picamera.camera.PiCamera.framerate" title="picamera.camera.PiCamera.framerate"><code class="xref py py-attr docutils literal"><span class="pre">framerate</span></code></a> attribute to control video
and rapid-image capture frame rates</li>
<li>Default value for <a class="reference internal" href="index.html#picamera.camera.PiCamera.ISO" title="picamera.camera.PiCamera.ISO"><code class="xref py py-attr docutils literal"><span class="pre">ISO</span></code></a> changed from 400 to 0
(auto) which fixes <a class="reference internal" href="index.html#picamera.camera.PiCamera.exposure_mode" title="picamera.camera.PiCamera.exposure_mode"><code class="xref py py-attr docutils literal"><span class="pre">exposure_mode</span></code></a> not
working by default</li>
<li><em>intraperiod</em> and <em>profile</em> options for
<a class="reference internal" href="index.html#picamera.camera.PiCamera.start_recording" title="picamera.camera.PiCamera.start_recording"><code class="xref py py-meth docutils literal"><span class="pre">start_recording()</span></code></a></li>
</ul>
<p>In addition a few bugs were fixed:</p>
<ul class="simple">
<li>Byte strings not being accepted by
<code class="xref py py-meth docutils literal"><span class="pre">continuous()</span></code></li>
<li>Erroneous docs for <code class="xref py py-attr docutils literal"><span class="pre">ISO</span></code></li>
</ul>
<p>Many thanks to the community for the bug reports!</p>
</div>
<div class="section" id="release-0-4-2013-10-11">
<h4>Release 0.4 (2013-10-11)<a class="headerlink" href="#release-0-4-2013-10-11" title="Permalink to this headline">¶</a></h4>
<p>In 0.4, several new attributes were introduced for configuration of the preview
window:</p>
<ul class="simple">
<li><a class="reference internal" href="index.html#picamera.camera.PiCamera.preview_alpha" title="picamera.camera.PiCamera.preview_alpha"><code class="xref py py-attr docutils literal"><span class="pre">preview_alpha</span></code></a></li>
<li><a class="reference internal" href="index.html#picamera.camera.PiCamera.preview_fullscreen" title="picamera.camera.PiCamera.preview_fullscreen"><code class="xref py py-attr docutils literal"><span class="pre">preview_fullscreen</span></code></a></li>
<li><a class="reference internal" href="index.html#picamera.camera.PiCamera.preview_window" title="picamera.camera.PiCamera.preview_window"><code class="xref py py-attr docutils literal"><span class="pre">preview_window</span></code></a></li>
</ul>
<p>Also, a new method for rapid continual capture of still images was introduced:
<code class="xref py py-meth docutils literal"><span class="pre">continuous()</span></code>.</p>
</div>
<div class="section" id="release-0-3-2013-10-04">
<h4>Release 0.3 (2013-10-04)<a class="headerlink" href="#release-0-3-2013-10-04" title="Permalink to this headline">¶</a></h4>
<p>The major change in 0.3 was the introduction of custom Exif tagging for
captured images, and fixing a silly bug which prevented more than one image
being captured during the lifetime of a PiCamera instance.</p>
</div>
<div class="section" id="release-0-2">
<h4>Release 0.2<a class="headerlink" href="#release-0-2" title="Permalink to this headline">¶</a></h4>
<p>The major change in 0.2 was support for video recording, along with the new
<a class="reference internal" href="index.html#picamera.camera.PiCamera.resolution" title="picamera.camera.PiCamera.resolution"><code class="xref py py-attr docutils literal"><span class="pre">resolution</span></code></a> property which replaced the separate
<code class="docutils literal"><span class="pre">preview_resolution</span></code> and <code class="docutils literal"><span class="pre">stills_resolution</span></code> properties.</p>
</div>
</div>
<span id="document-license"></span><div class="section" id="license">
<span id="id1"></span><h3>License<a class="headerlink" href="#license" title="Permalink to this headline">¶</a></h3>
<p>Copyright 2013-2015 <a class="reference external" href="mailto:dave&#37;&#52;&#48;waveform&#46;org&#46;uk">Dave Jones</a></p>
<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:</p>
<ul class="simple">
<li>Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.</li>
<li>Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.</li>
</ul>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &#8220;AS IS&#8221; AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<hr class="docutils" />
<p>The <a class="reference internal" href="index.html#bayer-data"><span>bayer pattern diagram</span></a> in the documentation is derived
from <a class="reference external" href="http://en.wikipedia.org/wiki/File:Bayer_pattern_on_sensor.svg">Bayer_pattern_on_sensor.svg</a> which is copyright (c) Colin Burnett
(User:Cburnett) on Wikipedia, modified under the terms of the GPL:</p>
<p>This work is free software; you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or any later version.  This work
is distributed in the hope that it will be useful, but without any warranty;
without even the implied warranty of merchantability or fitness for a
particular purpose. See version 2 and version 3 of the GNU General Public
License for more details.</p>
<hr class="docutils" />
<p>The <a class="reference internal" href="index.html#yuv-capture"><span>YUV420 planar diagram</span></a> in the documentation is
<a class="reference external" href="http://en.wikipedia.org/wiki/File:Yuv420.svg">Yuv420.svg</a> created by Geoff Richards (User:Qef) on Wikipedia, released into
the public domain.</p>
</div>
</div>
</div>
<div class="section" id="indices-and-tables">
<h2>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><span>Index</span></a></li>
<li><a class="reference internal" href="py-modindex.html"><span>Module Index</span></a></li>
<li><a class="reference internal" href="search.html"><span>Search Page</span></a></li>
</ul>
</div>
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2013,2014 Dave Jones.
      
        <span class="commit">
          Revision <code>6f36295e</code>.
        </span>
      

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Read the Docs</span>
      v: release-1.10
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Versions</dt>
        
          <dd><a href="/en/latest/">latest</a></dd>
        
          <dd><a href="/en/release-1.9/">release-1.9</a></dd>
        
          <dd><a href="/en/release-1.8/">release-1.8</a></dd>
        
          <dd><a href="/en/release-1.7/">release-1.7</a></dd>
        
          <dd><a href="/en/release-1.6/">release-1.6</a></dd>
        
          <dd><a href="/en/release-1.5/">release-1.5</a></dd>
        
          <dd><a href="/en/release-1.4/">release-1.4</a></dd>
        
          <dd><a href="/en/release-1.3/">release-1.3</a></dd>
        
          <dd><a href="/en/release-1.2/">release-1.2</a></dd>
        
          <dd><a href="/en/release-1.10/">release-1.10</a></dd>
        
          <dd><a href="/en/release-1.1/">release-1.1</a></dd>
        
          <dd><a href="/en/release-1.0/">release-1.0</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
          <dd><a href="//readthedocs.org/projects/picamera/downloads/pdf/release-1.10/">pdf</a></dd>
        
          <dd><a href="//readthedocs.org/projects/picamera/downloads/htmlzip/release-1.10/">htmlzip</a></dd>
        
          <dd><a href="//readthedocs.org/projects/picamera/downloads/epub/release-1.10/">epub</a></dd>
        
      </dl>
      <dl>
        <dt>On Read the Docs</dt>
          <dd>
            <a href="//readthedocs.org/projects/picamera/?fromdocs=picamera">Project Home</a>
          </dd>
          <dd>
            <a href="//readthedocs.org/builds/picamera/?fromdocs=picamera">Builds</a>
          </dd>
      </dl>
      <hr/>
      Free document hosting provided by <a href="http://www.readthedocs.org">Read the Docs</a>.

    </div>
  </div>



  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.10',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="https://media.readthedocs.org/javascript/jquery/jquery-2.0.3.min.js"></script>
      <script type="text/javascript" src="https://media.readthedocs.org/javascript/jquery/jquery-migrate-1.2.1.min.js"></script>
      <script type="text/javascript" src="https://media.readthedocs.org/javascript/underscore.js"></script>
      <script type="text/javascript" src="https://media.readthedocs.org/javascript/doctools.js"></script>
      <script type="text/javascript" src="https://media.readthedocs.org/javascript/readthedocs-doc-embed.js"></script>

  

  
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>